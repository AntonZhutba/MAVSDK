// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/striker/striker.proto)

#include <iomanip>

#include "striker_impl.h"
#include "plugins/striker/striker.h"

namespace mavsdk {

using ActuatorServosStatus = Striker::ActuatorServosStatus;
using Heartbeat = Striker::Heartbeat;
using SysStatus = Striker::SysStatus;
using RcChannel = Striker::RcChannel;
using Magnitometer = Striker::Magnitometer;
using BatteryVoltages = Striker::BatteryVoltages;
using AvailableMode = Striker::AvailableMode;

Striker::Striker(System& system) : PluginBase(), _impl{std::make_unique<StrikerImpl>(system)} {}

Striker::Striker(std::shared_ptr<System> system) :
    PluginBase(),
    _impl{std::make_unique<StrikerImpl>(system)}
{}

Striker::~Striker() {}

Striker::HeartbeatHandle Striker::subscribe_heartbeat(const HeartbeatCallback& callback)
{
    return _impl->subscribe_heartbeat(callback);
}

void Striker::unsubscribe_heartbeat(HeartbeatHandle handle)
{
    _impl->unsubscribe_heartbeat(handle);
}

Striker::Heartbeat Striker::heartbeat() const
{
    return _impl->heartbeat();
}

Striker::SysStatusHandle Striker::subscribe_sys_status(const SysStatusCallback& callback)
{
    return _impl->subscribe_sys_status(callback);
}

void Striker::unsubscribe_sys_status(SysStatusHandle handle)
{
    _impl->unsubscribe_sys_status(handle);
}

Striker::SysStatus Striker::sys_status() const
{
    return _impl->sys_status();
}

Striker::RcChannelHandle Striker::subscribe_rc_channel(const RcChannelCallback& callback)
{
    return _impl->subscribe_rc_channel(callback);
}

void Striker::unsubscribe_rc_channel(RcChannelHandle handle)
{
    _impl->unsubscribe_rc_channel(handle);
}

Striker::RcChannel Striker::rc_channel() const
{
    return _impl->rc_channel();
}

Striker::MagnitometerHandle Striker::subscribe_magnitometer(const MagnitometerCallback& callback)
{
    return _impl->subscribe_magnitometer(callback);
}

void Striker::unsubscribe_magnitometer(MagnitometerHandle handle)
{
    _impl->unsubscribe_magnitometer(handle);
}

Striker::Magnitometer Striker::magnitometer() const
{
    return _impl->magnitometer();
}

Striker::BatteryVoltagesHandle
Striker::subscribe_battery_voltages(const BatteryVoltagesCallback& callback)
{
    return _impl->subscribe_battery_voltages(callback);
}

void Striker::unsubscribe_battery_voltages(BatteryVoltagesHandle handle)
{
    _impl->unsubscribe_battery_voltages(handle);
}

Striker::BatteryVoltages Striker::battery_voltages() const
{
    return _impl->battery_voltages();
}

Striker::AvailableModesHandle
Striker::subscribe_available_modes(const AvailableModesCallback& callback)
{
    return _impl->subscribe_available_modes(callback);
}

void Striker::unsubscribe_available_modes(AvailableModesHandle handle)
{
    _impl->unsubscribe_available_modes(handle);
}

std::vector<Striker::AvailableMode> Striker::available_modes() const
{
    return _impl->available_modes();
}

void Striker::set_manual_flight_mode_async(
    uint32_t mode, uint32_t custom_mode, uint32_t custom_sub_mode, const ResultCallback callback)
{
    _impl->set_manual_flight_mode_async(mode, custom_mode, custom_sub_mode, callback);
}

Striker::Result
Striker::set_manual_flight_mode(uint32_t mode, uint32_t custom_mode, uint32_t custom_sub_mode) const
{
    return _impl->set_manual_flight_mode(mode, custom_mode, custom_sub_mode);
}

Striker::ActuatorServosStatusHandle
Striker::subscribe_actuator_servos_status(const ActuatorServosStatusCallback& callback)
{
    return _impl->subscribe_actuator_servos_status(callback);
}

void Striker::unsubscribe_actuator_servos_status(ActuatorServosStatusHandle handle)
{
    _impl->unsubscribe_actuator_servos_status(handle);
}

Striker::ActuatorServosStatus Striker::actuator_servos_status() const
{
    return _impl->actuator_servos_status();
}

void Striker::set_rate_actuator_servos_status_async(double rate_hz, const ResultCallback callback)
{
    _impl->set_rate_actuator_servos_status_async(rate_hz, callback);
}

Striker::Result Striker::set_rate_actuator_servos_status(double rate_hz) const
{
    return _impl->set_rate_actuator_servos_status(rate_hz);
}

bool operator==(const Striker::ActuatorServosStatus& lhs, const Striker::ActuatorServosStatus& rhs)
{
    return (rhs.time_usec == lhs.time_usec) && (rhs.control == lhs.control);
}

std::ostream&
operator<<(std::ostream& str, Striker::ActuatorServosStatus const& actuator_servos_status)
{
    str << std::setprecision(15);
    str << "actuator_servos_status:" << '\n' << "{\n";
    str << "    time_usec: " << actuator_servos_status.time_usec << '\n';
    str << "    control: [";
    for (auto it = actuator_servos_status.control.begin();
         it != actuator_servos_status.control.end();
         ++it) {
        str << *it;
        str << (it + 1 != actuator_servos_status.control.end() ? ", " : "]\n");
    }
    str << '}';
    return str;
}

bool operator==(const Striker::Heartbeat& lhs, const Striker::Heartbeat& rhs)
{
    return (rhs.custom_mode == lhs.custom_mode) && (rhs.type == lhs.type) &&
           (rhs.autopilot == lhs.autopilot) && (rhs.base_mode == lhs.base_mode) &&
           (rhs.system_status == lhs.system_status) && (rhs.mavlink_version == lhs.mavlink_version);
}

std::ostream& operator<<(std::ostream& str, Striker::Heartbeat const& heartbeat)
{
    str << std::setprecision(15);
    str << "heartbeat:" << '\n' << "{\n";
    str << "    custom_mode: " << heartbeat.custom_mode << '\n';
    str << "    type: " << heartbeat.type << '\n';
    str << "    autopilot: " << heartbeat.autopilot << '\n';
    str << "    base_mode: " << heartbeat.base_mode << '\n';
    str << "    system_status: " << heartbeat.system_status << '\n';
    str << "    mavlink_version: " << heartbeat.mavlink_version << '\n';
    str << '}';
    return str;
}

bool operator==(const Striker::SysStatus& lhs, const Striker::SysStatus& rhs)
{
    return (rhs.onboard_control_sensors_present == lhs.onboard_control_sensors_present) &&
           (rhs.onboard_control_sensors_enabled == lhs.onboard_control_sensors_enabled) &&
           (rhs.onboard_control_sensors_health == lhs.onboard_control_sensors_health) &&
           (rhs.load == lhs.load) && (rhs.voltage_battery == lhs.voltage_battery) &&
           (rhs.current_battery == lhs.current_battery) &&
           (rhs.drop_rate_comm == lhs.drop_rate_comm) && (rhs.errors_comm == lhs.errors_comm) &&
           (rhs.errors_count1 == lhs.errors_count1) && (rhs.errors_count2 == lhs.errors_count2) &&
           (rhs.errors_count3 == lhs.errors_count3) && (rhs.errors_count4 == lhs.errors_count4) &&
           (rhs.battery_remaining == lhs.battery_remaining) &&
           (rhs.onboard_control_sensors_present_extended ==
            lhs.onboard_control_sensors_present_extended) &&
           (rhs.onboard_control_sensors_enabled_extended ==
            lhs.onboard_control_sensors_enabled_extended) &&
           (rhs.onboard_control_sensors_health_extended ==
            lhs.onboard_control_sensors_health_extended);
}

std::ostream& operator<<(std::ostream& str, Striker::SysStatus const& sys_status)
{
    str << std::setprecision(15);
    str << "sys_status:" << '\n' << "{\n";
    str << "    onboard_control_sensors_present: " << sys_status.onboard_control_sensors_present
        << '\n';
    str << "    onboard_control_sensors_enabled: " << sys_status.onboard_control_sensors_enabled
        << '\n';
    str << "    onboard_control_sensors_health: " << sys_status.onboard_control_sensors_health
        << '\n';
    str << "    load: " << sys_status.load << '\n';
    str << "    voltage_battery: " << sys_status.voltage_battery << '\n';
    str << "    current_battery: " << sys_status.current_battery << '\n';
    str << "    drop_rate_comm: " << sys_status.drop_rate_comm << '\n';
    str << "    errors_comm: " << sys_status.errors_comm << '\n';
    str << "    errors_count1: " << sys_status.errors_count1 << '\n';
    str << "    errors_count2: " << sys_status.errors_count2 << '\n';
    str << "    errors_count3: " << sys_status.errors_count3 << '\n';
    str << "    errors_count4: " << sys_status.errors_count4 << '\n';
    str << "    battery_remaining: " << sys_status.battery_remaining << '\n';
    str << "    onboard_control_sensors_present_extended: "
        << sys_status.onboard_control_sensors_present_extended << '\n';
    str << "    onboard_control_sensors_enabled_extended: "
        << sys_status.onboard_control_sensors_enabled_extended << '\n';
    str << "    onboard_control_sensors_health_extended: "
        << sys_status.onboard_control_sensors_health_extended << '\n';
    str << '}';
    return str;
}

bool operator==(const Striker::RcChannel& lhs, const Striker::RcChannel& rhs)
{
    return (rhs.time_boot_ms == lhs.time_boot_ms) && (rhs.chan1_raw == lhs.chan1_raw) &&
           (rhs.chan2_raw == lhs.chan2_raw) && (rhs.chan3_raw == lhs.chan3_raw) &&
           (rhs.chan4_raw == lhs.chan4_raw) && (rhs.chan5_raw == lhs.chan5_raw) &&
           (rhs.chan6_raw == lhs.chan6_raw) && (rhs.chan7_raw == lhs.chan7_raw) &&
           (rhs.chan8_raw == lhs.chan8_raw) && (rhs.chan9_raw == lhs.chan9_raw) &&
           (rhs.chan10_raw == lhs.chan10_raw) && (rhs.chan11_raw == lhs.chan11_raw) &&
           (rhs.chan12_raw == lhs.chan12_raw) && (rhs.chan13_raw == lhs.chan13_raw) &&
           (rhs.chan14_raw == lhs.chan14_raw) && (rhs.chan15_raw == lhs.chan15_raw) &&
           (rhs.chan16_raw == lhs.chan16_raw) && (rhs.chan17_raw == lhs.chan17_raw) &&
           (rhs.chan18_raw == lhs.chan18_raw) && (rhs.chancount == lhs.chancount) &&
           (rhs.rssi == lhs.rssi);
}

std::ostream& operator<<(std::ostream& str, Striker::RcChannel const& rc_channel)
{
    str << std::setprecision(15);
    str << "rc_channel:" << '\n' << "{\n";
    str << "    time_boot_ms: " << rc_channel.time_boot_ms << '\n';
    str << "    chan1_raw: " << rc_channel.chan1_raw << '\n';
    str << "    chan2_raw: " << rc_channel.chan2_raw << '\n';
    str << "    chan3_raw: " << rc_channel.chan3_raw << '\n';
    str << "    chan4_raw: " << rc_channel.chan4_raw << '\n';
    str << "    chan5_raw: " << rc_channel.chan5_raw << '\n';
    str << "    chan6_raw: " << rc_channel.chan6_raw << '\n';
    str << "    chan7_raw: " << rc_channel.chan7_raw << '\n';
    str << "    chan8_raw: " << rc_channel.chan8_raw << '\n';
    str << "    chan9_raw: " << rc_channel.chan9_raw << '\n';
    str << "    chan10_raw: " << rc_channel.chan10_raw << '\n';
    str << "    chan11_raw: " << rc_channel.chan11_raw << '\n';
    str << "    chan12_raw: " << rc_channel.chan12_raw << '\n';
    str << "    chan13_raw: " << rc_channel.chan13_raw << '\n';
    str << "    chan14_raw: " << rc_channel.chan14_raw << '\n';
    str << "    chan15_raw: " << rc_channel.chan15_raw << '\n';
    str << "    chan16_raw: " << rc_channel.chan16_raw << '\n';
    str << "    chan17_raw: " << rc_channel.chan17_raw << '\n';
    str << "    chan18_raw: " << rc_channel.chan18_raw << '\n';
    str << "    chancount: " << rc_channel.chancount << '\n';
    str << "    rssi: " << rc_channel.rssi << '\n';
    str << '}';
    return str;
}

bool operator==(const Striker::Magnitometer& lhs, const Striker::Magnitometer& rhs)
{
    return ((std::isnan(rhs.x) && std::isnan(lhs.x)) || rhs.x == lhs.x) &&
           ((std::isnan(rhs.y) && std::isnan(lhs.y)) || rhs.y == lhs.y) &&
           ((std::isnan(rhs.z) && std::isnan(lhs.z)) || rhs.z == lhs.z) &&
           ((std::isnan(rhs.magnetic_heading) && std::isnan(lhs.magnetic_heading)) ||
            rhs.magnetic_heading == lhs.magnetic_heading);
}

std::ostream& operator<<(std::ostream& str, Striker::Magnitometer const& magnitometer)
{
    str << std::setprecision(15);
    str << "magnitometer:" << '\n' << "{\n";
    str << "    x: " << magnitometer.x << '\n';
    str << "    y: " << magnitometer.y << '\n';
    str << "    z: " << magnitometer.z << '\n';
    str << "    magnetic_heading: " << magnitometer.magnetic_heading << '\n';
    str << '}';
    return str;
}

bool operator==(const Striker::BatteryVoltages& lhs, const Striker::BatteryVoltages& rhs)
{
    return (rhs.voltages == lhs.voltages) && (rhs.ext_voltages == lhs.ext_voltages);
}

std::ostream& operator<<(std::ostream& str, Striker::BatteryVoltages const& battery_voltages)
{
    str << std::setprecision(15);
    str << "battery_voltages:" << '\n' << "{\n";
    str << "    voltages: [";
    for (auto it = battery_voltages.voltages.begin(); it != battery_voltages.voltages.end(); ++it) {
        str << *it;
        str << (it + 1 != battery_voltages.voltages.end() ? ", " : "]\n");
    }
    str << "    ext_voltages: [";
    for (auto it = battery_voltages.ext_voltages.begin(); it != battery_voltages.ext_voltages.end();
         ++it) {
        str << *it;
        str << (it + 1 != battery_voltages.ext_voltages.end() ? ", " : "]\n");
    }
    str << '}';
    return str;
}

bool operator==(const Striker::AvailableMode& lhs, const Striker::AvailableMode& rhs)
{
    return (rhs.number_modes == lhs.number_modes) && (rhs.mode_index == lhs.mode_index) &&
           (rhs.standard_mode == lhs.standard_mode) && (rhs.custom_mode == lhs.custom_mode) &&
           (rhs.properties == lhs.properties) && (rhs.mode_name == lhs.mode_name);
}

std::ostream& operator<<(std::ostream& str, Striker::AvailableMode const& available_mode)
{
    str << std::setprecision(15);
    str << "available_mode:" << '\n' << "{\n";
    str << "    number_modes: " << available_mode.number_modes << '\n';
    str << "    mode_index: " << available_mode.mode_index << '\n';
    str << "    standard_mode: " << available_mode.standard_mode << '\n';
    str << "    custom_mode: " << available_mode.custom_mode << '\n';
    str << "    properties: " << available_mode.properties << '\n';
    str << "    mode_name: " << available_mode.mode_name << '\n';
    str << '}';
    return str;
}

std::ostream& operator<<(std::ostream& str, Striker::Result const& result)
{
    switch (result) {
        case Striker::Result::Unknown:
            return str << "Unknown";
        case Striker::Result::Success:
            return str << "Success";
        case Striker::Result::NoSystem:
            return str << "No System";
        case Striker::Result::ConnectionError:
            return str << "Connection Error";
        case Striker::Result::Busy:
            return str << "Busy";
        case Striker::Result::CommandDenied:
            return str << "Command Denied";
        case Striker::Result::CommandDeniedLandedStateUnknown:
            return str << "Command Denied Landed State Unknown";
        case Striker::Result::CommandDeniedNotLanded:
            return str << "Command Denied Not Landed";
        case Striker::Result::Timeout:
            return str << "Timeout";
        case Striker::Result::VtolTransitionSupportUnknown:
            return str << "Vtol Transition Support Unknown";
        case Striker::Result::NoVtolTransitionSupport:
            return str << "No Vtol Transition Support";
        case Striker::Result::ParameterError:
            return str << "Parameter Error";
        case Striker::Result::Unsupported:
            return str << "Unsupported";
        case Striker::Result::Failed:
            return str << "Failed";
        case Striker::Result::InvalidArgument:
            return str << "Invalid Argument";
        default:
            return str << "Unknown";
    }
}

} // namespace mavsdk