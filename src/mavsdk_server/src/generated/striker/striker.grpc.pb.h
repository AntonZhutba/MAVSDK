// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: striker/striker.proto
#ifndef GRPC_striker_2fstriker_2eproto__INCLUDED
#define GRPC_striker_2fstriker_2eproto__INCLUDED

#include "striker/striker.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace mavsdk {
namespace rpc {
namespace striker {

//
// Allow users to get vehicle telemetry and state information
class StrikerService final {
 public:
  static constexpr char const* service_full_name() {
    return "mavsdk.rpc.striker.StrikerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Subscribe to 'Heartbeat' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>> SubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>>(SubscribeHeartbeatRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>> AsyncSubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>>(AsyncSubscribeHeartbeatRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>> PrepareAsyncSubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>>(PrepareAsyncSubscribeHeartbeatRaw(context, request, cq));
    }
    // Subscribe to 'Sys Status' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>> SubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>>(SubscribeSysStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>> AsyncSubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>>(AsyncSubscribeSysStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>> PrepareAsyncSubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>>(PrepareAsyncSubscribeSysStatusRaw(context, request, cq));
    }
    // Subscribe to 'RC channel' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>> SubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>>(SubscribeRcChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>> AsyncSubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>>(AsyncSubscribeRcChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>> PrepareAsyncSubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>>(PrepareAsyncSubscribeRcChannelRaw(context, request, cq));
    }
    // Subscribe to 'Magnitometer' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>> SubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>>(SubscribeMagnitometerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>> AsyncSubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>>(AsyncSubscribeMagnitometerRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>> PrepareAsyncSubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>>(PrepareAsyncSubscribeMagnitometerRaw(context, request, cq));
    }
    // Subscribe to 'Battery voltage' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> SubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(SubscribeBatteryVoltagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> AsyncSubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(AsyncSubscribeBatteryVoltagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> PrepareAsyncSubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(PrepareAsyncSubscribeBatteryVoltagesRaw(context, request, cq));
    }
    // Subscribe to 'Available Modes' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>> SubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>>(SubscribeAvailableModesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>> AsyncSubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>>(AsyncSubscribeAvailableModesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>> PrepareAsyncSubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>>(PrepareAsyncSubscribeAvailableModesRaw(context, request, cq));
    }
    // Set the vehicle mode.
    virtual ::grpc::Status SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>> AsyncSetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>>(AsyncSetManualFlightModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>> PrepareAsyncSetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>>(PrepareAsyncSetManualFlightModeRaw(context, request, cq));
    }
    // Subscribe to 'Actuator Servos Status' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> SubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(SubscribeActuatorServosStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> AsyncSubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(AsyncSubscribeActuatorServosStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> PrepareAsyncSubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(PrepareAsyncSubscribeActuatorServosStatusRaw(context, request, cq));
    }
    // Set the actuator control target.
    virtual ::grpc::Status SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>> AsyncSetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>>(AsyncSetRateActuatorServosStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>> PrepareAsyncSetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>>(PrepareAsyncSetRateActuatorServosStatusRaw(context, request, cq));
    }
    // Request available modes.
    virtual ::grpc::Status RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>> AsyncRequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>>(AsyncRequestAvailableModesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>> PrepareAsyncRequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>>(PrepareAsyncRequestAvailableModesRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Subscribe to 'Heartbeat' updates.
      virtual void SubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::HeartbeatResponse>* reactor) = 0;
      // Subscribe to 'Sys Status' updates.
      virtual void SubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::SysStatusResponse>* reactor) = 0;
      // Subscribe to 'RC channel' updates.
      virtual void SubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::RcChannelResponse>* reactor) = 0;
      // Subscribe to 'Magnitometer' updates.
      virtual void SubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::MagnitometerResponse>* reactor) = 0;
      // Subscribe to 'Battery voltage' updates.
      virtual void SubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* reactor) = 0;
      // Subscribe to 'Available Modes' updates.
      virtual void SubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::AvailableModesResponse>* reactor) = 0;
      // Set the vehicle mode.
      virtual void SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Subscribe to 'Actuator Servos Status' updates.
      virtual void SubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* reactor) = 0;
      // Set the actuator control target.
      virtual void SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Request available modes.
      virtual void RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>* SubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>* AsyncSubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::HeartbeatResponse>* PrepareAsyncSubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>* SubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>* AsyncSubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::SysStatusResponse>* PrepareAsyncSubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>* SubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>* AsyncSubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::RcChannelResponse>* PrepareAsyncSubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>* SubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>* AsyncSubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::MagnitometerResponse>* PrepareAsyncSubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* SubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* AsyncSubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* PrepareAsyncSubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>* SubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>* AsyncSubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::AvailableModesResponse>* PrepareAsyncSubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>* AsyncSetManualFlightModeRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetManualFlightModeResponse>* PrepareAsyncSetManualFlightModeRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* SubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* AsyncSubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* PrepareAsyncSubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* AsyncSetRateActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* PrepareAsyncSetRateActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>* AsyncRequestAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::striker::RequestAvailableModesResponse>* PrepareAsyncRequestAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::HeartbeatResponse>> SubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::HeartbeatResponse>>(SubscribeHeartbeatRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>> AsyncSubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>>(AsyncSubscribeHeartbeatRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>> PrepareAsyncSubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>>(PrepareAsyncSubscribeHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::SysStatusResponse>> SubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::SysStatusResponse>>(SubscribeSysStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>> AsyncSubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>>(AsyncSubscribeSysStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>> PrepareAsyncSubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>>(PrepareAsyncSubscribeSysStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::RcChannelResponse>> SubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::RcChannelResponse>>(SubscribeRcChannelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>> AsyncSubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>>(AsyncSubscribeRcChannelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>> PrepareAsyncSubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>>(PrepareAsyncSubscribeRcChannelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::MagnitometerResponse>> SubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::MagnitometerResponse>>(SubscribeMagnitometerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>> AsyncSubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>>(AsyncSubscribeMagnitometerRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>> PrepareAsyncSubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>>(PrepareAsyncSubscribeMagnitometerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> SubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(SubscribeBatteryVoltagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> AsyncSubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(AsyncSubscribeBatteryVoltagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>> PrepareAsyncSubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>>(PrepareAsyncSubscribeBatteryVoltagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::AvailableModesResponse>> SubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::AvailableModesResponse>>(SubscribeAvailableModesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>> AsyncSubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>>(AsyncSubscribeAvailableModesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>> PrepareAsyncSubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>>(PrepareAsyncSubscribeAvailableModesRaw(context, request, cq));
    }
    ::grpc::Status SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>> AsyncSetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>>(AsyncSetManualFlightModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>> PrepareAsyncSetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>>(PrepareAsyncSetManualFlightModeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> SubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(SubscribeActuatorServosStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> AsyncSubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(AsyncSubscribeActuatorServosStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>> PrepareAsyncSubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>>(PrepareAsyncSubscribeActuatorServosStatusRaw(context, request, cq));
    }
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>> AsyncSetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>>(AsyncSetRateActuatorServosStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>> PrepareAsyncSetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>>(PrepareAsyncSetRateActuatorServosStatusRaw(context, request, cq));
    }
    ::grpc::Status RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>> AsyncRequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>>(AsyncRequestAvailableModesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>> PrepareAsyncRequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>>(PrepareAsyncRequestAvailableModesRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SubscribeHeartbeat(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::HeartbeatResponse>* reactor) override;
      void SubscribeSysStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::SysStatusResponse>* reactor) override;
      void SubscribeRcChannel(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::RcChannelResponse>* reactor) override;
      void SubscribeMagnitometer(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::MagnitometerResponse>* reactor) override;
      void SubscribeBatteryVoltages(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* reactor) override;
      void SubscribeAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::AvailableModesResponse>* reactor) override;
      void SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response, std::function<void(::grpc::Status)>) override;
      void SetManualFlightMode(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubscribeActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* reactor) override;
      void SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void SetRateActuatorServosStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response, std::function<void(::grpc::Status)>) override;
      void RequestAvailableModes(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::mavsdk::rpc::striker::HeartbeatResponse>* SubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>* AsyncSubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::HeartbeatResponse>* PrepareAsyncSubscribeHeartbeatRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::SysStatusResponse>* SubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>* AsyncSubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::SysStatusResponse>* PrepareAsyncSubscribeSysStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::RcChannelResponse>* SubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>* AsyncSubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::RcChannelResponse>* PrepareAsyncSubscribeRcChannelRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::MagnitometerResponse>* SubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>* AsyncSubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::MagnitometerResponse>* PrepareAsyncSubscribeMagnitometerRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* SubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* AsyncSubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* PrepareAsyncSubscribeBatteryVoltagesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::AvailableModesResponse>* SubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>* AsyncSubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::AvailableModesResponse>* PrepareAsyncSubscribeAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>* AsyncSetManualFlightModeRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetManualFlightModeResponse>* PrepareAsyncSetManualFlightModeRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* SubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* AsyncSubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* PrepareAsyncSubscribeActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* AsyncSetRateActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* PrepareAsyncSetRateActuatorServosStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>* AsyncRequestAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::striker::RequestAvailableModesResponse>* PrepareAsyncRequestAvailableModesRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeSysStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeRcChannel_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeMagnitometer_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeBatteryVoltages_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeAvailableModes_;
    const ::grpc::internal::RpcMethod rpcmethod_SetManualFlightMode_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeActuatorServosStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRateActuatorServosStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestAvailableModes_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Subscribe to 'Heartbeat' updates.
    virtual ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* writer);
    // Subscribe to 'Sys Status' updates.
    virtual ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* writer);
    // Subscribe to 'RC channel' updates.
    virtual ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* writer);
    // Subscribe to 'Magnitometer' updates.
    virtual ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* writer);
    // Subscribe to 'Battery voltage' updates.
    virtual ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* writer);
    // Subscribe to 'Available Modes' updates.
    virtual ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* writer);
    // Set the vehicle mode.
    virtual ::grpc::Status SetManualFlightMode(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response);
    // Subscribe to 'Actuator Servos Status' updates.
    virtual ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* writer);
    // Set the actuator control target.
    virtual ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response);
    // Request available modes.
    virtual ::grpc::Status RequestAvailableModes(::grpc::ServerContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeHeartbeat(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeSysStatus(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeSysStatusRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::SysStatusResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeRcChannel(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeRcChannelRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::RcChannelResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeMagnitometer(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeBatteryVoltages(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeAvailableModes(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualFlightMode(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::striker::SetManualFlightModeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeActuatorServosStatus(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRateActuatorServosStatus(::grpc::ServerContext* context, ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestAvailableModes(::grpc::ServerContext* context, ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::striker::RequestAvailableModesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SubscribeHeartbeat<WithAsyncMethod_SubscribeSysStatus<WithAsyncMethod_SubscribeRcChannel<WithAsyncMethod_SubscribeMagnitometer<WithAsyncMethod_SubscribeBatteryVoltages<WithAsyncMethod_SubscribeAvailableModes<WithAsyncMethod_SetManualFlightMode<WithAsyncMethod_SubscribeActuatorServosStatus<WithAsyncMethod_SetRateActuatorServosStatus<WithAsyncMethod_RequestAvailableModes<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeHeartbeatRequest, ::mavsdk::rpc::striker::HeartbeatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* request) { return this->SubscribeHeartbeat(context, request); }));
    }
    ~WithCallbackMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::HeartbeatResponse>* SubscribeHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeSysStatusRequest, ::mavsdk::rpc::striker::SysStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* request) { return this->SubscribeSysStatus(context, request); }));
    }
    ~WithCallbackMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::SysStatusResponse>* SubscribeSysStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeRcChannelRequest, ::mavsdk::rpc::striker::RcChannelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* request) { return this->SubscribeRcChannel(context, request); }));
    }
    ~WithCallbackMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::RcChannelResponse>* SubscribeRcChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeMagnitometerRequest, ::mavsdk::rpc::striker::MagnitometerResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* request) { return this->SubscribeMagnitometer(context, request); }));
    }
    ~WithCallbackMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::MagnitometerResponse>* SubscribeMagnitometer(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest, ::mavsdk::rpc::striker::BatteryVoltagesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* request) { return this->SubscribeBatteryVoltages(context, request); }));
    }
    ~WithCallbackMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* SubscribeBatteryVoltages(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeAvailableModesRequest, ::mavsdk::rpc::striker::AvailableModesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* request) { return this->SubscribeAvailableModes(context, request); }));
    }
    ~WithCallbackMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::AvailableModesResponse>* SubscribeAvailableModes(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::SetManualFlightModeRequest, ::mavsdk::rpc::striker::SetManualFlightModeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* request, ::mavsdk::rpc::striker::SetManualFlightModeResponse* response) { return this->SetManualFlightMode(context, request, response); }));}
    void SetMessageAllocatorFor_SetManualFlightMode(
        ::grpc::MessageAllocator< ::mavsdk::rpc::striker::SetManualFlightModeRequest, ::mavsdk::rpc::striker::SetManualFlightModeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::SetManualFlightModeRequest, ::mavsdk::rpc::striker::SetManualFlightModeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualFlightMode(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest, ::mavsdk::rpc::striker::ActuatorServosStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* request) { return this->SubscribeActuatorServosStatus(context, request); }));
    }
    ~WithCallbackMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* SubscribeActuatorServosStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* request, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* response) { return this->SetRateActuatorServosStatus(context, request, response); }));}
    void SetMessageAllocatorFor_SetRateActuatorServosStatus(
        ::grpc::MessageAllocator< ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRateActuatorServosStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::RequestAvailableModesRequest, ::mavsdk::rpc::striker::RequestAvailableModesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* request, ::mavsdk::rpc::striker::RequestAvailableModesResponse* response) { return this->RequestAvailableModes(context, request, response); }));}
    void SetMessageAllocatorFor_RequestAvailableModes(
        ::grpc::MessageAllocator< ::mavsdk::rpc::striker::RequestAvailableModesRequest, ::mavsdk::rpc::striker::RequestAvailableModesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::striker::RequestAvailableModesRequest, ::mavsdk::rpc::striker::RequestAvailableModesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestAvailableModes(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SubscribeHeartbeat<WithCallbackMethod_SubscribeSysStatus<WithCallbackMethod_SubscribeRcChannel<WithCallbackMethod_SubscribeMagnitometer<WithCallbackMethod_SubscribeBatteryVoltages<WithCallbackMethod_SubscribeAvailableModes<WithCallbackMethod_SetManualFlightMode<WithCallbackMethod_SubscribeActuatorServosStatus<WithCallbackMethod_SetRateActuatorServosStatus<WithCallbackMethod_RequestAvailableModes<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeSysStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeRcChannel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeMagnitometer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeBatteryVoltages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeAvailableModes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetManualFlightMode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeActuatorServosStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRateActuatorServosStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestAvailableModes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeHeartbeat(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeSysStatus(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeSysStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeRcChannel(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeRcChannel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeMagnitometer(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeMagnitometer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeBatteryVoltages(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeBatteryVoltages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeAvailableModes(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeAvailableModes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetManualFlightMode(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetManualFlightMode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeActuatorServosStatus(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeActuatorServosStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRateActuatorServosStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRateActuatorServosStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestAvailableModes(context, request, response); }));
    }
    ~WithRawCallbackMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestAvailableModes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetManualFlightMode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetManualFlightMode() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::striker::SetManualFlightModeRequest, ::mavsdk::rpc::striker::SetManualFlightModeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::striker::SetManualFlightModeRequest, ::mavsdk::rpc::striker::SetManualFlightModeResponse>* streamer) {
                       return this->StreamedSetManualFlightMode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetManualFlightMode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetManualFlightMode(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetManualFlightModeRequest* /*request*/, ::mavsdk::rpc::striker::SetManualFlightModeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetManualFlightMode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::striker::SetManualFlightModeRequest,::mavsdk::rpc::striker::SetManualFlightModeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRateActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRateActuatorServosStatus() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* streamer) {
                       return this->StreamedSetRateActuatorServosStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRateActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRateActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest* /*request*/, ::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRateActuatorServosStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::striker::SetRateActuatorServosStatusRequest,::mavsdk::rpc::striker::SetRateActuatorServosStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestAvailableModes() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::striker::RequestAvailableModesRequest, ::mavsdk::rpc::striker::RequestAvailableModesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::striker::RequestAvailableModesRequest, ::mavsdk::rpc::striker::RequestAvailableModesResponse>* streamer) {
                       return this->StreamedRequestAvailableModes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::RequestAvailableModesRequest* /*request*/, ::mavsdk::rpc::striker::RequestAvailableModesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestAvailableModes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::striker::RequestAvailableModesRequest,::mavsdk::rpc::striker::RequestAvailableModesResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetManualFlightMode<WithStreamedUnaryMethod_SetRateActuatorServosStatus<WithStreamedUnaryMethod_RequestAvailableModes<Service > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeHeartbeatRequest, ::mavsdk::rpc::striker::HeartbeatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeHeartbeatRequest, ::mavsdk::rpc::striker::HeartbeatResponse>* streamer) {
                       return this->StreamedSubscribeHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeHeartbeat(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeHeartbeatRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::HeartbeatResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeHeartbeat(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeHeartbeatRequest,::mavsdk::rpc::striker::HeartbeatResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeSysStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeSysStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeSysStatusRequest, ::mavsdk::rpc::striker::SysStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeSysStatusRequest, ::mavsdk::rpc::striker::SysStatusResponse>* streamer) {
                       return this->StreamedSubscribeSysStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeSysStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeSysStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeSysStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::SysStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeSysStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeSysStatusRequest,::mavsdk::rpc::striker::SysStatusResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeRcChannel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeRcChannel() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeRcChannelRequest, ::mavsdk::rpc::striker::RcChannelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeRcChannelRequest, ::mavsdk::rpc::striker::RcChannelResponse>* streamer) {
                       return this->StreamedSubscribeRcChannel(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeRcChannel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeRcChannel(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeRcChannelRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::RcChannelResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeRcChannel(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeRcChannelRequest,::mavsdk::rpc::striker::RcChannelResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeMagnitometer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeMagnitometer() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeMagnitometerRequest, ::mavsdk::rpc::striker::MagnitometerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeMagnitometerRequest, ::mavsdk::rpc::striker::MagnitometerResponse>* streamer) {
                       return this->StreamedSubscribeMagnitometer(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeMagnitometer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeMagnitometer(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeMagnitometerRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::MagnitometerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeMagnitometer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeMagnitometerRequest,::mavsdk::rpc::striker::MagnitometerResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeBatteryVoltages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeBatteryVoltages() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest, ::mavsdk::rpc::striker::BatteryVoltagesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest, ::mavsdk::rpc::striker::BatteryVoltagesResponse>* streamer) {
                       return this->StreamedSubscribeBatteryVoltages(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeBatteryVoltages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeBatteryVoltages(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::BatteryVoltagesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeBatteryVoltages(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeBatteryVoltagesRequest,::mavsdk::rpc::striker::BatteryVoltagesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeAvailableModes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeAvailableModes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeAvailableModesRequest, ::mavsdk::rpc::striker::AvailableModesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeAvailableModesRequest, ::mavsdk::rpc::striker::AvailableModesResponse>* streamer) {
                       return this->StreamedSubscribeAvailableModes(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeAvailableModes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeAvailableModes(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeAvailableModesRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::AvailableModesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeAvailableModes(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeAvailableModesRequest,::mavsdk::rpc::striker::AvailableModesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeActuatorServosStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeActuatorServosStatus() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest, ::mavsdk::rpc::striker::ActuatorServosStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest, ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* streamer) {
                       return this->StreamedSubscribeActuatorServosStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeActuatorServosStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeActuatorServosStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::striker::ActuatorServosStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeActuatorServosStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::striker::SubscribeActuatorServosStatusRequest,::mavsdk::rpc::striker::ActuatorServosStatusResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeHeartbeat<WithSplitStreamingMethod_SubscribeSysStatus<WithSplitStreamingMethod_SubscribeRcChannel<WithSplitStreamingMethod_SubscribeMagnitometer<WithSplitStreamingMethod_SubscribeBatteryVoltages<WithSplitStreamingMethod_SubscribeAvailableModes<WithSplitStreamingMethod_SubscribeActuatorServosStatus<Service > > > > > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_SubscribeHeartbeat<WithSplitStreamingMethod_SubscribeSysStatus<WithSplitStreamingMethod_SubscribeRcChannel<WithSplitStreamingMethod_SubscribeMagnitometer<WithSplitStreamingMethod_SubscribeBatteryVoltages<WithSplitStreamingMethod_SubscribeAvailableModes<WithStreamedUnaryMethod_SetManualFlightMode<WithSplitStreamingMethod_SubscribeActuatorServosStatus<WithStreamedUnaryMethod_SetRateActuatorServosStatus<WithStreamedUnaryMethod_RequestAvailableModes<Service > > > > > > > > > > StreamedService;
};

}  // namespace striker
}  // namespace rpc
}  // namespace mavsdk


#endif  // GRPC_striker_2fstriker_2eproto__INCLUDED
