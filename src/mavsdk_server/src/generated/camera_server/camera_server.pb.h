// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera_server/camera_server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_camera_5fserver_2fcamera_5fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_camera_5fserver_2fcamera_5fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mavsdk_options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_camera_5fserver_2fcamera_5fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_camera_5fserver_2fcamera_5fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_camera_5fserver_2fcamera_5fserver_2eproto;
namespace mavsdk {
namespace rpc {
namespace camera_server {
class CameraServerResult;
struct CameraServerResultDefaultTypeInternal;
extern CameraServerResultDefaultTypeInternal _CameraServerResult_default_instance_;
class CaptureInfo;
struct CaptureInfoDefaultTypeInternal;
extern CaptureInfoDefaultTypeInternal _CaptureInfo_default_instance_;
class CaptureStatus;
struct CaptureStatusDefaultTypeInternal;
extern CaptureStatusDefaultTypeInternal _CaptureStatus_default_instance_;
class CaptureStatusResponse;
struct CaptureStatusResponseDefaultTypeInternal;
extern CaptureStatusResponseDefaultTypeInternal _CaptureStatusResponse_default_instance_;
class FormatStorageResponse;
struct FormatStorageResponseDefaultTypeInternal;
extern FormatStorageResponseDefaultTypeInternal _FormatStorageResponse_default_instance_;
class Information;
struct InformationDefaultTypeInternal;
extern InformationDefaultTypeInternal _Information_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class ResetSettingsResponse;
struct ResetSettingsResponseDefaultTypeInternal;
extern ResetSettingsResponseDefaultTypeInternal _ResetSettingsResponse_default_instance_;
class RespondCaptureStatusRequest;
struct RespondCaptureStatusRequestDefaultTypeInternal;
extern RespondCaptureStatusRequestDefaultTypeInternal _RespondCaptureStatusRequest_default_instance_;
class RespondCaptureStatusResponse;
struct RespondCaptureStatusResponseDefaultTypeInternal;
extern RespondCaptureStatusResponseDefaultTypeInternal _RespondCaptureStatusResponse_default_instance_;
class RespondFormatStorageRequest;
struct RespondFormatStorageRequestDefaultTypeInternal;
extern RespondFormatStorageRequestDefaultTypeInternal _RespondFormatStorageRequest_default_instance_;
class RespondFormatStorageResponse;
struct RespondFormatStorageResponseDefaultTypeInternal;
extern RespondFormatStorageResponseDefaultTypeInternal _RespondFormatStorageResponse_default_instance_;
class RespondResetSettingsRequest;
struct RespondResetSettingsRequestDefaultTypeInternal;
extern RespondResetSettingsRequestDefaultTypeInternal _RespondResetSettingsRequest_default_instance_;
class RespondResetSettingsResponse;
struct RespondResetSettingsResponseDefaultTypeInternal;
extern RespondResetSettingsResponseDefaultTypeInternal _RespondResetSettingsResponse_default_instance_;
class RespondSetModeRequest;
struct RespondSetModeRequestDefaultTypeInternal;
extern RespondSetModeRequestDefaultTypeInternal _RespondSetModeRequest_default_instance_;
class RespondSetModeResponse;
struct RespondSetModeResponseDefaultTypeInternal;
extern RespondSetModeResponseDefaultTypeInternal _RespondSetModeResponse_default_instance_;
class RespondStartVideoRequest;
struct RespondStartVideoRequestDefaultTypeInternal;
extern RespondStartVideoRequestDefaultTypeInternal _RespondStartVideoRequest_default_instance_;
class RespondStartVideoResponse;
struct RespondStartVideoResponseDefaultTypeInternal;
extern RespondStartVideoResponseDefaultTypeInternal _RespondStartVideoResponse_default_instance_;
class RespondStartVideoStreamingRequest;
struct RespondStartVideoStreamingRequestDefaultTypeInternal;
extern RespondStartVideoStreamingRequestDefaultTypeInternal _RespondStartVideoStreamingRequest_default_instance_;
class RespondStartVideoStreamingResponse;
struct RespondStartVideoStreamingResponseDefaultTypeInternal;
extern RespondStartVideoStreamingResponseDefaultTypeInternal _RespondStartVideoStreamingResponse_default_instance_;
class RespondStopVideoRequest;
struct RespondStopVideoRequestDefaultTypeInternal;
extern RespondStopVideoRequestDefaultTypeInternal _RespondStopVideoRequest_default_instance_;
class RespondStopVideoResponse;
struct RespondStopVideoResponseDefaultTypeInternal;
extern RespondStopVideoResponseDefaultTypeInternal _RespondStopVideoResponse_default_instance_;
class RespondStopVideoStreamingRequest;
struct RespondStopVideoStreamingRequestDefaultTypeInternal;
extern RespondStopVideoStreamingRequestDefaultTypeInternal _RespondStopVideoStreamingRequest_default_instance_;
class RespondStopVideoStreamingResponse;
struct RespondStopVideoStreamingResponseDefaultTypeInternal;
extern RespondStopVideoStreamingResponseDefaultTypeInternal _RespondStopVideoStreamingResponse_default_instance_;
class RespondStorageInformationRequest;
struct RespondStorageInformationRequestDefaultTypeInternal;
extern RespondStorageInformationRequestDefaultTypeInternal _RespondStorageInformationRequest_default_instance_;
class RespondStorageInformationResponse;
struct RespondStorageInformationResponseDefaultTypeInternal;
extern RespondStorageInformationResponseDefaultTypeInternal _RespondStorageInformationResponse_default_instance_;
class RespondTakePhotoRequest;
struct RespondTakePhotoRequestDefaultTypeInternal;
extern RespondTakePhotoRequestDefaultTypeInternal _RespondTakePhotoRequest_default_instance_;
class RespondTakePhotoResponse;
struct RespondTakePhotoResponseDefaultTypeInternal;
extern RespondTakePhotoResponseDefaultTypeInternal _RespondTakePhotoResponse_default_instance_;
class RespondTrackingOffCommandRequest;
struct RespondTrackingOffCommandRequestDefaultTypeInternal;
extern RespondTrackingOffCommandRequestDefaultTypeInternal _RespondTrackingOffCommandRequest_default_instance_;
class RespondTrackingOffCommandResponse;
struct RespondTrackingOffCommandResponseDefaultTypeInternal;
extern RespondTrackingOffCommandResponseDefaultTypeInternal _RespondTrackingOffCommandResponse_default_instance_;
class RespondTrackingPointCommandRequest;
struct RespondTrackingPointCommandRequestDefaultTypeInternal;
extern RespondTrackingPointCommandRequestDefaultTypeInternal _RespondTrackingPointCommandRequest_default_instance_;
class RespondTrackingPointCommandResponse;
struct RespondTrackingPointCommandResponseDefaultTypeInternal;
extern RespondTrackingPointCommandResponseDefaultTypeInternal _RespondTrackingPointCommandResponse_default_instance_;
class RespondTrackingRectangleCommandRequest;
struct RespondTrackingRectangleCommandRequestDefaultTypeInternal;
extern RespondTrackingRectangleCommandRequestDefaultTypeInternal _RespondTrackingRectangleCommandRequest_default_instance_;
class RespondTrackingRectangleCommandResponse;
struct RespondTrackingRectangleCommandResponseDefaultTypeInternal;
extern RespondTrackingRectangleCommandResponseDefaultTypeInternal _RespondTrackingRectangleCommandResponse_default_instance_;
class RespondZoomInStartRequest;
struct RespondZoomInStartRequestDefaultTypeInternal;
extern RespondZoomInStartRequestDefaultTypeInternal _RespondZoomInStartRequest_default_instance_;
class RespondZoomInStartResponse;
struct RespondZoomInStartResponseDefaultTypeInternal;
extern RespondZoomInStartResponseDefaultTypeInternal _RespondZoomInStartResponse_default_instance_;
class RespondZoomOutStartRequest;
struct RespondZoomOutStartRequestDefaultTypeInternal;
extern RespondZoomOutStartRequestDefaultTypeInternal _RespondZoomOutStartRequest_default_instance_;
class RespondZoomOutStartResponse;
struct RespondZoomOutStartResponseDefaultTypeInternal;
extern RespondZoomOutStartResponseDefaultTypeInternal _RespondZoomOutStartResponse_default_instance_;
class RespondZoomRangeRequest;
struct RespondZoomRangeRequestDefaultTypeInternal;
extern RespondZoomRangeRequestDefaultTypeInternal _RespondZoomRangeRequest_default_instance_;
class RespondZoomRangeResponse;
struct RespondZoomRangeResponseDefaultTypeInternal;
extern RespondZoomRangeResponseDefaultTypeInternal _RespondZoomRangeResponse_default_instance_;
class RespondZoomStopRequest;
struct RespondZoomStopRequestDefaultTypeInternal;
extern RespondZoomStopRequestDefaultTypeInternal _RespondZoomStopRequest_default_instance_;
class RespondZoomStopResponse;
struct RespondZoomStopResponseDefaultTypeInternal;
extern RespondZoomStopResponseDefaultTypeInternal _RespondZoomStopResponse_default_instance_;
class SetInProgressRequest;
struct SetInProgressRequestDefaultTypeInternal;
extern SetInProgressRequestDefaultTypeInternal _SetInProgressRequest_default_instance_;
class SetInProgressResponse;
struct SetInProgressResponseDefaultTypeInternal;
extern SetInProgressResponseDefaultTypeInternal _SetInProgressResponse_default_instance_;
class SetInformationRequest;
struct SetInformationRequestDefaultTypeInternal;
extern SetInformationRequestDefaultTypeInternal _SetInformationRequest_default_instance_;
class SetInformationResponse;
struct SetInformationResponseDefaultTypeInternal;
extern SetInformationResponseDefaultTypeInternal _SetInformationResponse_default_instance_;
class SetModeResponse;
struct SetModeResponseDefaultTypeInternal;
extern SetModeResponseDefaultTypeInternal _SetModeResponse_default_instance_;
class SetTrackingOffStatusRequest;
struct SetTrackingOffStatusRequestDefaultTypeInternal;
extern SetTrackingOffStatusRequestDefaultTypeInternal _SetTrackingOffStatusRequest_default_instance_;
class SetTrackingOffStatusResponse;
struct SetTrackingOffStatusResponseDefaultTypeInternal;
extern SetTrackingOffStatusResponseDefaultTypeInternal _SetTrackingOffStatusResponse_default_instance_;
class SetTrackingPointStatusRequest;
struct SetTrackingPointStatusRequestDefaultTypeInternal;
extern SetTrackingPointStatusRequestDefaultTypeInternal _SetTrackingPointStatusRequest_default_instance_;
class SetTrackingPointStatusResponse;
struct SetTrackingPointStatusResponseDefaultTypeInternal;
extern SetTrackingPointStatusResponseDefaultTypeInternal _SetTrackingPointStatusResponse_default_instance_;
class SetTrackingRectangleStatusRequest;
struct SetTrackingRectangleStatusRequestDefaultTypeInternal;
extern SetTrackingRectangleStatusRequestDefaultTypeInternal _SetTrackingRectangleStatusRequest_default_instance_;
class SetTrackingRectangleStatusResponse;
struct SetTrackingRectangleStatusResponseDefaultTypeInternal;
extern SetTrackingRectangleStatusResponseDefaultTypeInternal _SetTrackingRectangleStatusResponse_default_instance_;
class SetVideoStreamingRequest;
struct SetVideoStreamingRequestDefaultTypeInternal;
extern SetVideoStreamingRequestDefaultTypeInternal _SetVideoStreamingRequest_default_instance_;
class SetVideoStreamingResponse;
struct SetVideoStreamingResponseDefaultTypeInternal;
extern SetVideoStreamingResponseDefaultTypeInternal _SetVideoStreamingResponse_default_instance_;
class StartVideoResponse;
struct StartVideoResponseDefaultTypeInternal;
extern StartVideoResponseDefaultTypeInternal _StartVideoResponse_default_instance_;
class StartVideoStreamingResponse;
struct StartVideoStreamingResponseDefaultTypeInternal;
extern StartVideoStreamingResponseDefaultTypeInternal _StartVideoStreamingResponse_default_instance_;
class StopVideoResponse;
struct StopVideoResponseDefaultTypeInternal;
extern StopVideoResponseDefaultTypeInternal _StopVideoResponse_default_instance_;
class StopVideoStreamingResponse;
struct StopVideoStreamingResponseDefaultTypeInternal;
extern StopVideoStreamingResponseDefaultTypeInternal _StopVideoStreamingResponse_default_instance_;
class StorageInformation;
struct StorageInformationDefaultTypeInternal;
extern StorageInformationDefaultTypeInternal _StorageInformation_default_instance_;
class StorageInformationResponse;
struct StorageInformationResponseDefaultTypeInternal;
extern StorageInformationResponseDefaultTypeInternal _StorageInformationResponse_default_instance_;
class SubscribeCaptureStatusRequest;
struct SubscribeCaptureStatusRequestDefaultTypeInternal;
extern SubscribeCaptureStatusRequestDefaultTypeInternal _SubscribeCaptureStatusRequest_default_instance_;
class SubscribeFormatStorageRequest;
struct SubscribeFormatStorageRequestDefaultTypeInternal;
extern SubscribeFormatStorageRequestDefaultTypeInternal _SubscribeFormatStorageRequest_default_instance_;
class SubscribeResetSettingsRequest;
struct SubscribeResetSettingsRequestDefaultTypeInternal;
extern SubscribeResetSettingsRequestDefaultTypeInternal _SubscribeResetSettingsRequest_default_instance_;
class SubscribeSetModeRequest;
struct SubscribeSetModeRequestDefaultTypeInternal;
extern SubscribeSetModeRequestDefaultTypeInternal _SubscribeSetModeRequest_default_instance_;
class SubscribeStartVideoRequest;
struct SubscribeStartVideoRequestDefaultTypeInternal;
extern SubscribeStartVideoRequestDefaultTypeInternal _SubscribeStartVideoRequest_default_instance_;
class SubscribeStartVideoStreamingRequest;
struct SubscribeStartVideoStreamingRequestDefaultTypeInternal;
extern SubscribeStartVideoStreamingRequestDefaultTypeInternal _SubscribeStartVideoStreamingRequest_default_instance_;
class SubscribeStopVideoRequest;
struct SubscribeStopVideoRequestDefaultTypeInternal;
extern SubscribeStopVideoRequestDefaultTypeInternal _SubscribeStopVideoRequest_default_instance_;
class SubscribeStopVideoStreamingRequest;
struct SubscribeStopVideoStreamingRequestDefaultTypeInternal;
extern SubscribeStopVideoStreamingRequestDefaultTypeInternal _SubscribeStopVideoStreamingRequest_default_instance_;
class SubscribeStorageInformationRequest;
struct SubscribeStorageInformationRequestDefaultTypeInternal;
extern SubscribeStorageInformationRequestDefaultTypeInternal _SubscribeStorageInformationRequest_default_instance_;
class SubscribeTakePhotoRequest;
struct SubscribeTakePhotoRequestDefaultTypeInternal;
extern SubscribeTakePhotoRequestDefaultTypeInternal _SubscribeTakePhotoRequest_default_instance_;
class SubscribeTrackingOffCommandRequest;
struct SubscribeTrackingOffCommandRequestDefaultTypeInternal;
extern SubscribeTrackingOffCommandRequestDefaultTypeInternal _SubscribeTrackingOffCommandRequest_default_instance_;
class SubscribeTrackingPointCommandRequest;
struct SubscribeTrackingPointCommandRequestDefaultTypeInternal;
extern SubscribeTrackingPointCommandRequestDefaultTypeInternal _SubscribeTrackingPointCommandRequest_default_instance_;
class SubscribeTrackingRectangleCommandRequest;
struct SubscribeTrackingRectangleCommandRequestDefaultTypeInternal;
extern SubscribeTrackingRectangleCommandRequestDefaultTypeInternal _SubscribeTrackingRectangleCommandRequest_default_instance_;
class SubscribeZoomInStartRequest;
struct SubscribeZoomInStartRequestDefaultTypeInternal;
extern SubscribeZoomInStartRequestDefaultTypeInternal _SubscribeZoomInStartRequest_default_instance_;
class SubscribeZoomOutStartRequest;
struct SubscribeZoomOutStartRequestDefaultTypeInternal;
extern SubscribeZoomOutStartRequestDefaultTypeInternal _SubscribeZoomOutStartRequest_default_instance_;
class SubscribeZoomRangeRequest;
struct SubscribeZoomRangeRequestDefaultTypeInternal;
extern SubscribeZoomRangeRequestDefaultTypeInternal _SubscribeZoomRangeRequest_default_instance_;
class SubscribeZoomStopRequest;
struct SubscribeZoomStopRequestDefaultTypeInternal;
extern SubscribeZoomStopRequestDefaultTypeInternal _SubscribeZoomStopRequest_default_instance_;
class TakePhotoResponse;
struct TakePhotoResponseDefaultTypeInternal;
extern TakePhotoResponseDefaultTypeInternal _TakePhotoResponse_default_instance_;
class TrackPoint;
struct TrackPointDefaultTypeInternal;
extern TrackPointDefaultTypeInternal _TrackPoint_default_instance_;
class TrackRectangle;
struct TrackRectangleDefaultTypeInternal;
extern TrackRectangleDefaultTypeInternal _TrackRectangle_default_instance_;
class TrackingOffCommandResponse;
struct TrackingOffCommandResponseDefaultTypeInternal;
extern TrackingOffCommandResponseDefaultTypeInternal _TrackingOffCommandResponse_default_instance_;
class TrackingPointCommandResponse;
struct TrackingPointCommandResponseDefaultTypeInternal;
extern TrackingPointCommandResponseDefaultTypeInternal _TrackingPointCommandResponse_default_instance_;
class TrackingRectangleCommandResponse;
struct TrackingRectangleCommandResponseDefaultTypeInternal;
extern TrackingRectangleCommandResponseDefaultTypeInternal _TrackingRectangleCommandResponse_default_instance_;
class VideoStreaming;
struct VideoStreamingDefaultTypeInternal;
extern VideoStreamingDefaultTypeInternal _VideoStreaming_default_instance_;
class ZoomInStartResponse;
struct ZoomInStartResponseDefaultTypeInternal;
extern ZoomInStartResponseDefaultTypeInternal _ZoomInStartResponse_default_instance_;
class ZoomOutStartResponse;
struct ZoomOutStartResponseDefaultTypeInternal;
extern ZoomOutStartResponseDefaultTypeInternal _ZoomOutStartResponse_default_instance_;
class ZoomRangeResponse;
struct ZoomRangeResponseDefaultTypeInternal;
extern ZoomRangeResponseDefaultTypeInternal _ZoomRangeResponse_default_instance_;
class ZoomStopResponse;
struct ZoomStopResponseDefaultTypeInternal;
extern ZoomStopResponseDefaultTypeInternal _ZoomStopResponse_default_instance_;
}  // namespace camera_server
}  // namespace rpc
}  // namespace mavsdk
PROTOBUF_NAMESPACE_OPEN
template<> ::mavsdk::rpc::camera_server::CameraServerResult* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(Arena*);
template<> ::mavsdk::rpc::camera_server::CaptureInfo* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::CaptureInfo>(Arena*);
template<> ::mavsdk::rpc::camera_server::CaptureStatus* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::CaptureStatus>(Arena*);
template<> ::mavsdk::rpc::camera_server::CaptureStatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::CaptureStatusResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::FormatStorageResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::FormatStorageResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::Information* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::Information>(Arena*);
template<> ::mavsdk::rpc::camera_server::Position* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::Position>(Arena*);
template<> ::mavsdk::rpc::camera_server::Quaternion* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::Quaternion>(Arena*);
template<> ::mavsdk::rpc::camera_server::ResetSettingsResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::ResetSettingsResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondCaptureStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondCaptureStatusRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondCaptureStatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondCaptureStatusResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondFormatStorageRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondFormatStorageRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondFormatStorageResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondFormatStorageResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondResetSettingsRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondResetSettingsRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondResetSettingsResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondResetSettingsResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondSetModeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondSetModeRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondSetModeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondSetModeResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStartVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStartVideoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStartVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStartVideoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStartVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStartVideoStreamingRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStartVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStartVideoStreamingResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStopVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStopVideoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStopVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStopVideoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStopVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStopVideoStreamingRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStopVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStopVideoStreamingResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStorageInformationRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStorageInformationRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondStorageInformationResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondStorageInformationResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTakePhotoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTakePhotoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTakePhotoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTakePhotoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingOffCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingOffCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingOffCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingOffCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingPointCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingPointCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingPointCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingPointCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingRectangleCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingRectangleCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondTrackingRectangleCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondTrackingRectangleCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomInStartRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomInStartRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomInStartResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomInStartResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomOutStartRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomOutStartRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomOutStartResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomOutStartResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomRangeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomRangeRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomRangeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomRangeResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomStopRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomStopRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::RespondZoomStopResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::RespondZoomStopResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetInProgressRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetInProgressRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetInProgressResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetInProgressResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetInformationRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetInformationRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetInformationResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetInformationResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetModeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetModeResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingOffStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingOffStatusRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingOffStatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingOffStatusResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingPointStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingPointStatusRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingPointStatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingPointStatusResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingRectangleStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingRectangleStatusRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetTrackingRectangleStatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetTrackingRectangleStatusResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetVideoStreamingRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SetVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SetVideoStreamingResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::StartVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StartVideoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::StartVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StartVideoStreamingResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::StopVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StopVideoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::StopVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StopVideoStreamingResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::StorageInformation* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StorageInformation>(Arena*);
template<> ::mavsdk::rpc::camera_server::StorageInformationResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::StorageInformationResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeCaptureStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeCaptureStatusRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeFormatStorageRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeFormatStorageRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeResetSettingsRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeResetSettingsRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeSetModeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeSetModeRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeStartVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeStartVideoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeStartVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeStartVideoStreamingRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeStopVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeStopVideoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeStopVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeStopVideoStreamingRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeStorageInformationRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeStorageInformationRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeTakePhotoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeTakePhotoRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeTrackingOffCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeTrackingOffCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeTrackingPointCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeTrackingPointCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeTrackingRectangleCommandRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeTrackingRectangleCommandRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeZoomInStartRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeZoomInStartRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeZoomOutStartRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeZoomOutStartRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeZoomRangeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeZoomRangeRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::SubscribeZoomStopRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::SubscribeZoomStopRequest>(Arena*);
template<> ::mavsdk::rpc::camera_server::TakePhotoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TakePhotoResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::TrackPoint* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackPoint>(Arena*);
template<> ::mavsdk::rpc::camera_server::TrackRectangle* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackRectangle>(Arena*);
template<> ::mavsdk::rpc::camera_server::TrackingOffCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackingOffCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::TrackingPointCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackingPointCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::TrackingRectangleCommandResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackingRectangleCommandResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::VideoStreaming* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::VideoStreaming>(Arena*);
template<> ::mavsdk::rpc::camera_server::ZoomInStartResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::ZoomInStartResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::ZoomOutStartResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::ZoomOutStartResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::ZoomRangeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::ZoomRangeResponse>(Arena*);
template<> ::mavsdk::rpc::camera_server::ZoomStopResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera_server::ZoomStopResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mavsdk {
namespace rpc {
namespace camera_server {

enum CameraServerResult_Result : int {
  CameraServerResult_Result_RESULT_UNKNOWN = 0,
  CameraServerResult_Result_RESULT_SUCCESS = 1,
  CameraServerResult_Result_RESULT_IN_PROGRESS = 2,
  CameraServerResult_Result_RESULT_BUSY = 3,
  CameraServerResult_Result_RESULT_DENIED = 4,
  CameraServerResult_Result_RESULT_ERROR = 5,
  CameraServerResult_Result_RESULT_TIMEOUT = 6,
  CameraServerResult_Result_RESULT_WRONG_ARGUMENT = 7,
  CameraServerResult_Result_RESULT_NO_SYSTEM = 8,
  CameraServerResult_Result_CameraServerResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CameraServerResult_Result_CameraServerResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CameraServerResult_Result_IsValid(int value);
constexpr CameraServerResult_Result CameraServerResult_Result_Result_MIN = CameraServerResult_Result_RESULT_UNKNOWN;
constexpr CameraServerResult_Result CameraServerResult_Result_Result_MAX = CameraServerResult_Result_RESULT_NO_SYSTEM;
constexpr int CameraServerResult_Result_Result_ARRAYSIZE = CameraServerResult_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraServerResult_Result_descriptor();
template<typename T>
inline const std::string& CameraServerResult_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraServerResult_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraServerResult_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraServerResult_Result_descriptor(), enum_t_value);
}
inline bool CameraServerResult_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraServerResult_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraServerResult_Result>(
    CameraServerResult_Result_descriptor(), name, value);
}
enum StorageInformation_StorageStatus : int {
  StorageInformation_StorageStatus_STORAGE_STATUS_NOT_AVAILABLE = 0,
  StorageInformation_StorageStatus_STORAGE_STATUS_UNFORMATTED = 1,
  StorageInformation_StorageStatus_STORAGE_STATUS_FORMATTED = 2,
  StorageInformation_StorageStatus_STORAGE_STATUS_NOT_SUPPORTED = 3,
  StorageInformation_StorageStatus_StorageInformation_StorageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StorageInformation_StorageStatus_StorageInformation_StorageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StorageInformation_StorageStatus_IsValid(int value);
constexpr StorageInformation_StorageStatus StorageInformation_StorageStatus_StorageStatus_MIN = StorageInformation_StorageStatus_STORAGE_STATUS_NOT_AVAILABLE;
constexpr StorageInformation_StorageStatus StorageInformation_StorageStatus_StorageStatus_MAX = StorageInformation_StorageStatus_STORAGE_STATUS_NOT_SUPPORTED;
constexpr int StorageInformation_StorageStatus_StorageStatus_ARRAYSIZE = StorageInformation_StorageStatus_StorageStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageInformation_StorageStatus_descriptor();
template<typename T>
inline const std::string& StorageInformation_StorageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StorageInformation_StorageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StorageInformation_StorageStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StorageInformation_StorageStatus_descriptor(), enum_t_value);
}
inline bool StorageInformation_StorageStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StorageInformation_StorageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StorageInformation_StorageStatus>(
    StorageInformation_StorageStatus_descriptor(), name, value);
}
enum StorageInformation_StorageType : int {
  StorageInformation_StorageType_STORAGE_TYPE_UNKNOWN = 0,
  StorageInformation_StorageType_STORAGE_TYPE_USB_STICK = 1,
  StorageInformation_StorageType_STORAGE_TYPE_SD = 2,
  StorageInformation_StorageType_STORAGE_TYPE_MICROSD = 3,
  StorageInformation_StorageType_STORAGE_TYPE_HD = 7,
  StorageInformation_StorageType_STORAGE_TYPE_OTHER = 254,
  StorageInformation_StorageType_StorageInformation_StorageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StorageInformation_StorageType_StorageInformation_StorageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StorageInformation_StorageType_IsValid(int value);
constexpr StorageInformation_StorageType StorageInformation_StorageType_StorageType_MIN = StorageInformation_StorageType_STORAGE_TYPE_UNKNOWN;
constexpr StorageInformation_StorageType StorageInformation_StorageType_StorageType_MAX = StorageInformation_StorageType_STORAGE_TYPE_OTHER;
constexpr int StorageInformation_StorageType_StorageType_ARRAYSIZE = StorageInformation_StorageType_StorageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageInformation_StorageType_descriptor();
template<typename T>
inline const std::string& StorageInformation_StorageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StorageInformation_StorageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StorageInformation_StorageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StorageInformation_StorageType_descriptor(), enum_t_value);
}
inline bool StorageInformation_StorageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StorageInformation_StorageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StorageInformation_StorageType>(
    StorageInformation_StorageType_descriptor(), name, value);
}
enum CaptureStatus_ImageStatus : int {
  CaptureStatus_ImageStatus_IMAGE_STATUS_IDLE = 0,
  CaptureStatus_ImageStatus_IMAGE_STATUS_CAPTURE_IN_PROGRESS = 1,
  CaptureStatus_ImageStatus_IMAGE_STATUS_INTERVAL_IDLE = 2,
  CaptureStatus_ImageStatus_IMAGE_STATUS_INTERVAL_IN_PROGRESS = 3,
  CaptureStatus_ImageStatus_CaptureStatus_ImageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaptureStatus_ImageStatus_CaptureStatus_ImageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaptureStatus_ImageStatus_IsValid(int value);
constexpr CaptureStatus_ImageStatus CaptureStatus_ImageStatus_ImageStatus_MIN = CaptureStatus_ImageStatus_IMAGE_STATUS_IDLE;
constexpr CaptureStatus_ImageStatus CaptureStatus_ImageStatus_ImageStatus_MAX = CaptureStatus_ImageStatus_IMAGE_STATUS_INTERVAL_IN_PROGRESS;
constexpr int CaptureStatus_ImageStatus_ImageStatus_ARRAYSIZE = CaptureStatus_ImageStatus_ImageStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaptureStatus_ImageStatus_descriptor();
template<typename T>
inline const std::string& CaptureStatus_ImageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaptureStatus_ImageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaptureStatus_ImageStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaptureStatus_ImageStatus_descriptor(), enum_t_value);
}
inline bool CaptureStatus_ImageStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaptureStatus_ImageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaptureStatus_ImageStatus>(
    CaptureStatus_ImageStatus_descriptor(), name, value);
}
enum CaptureStatus_VideoStatus : int {
  CaptureStatus_VideoStatus_VIDEO_STATUS_IDLE = 0,
  CaptureStatus_VideoStatus_VIDEO_STATUS_CAPTURE_IN_PROGRESS = 1,
  CaptureStatus_VideoStatus_CaptureStatus_VideoStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaptureStatus_VideoStatus_CaptureStatus_VideoStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaptureStatus_VideoStatus_IsValid(int value);
constexpr CaptureStatus_VideoStatus CaptureStatus_VideoStatus_VideoStatus_MIN = CaptureStatus_VideoStatus_VIDEO_STATUS_IDLE;
constexpr CaptureStatus_VideoStatus CaptureStatus_VideoStatus_VideoStatus_MAX = CaptureStatus_VideoStatus_VIDEO_STATUS_CAPTURE_IN_PROGRESS;
constexpr int CaptureStatus_VideoStatus_VideoStatus_ARRAYSIZE = CaptureStatus_VideoStatus_VideoStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaptureStatus_VideoStatus_descriptor();
template<typename T>
inline const std::string& CaptureStatus_VideoStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaptureStatus_VideoStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaptureStatus_VideoStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaptureStatus_VideoStatus_descriptor(), enum_t_value);
}
inline bool CaptureStatus_VideoStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaptureStatus_VideoStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaptureStatus_VideoStatus>(
    CaptureStatus_VideoStatus_descriptor(), name, value);
}
enum CameraFeedback : int {
  CAMERA_FEEDBACK_UNKNOWN = 0,
  CAMERA_FEEDBACK_OK = 1,
  CAMERA_FEEDBACK_BUSY = 2,
  CAMERA_FEEDBACK_FAILED = 3,
  CameraFeedback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CameraFeedback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CameraFeedback_IsValid(int value);
constexpr CameraFeedback CameraFeedback_MIN = CAMERA_FEEDBACK_UNKNOWN;
constexpr CameraFeedback CameraFeedback_MAX = CAMERA_FEEDBACK_FAILED;
constexpr int CameraFeedback_ARRAYSIZE = CameraFeedback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraFeedback_descriptor();
template<typename T>
inline const std::string& CameraFeedback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraFeedback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraFeedback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraFeedback_descriptor(), enum_t_value);
}
inline bool CameraFeedback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraFeedback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraFeedback>(
    CameraFeedback_descriptor(), name, value);
}
enum Mode : int {
  MODE_UNKNOWN = 0,
  MODE_PHOTO = 1,
  MODE_VIDEO = 2,
  Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = MODE_UNKNOWN;
constexpr Mode Mode_MAX = MODE_VIDEO;
constexpr int Mode_ARRAYSIZE = Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor();
template<typename T>
inline const std::string& Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Mode_descriptor(), enum_t_value);
}
inline bool Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Mode>(
    Mode_descriptor(), name, value);
}
// ===================================================================

class SetInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetInformationRequest) */ {
 public:
  inline SetInformationRequest() : SetInformationRequest(nullptr) {}
  ~SetInformationRequest() override;
  explicit PROTOBUF_CONSTEXPR SetInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInformationRequest(const SetInformationRequest& from);
  SetInformationRequest(SetInformationRequest&& from) noexcept
    : SetInformationRequest() {
    *this = ::std::move(from);
  }

  inline SetInformationRequest& operator=(const SetInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInformationRequest& operator=(SetInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInformationRequest* internal_default_instance() {
    return reinterpret_cast<const SetInformationRequest*>(
               &_SetInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SetInformationRequest& a, SetInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetInformationRequest& from) {
    SetInformationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetInformationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetInformationRequest";
  }
  protected:
  explicit SetInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInformationFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.Information information = 1;
  bool has_information() const;
  private:
  bool _internal_has_information() const;
  public:
  void clear_information();
  const ::mavsdk::rpc::camera_server::Information& information() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::Information* release_information();
  ::mavsdk::rpc::camera_server::Information* mutable_information();
  void set_allocated_information(::mavsdk::rpc::camera_server::Information* information);
  private:
  const ::mavsdk::rpc::camera_server::Information& _internal_information() const;
  ::mavsdk::rpc::camera_server::Information* _internal_mutable_information();
  public:
  void unsafe_arena_set_allocated_information(
      ::mavsdk::rpc::camera_server::Information* information);
  ::mavsdk::rpc::camera_server::Information* unsafe_arena_release_information();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::Information* information_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetInformationResponse) */ {
 public:
  inline SetInformationResponse() : SetInformationResponse(nullptr) {}
  ~SetInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR SetInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInformationResponse(const SetInformationResponse& from);
  SetInformationResponse(SetInformationResponse&& from) noexcept
    : SetInformationResponse() {
    *this = ::std::move(from);
  }

  inline SetInformationResponse& operator=(const SetInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInformationResponse& operator=(SetInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInformationResponse* internal_default_instance() {
    return reinterpret_cast<const SetInformationResponse*>(
               &_SetInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetInformationResponse& a, SetInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetInformationResponse& from) {
    SetInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetInformationResponse";
  }
  protected:
  explicit SetInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetVideoStreamingRequest) */ {
 public:
  inline SetVideoStreamingRequest() : SetVideoStreamingRequest(nullptr) {}
  ~SetVideoStreamingRequest() override;
  explicit PROTOBUF_CONSTEXPR SetVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoStreamingRequest(const SetVideoStreamingRequest& from);
  SetVideoStreamingRequest(SetVideoStreamingRequest&& from) noexcept
    : SetVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline SetVideoStreamingRequest& operator=(const SetVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoStreamingRequest& operator=(SetVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const SetVideoStreamingRequest*>(
               &_SetVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SetVideoStreamingRequest& a, SetVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVideoStreamingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVideoStreamingRequest& from) {
    SetVideoStreamingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVideoStreamingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetVideoStreamingRequest";
  }
  protected:
  explicit SetVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoStreamingFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.VideoStreaming video_streaming = 1;
  bool has_video_streaming() const;
  private:
  bool _internal_has_video_streaming() const;
  public:
  void clear_video_streaming();
  const ::mavsdk::rpc::camera_server::VideoStreaming& video_streaming() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::VideoStreaming* release_video_streaming();
  ::mavsdk::rpc::camera_server::VideoStreaming* mutable_video_streaming();
  void set_allocated_video_streaming(::mavsdk::rpc::camera_server::VideoStreaming* video_streaming);
  private:
  const ::mavsdk::rpc::camera_server::VideoStreaming& _internal_video_streaming() const;
  ::mavsdk::rpc::camera_server::VideoStreaming* _internal_mutable_video_streaming();
  public:
  void unsafe_arena_set_allocated_video_streaming(
      ::mavsdk::rpc::camera_server::VideoStreaming* video_streaming);
  ::mavsdk::rpc::camera_server::VideoStreaming* unsafe_arena_release_video_streaming();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::VideoStreaming* video_streaming_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetVideoStreamingResponse) */ {
 public:
  inline SetVideoStreamingResponse() : SetVideoStreamingResponse(nullptr) {}
  ~SetVideoStreamingResponse() override;
  explicit PROTOBUF_CONSTEXPR SetVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoStreamingResponse(const SetVideoStreamingResponse& from);
  SetVideoStreamingResponse(SetVideoStreamingResponse&& from) noexcept
    : SetVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline SetVideoStreamingResponse& operator=(const SetVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoStreamingResponse& operator=(SetVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const SetVideoStreamingResponse*>(
               &_SetVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetVideoStreamingResponse& a, SetVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVideoStreamingResponse& from) {
    SetVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetVideoStreamingResponse";
  }
  protected:
  explicit SetVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetInProgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetInProgressRequest) */ {
 public:
  inline SetInProgressRequest() : SetInProgressRequest(nullptr) {}
  ~SetInProgressRequest() override;
  explicit PROTOBUF_CONSTEXPR SetInProgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInProgressRequest(const SetInProgressRequest& from);
  SetInProgressRequest(SetInProgressRequest&& from) noexcept
    : SetInProgressRequest() {
    *this = ::std::move(from);
  }

  inline SetInProgressRequest& operator=(const SetInProgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInProgressRequest& operator=(SetInProgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetInProgressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInProgressRequest* internal_default_instance() {
    return reinterpret_cast<const SetInProgressRequest*>(
               &_SetInProgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetInProgressRequest& a, SetInProgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInProgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInProgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInProgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInProgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetInProgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetInProgressRequest& from) {
    SetInProgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetInProgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetInProgressRequest";
  }
  protected:
  explicit SetInProgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInProgressFieldNumber = 1,
  };
  // bool in_progress = 1;
  void clear_in_progress();
  bool in_progress() const;
  void set_in_progress(bool value);
  private:
  bool _internal_in_progress() const;
  void _internal_set_in_progress(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetInProgressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool in_progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetInProgressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetInProgressResponse) */ {
 public:
  inline SetInProgressResponse() : SetInProgressResponse(nullptr) {}
  ~SetInProgressResponse() override;
  explicit PROTOBUF_CONSTEXPR SetInProgressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInProgressResponse(const SetInProgressResponse& from);
  SetInProgressResponse(SetInProgressResponse&& from) noexcept
    : SetInProgressResponse() {
    *this = ::std::move(from);
  }

  inline SetInProgressResponse& operator=(const SetInProgressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInProgressResponse& operator=(SetInProgressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetInProgressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInProgressResponse* internal_default_instance() {
    return reinterpret_cast<const SetInProgressResponse*>(
               &_SetInProgressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetInProgressResponse& a, SetInProgressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInProgressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInProgressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInProgressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInProgressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetInProgressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetInProgressResponse& from) {
    SetInProgressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetInProgressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetInProgressResponse";
  }
  protected:
  explicit SetInProgressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetInProgressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTakePhotoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeTakePhotoRequest) */ {
 public:
  inline SubscribeTakePhotoRequest() : SubscribeTakePhotoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeTakePhotoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTakePhotoRequest(const SubscribeTakePhotoRequest& from);
  SubscribeTakePhotoRequest(SubscribeTakePhotoRequest&& from) noexcept
    : SubscribeTakePhotoRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeTakePhotoRequest& operator=(const SubscribeTakePhotoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTakePhotoRequest& operator=(SubscribeTakePhotoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTakePhotoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTakePhotoRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeTakePhotoRequest*>(
               &_SubscribeTakePhotoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SubscribeTakePhotoRequest& a, SubscribeTakePhotoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTakePhotoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTakePhotoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTakePhotoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTakePhotoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeTakePhotoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeTakePhotoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeTakePhotoRequest";
  }
  protected:
  explicit SubscribeTakePhotoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeTakePhotoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TakePhotoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TakePhotoResponse) */ {
 public:
  inline TakePhotoResponse() : TakePhotoResponse(nullptr) {}
  ~TakePhotoResponse() override;
  explicit PROTOBUF_CONSTEXPR TakePhotoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TakePhotoResponse(const TakePhotoResponse& from);
  TakePhotoResponse(TakePhotoResponse&& from) noexcept
    : TakePhotoResponse() {
    *this = ::std::move(from);
  }

  inline TakePhotoResponse& operator=(const TakePhotoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakePhotoResponse& operator=(TakePhotoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakePhotoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakePhotoResponse* internal_default_instance() {
    return reinterpret_cast<const TakePhotoResponse*>(
               &_TakePhotoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TakePhotoResponse& a, TakePhotoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TakePhotoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakePhotoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakePhotoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TakePhotoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TakePhotoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TakePhotoResponse& from) {
    TakePhotoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakePhotoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TakePhotoResponse";
  }
  protected:
  explicit TakePhotoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TakePhotoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTakePhotoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTakePhotoRequest) */ {
 public:
  inline RespondTakePhotoRequest() : RespondTakePhotoRequest(nullptr) {}
  ~RespondTakePhotoRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondTakePhotoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTakePhotoRequest(const RespondTakePhotoRequest& from);
  RespondTakePhotoRequest(RespondTakePhotoRequest&& from) noexcept
    : RespondTakePhotoRequest() {
    *this = ::std::move(from);
  }

  inline RespondTakePhotoRequest& operator=(const RespondTakePhotoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTakePhotoRequest& operator=(RespondTakePhotoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTakePhotoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTakePhotoRequest* internal_default_instance() {
    return reinterpret_cast<const RespondTakePhotoRequest*>(
               &_RespondTakePhotoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RespondTakePhotoRequest& a, RespondTakePhotoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTakePhotoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTakePhotoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTakePhotoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTakePhotoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTakePhotoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTakePhotoRequest& from) {
    RespondTakePhotoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTakePhotoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTakePhotoRequest";
  }
  protected:
  explicit RespondTakePhotoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureInfoFieldNumber = 2,
    kTakePhotoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CaptureInfo capture_info = 2;
  bool has_capture_info() const;
  private:
  bool _internal_has_capture_info() const;
  public:
  void clear_capture_info();
  const ::mavsdk::rpc::camera_server::CaptureInfo& capture_info() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CaptureInfo* release_capture_info();
  ::mavsdk::rpc::camera_server::CaptureInfo* mutable_capture_info();
  void set_allocated_capture_info(::mavsdk::rpc::camera_server::CaptureInfo* capture_info);
  private:
  const ::mavsdk::rpc::camera_server::CaptureInfo& _internal_capture_info() const;
  ::mavsdk::rpc::camera_server::CaptureInfo* _internal_mutable_capture_info();
  public:
  void unsafe_arena_set_allocated_capture_info(
      ::mavsdk::rpc::camera_server::CaptureInfo* capture_info);
  ::mavsdk::rpc::camera_server::CaptureInfo* unsafe_arena_release_capture_info();

  // .mavsdk.rpc.camera_server.CameraFeedback take_photo_feedback = 1;
  void clear_take_photo_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback take_photo_feedback() const;
  void set_take_photo_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_take_photo_feedback() const;
  void _internal_set_take_photo_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTakePhotoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CaptureInfo* capture_info_;
    int take_photo_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTakePhotoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTakePhotoResponse) */ {
 public:
  inline RespondTakePhotoResponse() : RespondTakePhotoResponse(nullptr) {}
  ~RespondTakePhotoResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondTakePhotoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTakePhotoResponse(const RespondTakePhotoResponse& from);
  RespondTakePhotoResponse(RespondTakePhotoResponse&& from) noexcept
    : RespondTakePhotoResponse() {
    *this = ::std::move(from);
  }

  inline RespondTakePhotoResponse& operator=(const RespondTakePhotoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTakePhotoResponse& operator=(RespondTakePhotoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTakePhotoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTakePhotoResponse* internal_default_instance() {
    return reinterpret_cast<const RespondTakePhotoResponse*>(
               &_RespondTakePhotoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RespondTakePhotoResponse& a, RespondTakePhotoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTakePhotoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTakePhotoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTakePhotoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTakePhotoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTakePhotoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTakePhotoResponse& from) {
    RespondTakePhotoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTakePhotoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTakePhotoResponse";
  }
  protected:
  explicit RespondTakePhotoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTakePhotoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStartVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeStartVideoRequest) */ {
 public:
  inline SubscribeStartVideoRequest() : SubscribeStartVideoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeStartVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStartVideoRequest(const SubscribeStartVideoRequest& from);
  SubscribeStartVideoRequest(SubscribeStartVideoRequest&& from) noexcept
    : SubscribeStartVideoRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStartVideoRequest& operator=(const SubscribeStartVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStartVideoRequest& operator=(SubscribeStartVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStartVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStartVideoRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStartVideoRequest*>(
               &_SubscribeStartVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubscribeStartVideoRequest& a, SubscribeStartVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStartVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStartVideoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStartVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStartVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStartVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStartVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeStartVideoRequest";
  }
  protected:
  explicit SubscribeStartVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeStartVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StartVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StartVideoResponse) */ {
 public:
  inline StartVideoResponse() : StartVideoResponse(nullptr) {}
  ~StartVideoResponse() override;
  explicit PROTOBUF_CONSTEXPR StartVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoResponse(const StartVideoResponse& from);
  StartVideoResponse(StartVideoResponse&& from) noexcept
    : StartVideoResponse() {
    *this = ::std::move(from);
  }

  inline StartVideoResponse& operator=(const StartVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoResponse& operator=(StartVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoResponse* internal_default_instance() {
    return reinterpret_cast<const StartVideoResponse*>(
               &_StartVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StartVideoResponse& a, StartVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartVideoResponse& from) {
    StartVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StartVideoResponse";
  }
  protected:
  explicit StartVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // int32 stream_id = 1;
  void clear_stream_id();
  int32_t stream_id() const;
  void set_stream_id(int32_t value);
  private:
  int32_t _internal_stream_id() const;
  void _internal_set_stream_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StartVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t stream_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStartVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStartVideoRequest) */ {
 public:
  inline RespondStartVideoRequest() : RespondStartVideoRequest(nullptr) {}
  ~RespondStartVideoRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondStartVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStartVideoRequest(const RespondStartVideoRequest& from);
  RespondStartVideoRequest(RespondStartVideoRequest&& from) noexcept
    : RespondStartVideoRequest() {
    *this = ::std::move(from);
  }

  inline RespondStartVideoRequest& operator=(const RespondStartVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStartVideoRequest& operator=(RespondStartVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStartVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStartVideoRequest* internal_default_instance() {
    return reinterpret_cast<const RespondStartVideoRequest*>(
               &_RespondStartVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RespondStartVideoRequest& a, RespondStartVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStartVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStartVideoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStartVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStartVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStartVideoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStartVideoRequest& from) {
    RespondStartVideoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStartVideoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStartVideoRequest";
  }
  protected:
  explicit RespondStartVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartVideoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback start_video_feedback = 1;
  void clear_start_video_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback start_video_feedback() const;
  void set_start_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_start_video_feedback() const;
  void _internal_set_start_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStartVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int start_video_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStartVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStartVideoResponse) */ {
 public:
  inline RespondStartVideoResponse() : RespondStartVideoResponse(nullptr) {}
  ~RespondStartVideoResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondStartVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStartVideoResponse(const RespondStartVideoResponse& from);
  RespondStartVideoResponse(RespondStartVideoResponse&& from) noexcept
    : RespondStartVideoResponse() {
    *this = ::std::move(from);
  }

  inline RespondStartVideoResponse& operator=(const RespondStartVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStartVideoResponse& operator=(RespondStartVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStartVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStartVideoResponse* internal_default_instance() {
    return reinterpret_cast<const RespondStartVideoResponse*>(
               &_RespondStartVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RespondStartVideoResponse& a, RespondStartVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStartVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStartVideoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStartVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStartVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStartVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStartVideoResponse& from) {
    RespondStartVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStartVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStartVideoResponse";
  }
  protected:
  explicit RespondStartVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStartVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStopVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeStopVideoRequest) */ {
 public:
  inline SubscribeStopVideoRequest() : SubscribeStopVideoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeStopVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStopVideoRequest(const SubscribeStopVideoRequest& from);
  SubscribeStopVideoRequest(SubscribeStopVideoRequest&& from) noexcept
    : SubscribeStopVideoRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStopVideoRequest& operator=(const SubscribeStopVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStopVideoRequest& operator=(SubscribeStopVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStopVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStopVideoRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStopVideoRequest*>(
               &_SubscribeStopVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SubscribeStopVideoRequest& a, SubscribeStopVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStopVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStopVideoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStopVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStopVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStopVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStopVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeStopVideoRequest";
  }
  protected:
  explicit SubscribeStopVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeStopVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StopVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StopVideoResponse) */ {
 public:
  inline StopVideoResponse() : StopVideoResponse(nullptr) {}
  ~StopVideoResponse() override;
  explicit PROTOBUF_CONSTEXPR StopVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoResponse(const StopVideoResponse& from);
  StopVideoResponse(StopVideoResponse&& from) noexcept
    : StopVideoResponse() {
    *this = ::std::move(from);
  }

  inline StopVideoResponse& operator=(const StopVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoResponse& operator=(StopVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoResponse* internal_default_instance() {
    return reinterpret_cast<const StopVideoResponse*>(
               &_StopVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StopVideoResponse& a, StopVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopVideoResponse& from) {
    StopVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StopVideoResponse";
  }
  protected:
  explicit StopVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // int32 stream_id = 1;
  void clear_stream_id();
  int32_t stream_id() const;
  void set_stream_id(int32_t value);
  private:
  int32_t _internal_stream_id() const;
  void _internal_set_stream_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StopVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t stream_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStopVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStopVideoRequest) */ {
 public:
  inline RespondStopVideoRequest() : RespondStopVideoRequest(nullptr) {}
  ~RespondStopVideoRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondStopVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStopVideoRequest(const RespondStopVideoRequest& from);
  RespondStopVideoRequest(RespondStopVideoRequest&& from) noexcept
    : RespondStopVideoRequest() {
    *this = ::std::move(from);
  }

  inline RespondStopVideoRequest& operator=(const RespondStopVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStopVideoRequest& operator=(RespondStopVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStopVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStopVideoRequest* internal_default_instance() {
    return reinterpret_cast<const RespondStopVideoRequest*>(
               &_RespondStopVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RespondStopVideoRequest& a, RespondStopVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStopVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStopVideoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStopVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStopVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStopVideoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStopVideoRequest& from) {
    RespondStopVideoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStopVideoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStopVideoRequest";
  }
  protected:
  explicit RespondStopVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopVideoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
  void clear_stop_video_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback stop_video_feedback() const;
  void set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_stop_video_feedback() const;
  void _internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStopVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stop_video_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStopVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStopVideoResponse) */ {
 public:
  inline RespondStopVideoResponse() : RespondStopVideoResponse(nullptr) {}
  ~RespondStopVideoResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondStopVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStopVideoResponse(const RespondStopVideoResponse& from);
  RespondStopVideoResponse(RespondStopVideoResponse&& from) noexcept
    : RespondStopVideoResponse() {
    *this = ::std::move(from);
  }

  inline RespondStopVideoResponse& operator=(const RespondStopVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStopVideoResponse& operator=(RespondStopVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStopVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStopVideoResponse* internal_default_instance() {
    return reinterpret_cast<const RespondStopVideoResponse*>(
               &_RespondStopVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RespondStopVideoResponse& a, RespondStopVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStopVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStopVideoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStopVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStopVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStopVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStopVideoResponse& from) {
    RespondStopVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStopVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStopVideoResponse";
  }
  protected:
  explicit RespondStopVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStopVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStartVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest) */ {
 public:
  inline SubscribeStartVideoStreamingRequest() : SubscribeStartVideoStreamingRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeStartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStartVideoStreamingRequest(const SubscribeStartVideoStreamingRequest& from);
  SubscribeStartVideoStreamingRequest(SubscribeStartVideoStreamingRequest&& from) noexcept
    : SubscribeStartVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStartVideoStreamingRequest& operator=(const SubscribeStartVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStartVideoStreamingRequest& operator=(SubscribeStartVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStartVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStartVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStartVideoStreamingRequest*>(
               &_SubscribeStartVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SubscribeStartVideoStreamingRequest& a, SubscribeStartVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStartVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStartVideoStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStartVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStartVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStartVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStartVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest";
  }
  protected:
  explicit SubscribeStartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StartVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StartVideoStreamingResponse) */ {
 public:
  inline StartVideoStreamingResponse() : StartVideoStreamingResponse(nullptr) {}
  ~StartVideoStreamingResponse() override;
  explicit PROTOBUF_CONSTEXPR StartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoStreamingResponse(const StartVideoStreamingResponse& from);
  StartVideoStreamingResponse(StartVideoStreamingResponse&& from) noexcept
    : StartVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline StartVideoStreamingResponse& operator=(const StartVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoStreamingResponse& operator=(StartVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const StartVideoStreamingResponse*>(
               &_StartVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StartVideoStreamingResponse& a, StartVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartVideoStreamingResponse& from) {
    StartVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StartVideoStreamingResponse";
  }
  protected:
  explicit StartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // int32 stream_id = 1;
  void clear_stream_id();
  int32_t stream_id() const;
  void set_stream_id(int32_t value);
  private:
  int32_t _internal_stream_id() const;
  void _internal_set_stream_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StartVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t stream_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStartVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest) */ {
 public:
  inline RespondStartVideoStreamingRequest() : RespondStartVideoStreamingRequest(nullptr) {}
  ~RespondStartVideoStreamingRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondStartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStartVideoStreamingRequest(const RespondStartVideoStreamingRequest& from);
  RespondStartVideoStreamingRequest(RespondStartVideoStreamingRequest&& from) noexcept
    : RespondStartVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline RespondStartVideoStreamingRequest& operator=(const RespondStartVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStartVideoStreamingRequest& operator=(RespondStartVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStartVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStartVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const RespondStartVideoStreamingRequest*>(
               &_RespondStartVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RespondStartVideoStreamingRequest& a, RespondStartVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStartVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStartVideoStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStartVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStartVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStartVideoStreamingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStartVideoStreamingRequest& from) {
    RespondStartVideoStreamingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStartVideoStreamingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest";
  }
  protected:
  explicit RespondStartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartVideoStreamingFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback start_video_streaming_feedback = 1;
  void clear_start_video_streaming_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback start_video_streaming_feedback() const;
  void set_start_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_start_video_streaming_feedback() const;
  void _internal_set_start_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int start_video_streaming_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStartVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse) */ {
 public:
  inline RespondStartVideoStreamingResponse() : RespondStartVideoStreamingResponse(nullptr) {}
  ~RespondStartVideoStreamingResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondStartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStartVideoStreamingResponse(const RespondStartVideoStreamingResponse& from);
  RespondStartVideoStreamingResponse(RespondStartVideoStreamingResponse&& from) noexcept
    : RespondStartVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline RespondStartVideoStreamingResponse& operator=(const RespondStartVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStartVideoStreamingResponse& operator=(RespondStartVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStartVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStartVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const RespondStartVideoStreamingResponse*>(
               &_RespondStartVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RespondStartVideoStreamingResponse& a, RespondStartVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStartVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStartVideoStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStartVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStartVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStartVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStartVideoStreamingResponse& from) {
    RespondStartVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStartVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse";
  }
  protected:
  explicit RespondStartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStopVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest) */ {
 public:
  inline SubscribeStopVideoStreamingRequest() : SubscribeStopVideoStreamingRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeStopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStopVideoStreamingRequest(const SubscribeStopVideoStreamingRequest& from);
  SubscribeStopVideoStreamingRequest(SubscribeStopVideoStreamingRequest&& from) noexcept
    : SubscribeStopVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStopVideoStreamingRequest& operator=(const SubscribeStopVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStopVideoStreamingRequest& operator=(SubscribeStopVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStopVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStopVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStopVideoStreamingRequest*>(
               &_SubscribeStopVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SubscribeStopVideoStreamingRequest& a, SubscribeStopVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStopVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStopVideoStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStopVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStopVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStopVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStopVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest";
  }
  protected:
  explicit SubscribeStopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StopVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StopVideoStreamingResponse) */ {
 public:
  inline StopVideoStreamingResponse() : StopVideoStreamingResponse(nullptr) {}
  ~StopVideoStreamingResponse() override;
  explicit PROTOBUF_CONSTEXPR StopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoStreamingResponse(const StopVideoStreamingResponse& from);
  StopVideoStreamingResponse(StopVideoStreamingResponse&& from) noexcept
    : StopVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline StopVideoStreamingResponse& operator=(const StopVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoStreamingResponse& operator=(StopVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const StopVideoStreamingResponse*>(
               &_StopVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StopVideoStreamingResponse& a, StopVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopVideoStreamingResponse& from) {
    StopVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StopVideoStreamingResponse";
  }
  protected:
  explicit StopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
  };
  // int32 stream_id = 1;
  void clear_stream_id();
  int32_t stream_id() const;
  void set_stream_id(int32_t value);
  private:
  int32_t _internal_stream_id() const;
  void _internal_set_stream_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StopVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t stream_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStopVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest) */ {
 public:
  inline RespondStopVideoStreamingRequest() : RespondStopVideoStreamingRequest(nullptr) {}
  ~RespondStopVideoStreamingRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondStopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStopVideoStreamingRequest(const RespondStopVideoStreamingRequest& from);
  RespondStopVideoStreamingRequest(RespondStopVideoStreamingRequest&& from) noexcept
    : RespondStopVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline RespondStopVideoStreamingRequest& operator=(const RespondStopVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStopVideoStreamingRequest& operator=(RespondStopVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStopVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStopVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const RespondStopVideoStreamingRequest*>(
               &_RespondStopVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RespondStopVideoStreamingRequest& a, RespondStopVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStopVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStopVideoStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStopVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStopVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStopVideoStreamingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStopVideoStreamingRequest& from) {
    RespondStopVideoStreamingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStopVideoStreamingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest";
  }
  protected:
  explicit RespondStopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopVideoStreamingFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback stop_video_streaming_feedback = 1;
  void clear_stop_video_streaming_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback stop_video_streaming_feedback() const;
  void set_stop_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_stop_video_streaming_feedback() const;
  void _internal_set_stop_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stop_video_streaming_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStopVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse) */ {
 public:
  inline RespondStopVideoStreamingResponse() : RespondStopVideoStreamingResponse(nullptr) {}
  ~RespondStopVideoStreamingResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondStopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStopVideoStreamingResponse(const RespondStopVideoStreamingResponse& from);
  RespondStopVideoStreamingResponse(RespondStopVideoStreamingResponse&& from) noexcept
    : RespondStopVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline RespondStopVideoStreamingResponse& operator=(const RespondStopVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStopVideoStreamingResponse& operator=(RespondStopVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStopVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStopVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const RespondStopVideoStreamingResponse*>(
               &_RespondStopVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RespondStopVideoStreamingResponse& a, RespondStopVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStopVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStopVideoStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStopVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStopVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStopVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStopVideoStreamingResponse& from) {
    RespondStopVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStopVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse";
  }
  protected:
  explicit RespondStopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeSetModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeSetModeRequest) */ {
 public:
  inline SubscribeSetModeRequest() : SubscribeSetModeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeSetModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeSetModeRequest(const SubscribeSetModeRequest& from);
  SubscribeSetModeRequest(SubscribeSetModeRequest&& from) noexcept
    : SubscribeSetModeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeSetModeRequest& operator=(const SubscribeSetModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeSetModeRequest& operator=(SubscribeSetModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeSetModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeSetModeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeSetModeRequest*>(
               &_SubscribeSetModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SubscribeSetModeRequest& a, SubscribeSetModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeSetModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeSetModeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeSetModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeSetModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeSetModeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeSetModeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeSetModeRequest";
  }
  protected:
  explicit SubscribeSetModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeSetModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetModeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetModeResponse) */ {
 public:
  inline SetModeResponse() : SetModeResponse(nullptr) {}
  ~SetModeResponse() override;
  explicit PROTOBUF_CONSTEXPR SetModeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetModeResponse(const SetModeResponse& from);
  SetModeResponse(SetModeResponse&& from) noexcept
    : SetModeResponse() {
    *this = ::std::move(from);
  }

  inline SetModeResponse& operator=(const SetModeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetModeResponse& operator=(SetModeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetModeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetModeResponse* internal_default_instance() {
    return reinterpret_cast<const SetModeResponse*>(
               &_SetModeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetModeResponse& a, SetModeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetModeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetModeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetModeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetModeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetModeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetModeResponse& from) {
    SetModeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetModeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetModeResponse";
  }
  protected:
  explicit SetModeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.Mode mode = 1;
  void clear_mode();
  ::mavsdk::rpc::camera_server::Mode mode() const;
  void set_mode(::mavsdk::rpc::camera_server::Mode value);
  private:
  ::mavsdk::rpc::camera_server::Mode _internal_mode() const;
  void _internal_set_mode(::mavsdk::rpc::camera_server::Mode value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetModeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondSetModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondSetModeRequest) */ {
 public:
  inline RespondSetModeRequest() : RespondSetModeRequest(nullptr) {}
  ~RespondSetModeRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondSetModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondSetModeRequest(const RespondSetModeRequest& from);
  RespondSetModeRequest(RespondSetModeRequest&& from) noexcept
    : RespondSetModeRequest() {
    *this = ::std::move(from);
  }

  inline RespondSetModeRequest& operator=(const RespondSetModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondSetModeRequest& operator=(RespondSetModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondSetModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondSetModeRequest* internal_default_instance() {
    return reinterpret_cast<const RespondSetModeRequest*>(
               &_RespondSetModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RespondSetModeRequest& a, RespondSetModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondSetModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondSetModeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondSetModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondSetModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondSetModeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondSetModeRequest& from) {
    RespondSetModeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondSetModeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondSetModeRequest";
  }
  protected:
  explicit RespondSetModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetModeFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback set_mode_feedback = 1;
  void clear_set_mode_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback set_mode_feedback() const;
  void set_set_mode_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_set_mode_feedback() const;
  void _internal_set_set_mode_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondSetModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int set_mode_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondSetModeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondSetModeResponse) */ {
 public:
  inline RespondSetModeResponse() : RespondSetModeResponse(nullptr) {}
  ~RespondSetModeResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondSetModeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondSetModeResponse(const RespondSetModeResponse& from);
  RespondSetModeResponse(RespondSetModeResponse&& from) noexcept
    : RespondSetModeResponse() {
    *this = ::std::move(from);
  }

  inline RespondSetModeResponse& operator=(const RespondSetModeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondSetModeResponse& operator=(RespondSetModeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondSetModeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondSetModeResponse* internal_default_instance() {
    return reinterpret_cast<const RespondSetModeResponse*>(
               &_RespondSetModeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RespondSetModeResponse& a, RespondSetModeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondSetModeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondSetModeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondSetModeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondSetModeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondSetModeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondSetModeResponse& from) {
    RespondSetModeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondSetModeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondSetModeResponse";
  }
  protected:
  explicit RespondSetModeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondSetModeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStorageInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeStorageInformationRequest) */ {
 public:
  inline SubscribeStorageInformationRequest() : SubscribeStorageInformationRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeStorageInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStorageInformationRequest(const SubscribeStorageInformationRequest& from);
  SubscribeStorageInformationRequest(SubscribeStorageInformationRequest&& from) noexcept
    : SubscribeStorageInformationRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStorageInformationRequest& operator=(const SubscribeStorageInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStorageInformationRequest& operator=(SubscribeStorageInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStorageInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStorageInformationRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStorageInformationRequest*>(
               &_SubscribeStorageInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SubscribeStorageInformationRequest& a, SubscribeStorageInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStorageInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStorageInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStorageInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStorageInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStorageInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStorageInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeStorageInformationRequest";
  }
  protected:
  explicit SubscribeStorageInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeStorageInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StorageInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StorageInformationResponse) */ {
 public:
  inline StorageInformationResponse() : StorageInformationResponse(nullptr) {}
  ~StorageInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR StorageInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageInformationResponse(const StorageInformationResponse& from);
  StorageInformationResponse(StorageInformationResponse&& from) noexcept
    : StorageInformationResponse() {
    *this = ::std::move(from);
  }

  inline StorageInformationResponse& operator=(const StorageInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageInformationResponse& operator=(StorageInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageInformationResponse* internal_default_instance() {
    return reinterpret_cast<const StorageInformationResponse*>(
               &_StorageInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StorageInformationResponse& a, StorageInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageInformationResponse& from) {
    StorageInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StorageInformationResponse";
  }
  protected:
  explicit StorageInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageIdFieldNumber = 1,
  };
  // int32 storage_id = 1;
  void clear_storage_id();
  int32_t storage_id() const;
  void set_storage_id(int32_t value);
  private:
  int32_t _internal_storage_id() const;
  void _internal_set_storage_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StorageInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t storage_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStorageInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStorageInformationRequest) */ {
 public:
  inline RespondStorageInformationRequest() : RespondStorageInformationRequest(nullptr) {}
  ~RespondStorageInformationRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondStorageInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStorageInformationRequest(const RespondStorageInformationRequest& from);
  RespondStorageInformationRequest(RespondStorageInformationRequest&& from) noexcept
    : RespondStorageInformationRequest() {
    *this = ::std::move(from);
  }

  inline RespondStorageInformationRequest& operator=(const RespondStorageInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStorageInformationRequest& operator=(RespondStorageInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStorageInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStorageInformationRequest* internal_default_instance() {
    return reinterpret_cast<const RespondStorageInformationRequest*>(
               &_RespondStorageInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RespondStorageInformationRequest& a, RespondStorageInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStorageInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStorageInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStorageInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStorageInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStorageInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStorageInformationRequest& from) {
    RespondStorageInformationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStorageInformationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStorageInformationRequest";
  }
  protected:
  explicit RespondStorageInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageInformationFieldNumber = 2,
    kStorageInformationFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.StorageInformation storage_information = 2;
  bool has_storage_information() const;
  private:
  bool _internal_has_storage_information() const;
  public:
  void clear_storage_information();
  const ::mavsdk::rpc::camera_server::StorageInformation& storage_information() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::StorageInformation* release_storage_information();
  ::mavsdk::rpc::camera_server::StorageInformation* mutable_storage_information();
  void set_allocated_storage_information(::mavsdk::rpc::camera_server::StorageInformation* storage_information);
  private:
  const ::mavsdk::rpc::camera_server::StorageInformation& _internal_storage_information() const;
  ::mavsdk::rpc::camera_server::StorageInformation* _internal_mutable_storage_information();
  public:
  void unsafe_arena_set_allocated_storage_information(
      ::mavsdk::rpc::camera_server::StorageInformation* storage_information);
  ::mavsdk::rpc::camera_server::StorageInformation* unsafe_arena_release_storage_information();

  // .mavsdk.rpc.camera_server.CameraFeedback storage_information_feedback = 1;
  void clear_storage_information_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback storage_information_feedback() const;
  void set_storage_information_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_storage_information_feedback() const;
  void _internal_set_storage_information_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStorageInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::StorageInformation* storage_information_;
    int storage_information_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondStorageInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondStorageInformationResponse) */ {
 public:
  inline RespondStorageInformationResponse() : RespondStorageInformationResponse(nullptr) {}
  ~RespondStorageInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondStorageInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondStorageInformationResponse(const RespondStorageInformationResponse& from);
  RespondStorageInformationResponse(RespondStorageInformationResponse&& from) noexcept
    : RespondStorageInformationResponse() {
    *this = ::std::move(from);
  }

  inline RespondStorageInformationResponse& operator=(const RespondStorageInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondStorageInformationResponse& operator=(RespondStorageInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondStorageInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondStorageInformationResponse* internal_default_instance() {
    return reinterpret_cast<const RespondStorageInformationResponse*>(
               &_RespondStorageInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RespondStorageInformationResponse& a, RespondStorageInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondStorageInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondStorageInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondStorageInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondStorageInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondStorageInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondStorageInformationResponse& from) {
    RespondStorageInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondStorageInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondStorageInformationResponse";
  }
  protected:
  explicit RespondStorageInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondStorageInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeCaptureStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest) */ {
 public:
  inline SubscribeCaptureStatusRequest() : SubscribeCaptureStatusRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeCaptureStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCaptureStatusRequest(const SubscribeCaptureStatusRequest& from);
  SubscribeCaptureStatusRequest(SubscribeCaptureStatusRequest&& from) noexcept
    : SubscribeCaptureStatusRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeCaptureStatusRequest& operator=(const SubscribeCaptureStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCaptureStatusRequest& operator=(SubscribeCaptureStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCaptureStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeCaptureStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeCaptureStatusRequest*>(
               &_SubscribeCaptureStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SubscribeCaptureStatusRequest& a, SubscribeCaptureStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCaptureStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCaptureStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCaptureStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCaptureStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeCaptureStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeCaptureStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest";
  }
  protected:
  explicit SubscribeCaptureStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class CaptureStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.CaptureStatusResponse) */ {
 public:
  inline CaptureStatusResponse() : CaptureStatusResponse(nullptr) {}
  ~CaptureStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR CaptureStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureStatusResponse(const CaptureStatusResponse& from);
  CaptureStatusResponse(CaptureStatusResponse&& from) noexcept
    : CaptureStatusResponse() {
    *this = ::std::move(from);
  }

  inline CaptureStatusResponse& operator=(const CaptureStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureStatusResponse& operator=(CaptureStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureStatusResponse* internal_default_instance() {
    return reinterpret_cast<const CaptureStatusResponse*>(
               &_CaptureStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CaptureStatusResponse& a, CaptureStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureStatusResponse& from) {
    CaptureStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.CaptureStatusResponse";
  }
  protected:
  explicit CaptureStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
  };
  // int32 reserved = 1;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.CaptureStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondCaptureStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondCaptureStatusRequest) */ {
 public:
  inline RespondCaptureStatusRequest() : RespondCaptureStatusRequest(nullptr) {}
  ~RespondCaptureStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondCaptureStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondCaptureStatusRequest(const RespondCaptureStatusRequest& from);
  RespondCaptureStatusRequest(RespondCaptureStatusRequest&& from) noexcept
    : RespondCaptureStatusRequest() {
    *this = ::std::move(from);
  }

  inline RespondCaptureStatusRequest& operator=(const RespondCaptureStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondCaptureStatusRequest& operator=(RespondCaptureStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondCaptureStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondCaptureStatusRequest* internal_default_instance() {
    return reinterpret_cast<const RespondCaptureStatusRequest*>(
               &_RespondCaptureStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RespondCaptureStatusRequest& a, RespondCaptureStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondCaptureStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondCaptureStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondCaptureStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondCaptureStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondCaptureStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondCaptureStatusRequest& from) {
    RespondCaptureStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondCaptureStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondCaptureStatusRequest";
  }
  protected:
  explicit RespondCaptureStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureStatusFieldNumber = 2,
    kCaptureStatusFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CaptureStatus capture_status = 2;
  bool has_capture_status() const;
  private:
  bool _internal_has_capture_status() const;
  public:
  void clear_capture_status();
  const ::mavsdk::rpc::camera_server::CaptureStatus& capture_status() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CaptureStatus* release_capture_status();
  ::mavsdk::rpc::camera_server::CaptureStatus* mutable_capture_status();
  void set_allocated_capture_status(::mavsdk::rpc::camera_server::CaptureStatus* capture_status);
  private:
  const ::mavsdk::rpc::camera_server::CaptureStatus& _internal_capture_status() const;
  ::mavsdk::rpc::camera_server::CaptureStatus* _internal_mutable_capture_status();
  public:
  void unsafe_arena_set_allocated_capture_status(
      ::mavsdk::rpc::camera_server::CaptureStatus* capture_status);
  ::mavsdk::rpc::camera_server::CaptureStatus* unsafe_arena_release_capture_status();

  // .mavsdk.rpc.camera_server.CameraFeedback capture_status_feedback = 1;
  void clear_capture_status_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback capture_status_feedback() const;
  void set_capture_status_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_capture_status_feedback() const;
  void _internal_set_capture_status_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondCaptureStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CaptureStatus* capture_status_;
    int capture_status_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondCaptureStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondCaptureStatusResponse) */ {
 public:
  inline RespondCaptureStatusResponse() : RespondCaptureStatusResponse(nullptr) {}
  ~RespondCaptureStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondCaptureStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondCaptureStatusResponse(const RespondCaptureStatusResponse& from);
  RespondCaptureStatusResponse(RespondCaptureStatusResponse&& from) noexcept
    : RespondCaptureStatusResponse() {
    *this = ::std::move(from);
  }

  inline RespondCaptureStatusResponse& operator=(const RespondCaptureStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondCaptureStatusResponse& operator=(RespondCaptureStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondCaptureStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondCaptureStatusResponse* internal_default_instance() {
    return reinterpret_cast<const RespondCaptureStatusResponse*>(
               &_RespondCaptureStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(RespondCaptureStatusResponse& a, RespondCaptureStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondCaptureStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondCaptureStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondCaptureStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondCaptureStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondCaptureStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondCaptureStatusResponse& from) {
    RespondCaptureStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondCaptureStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondCaptureStatusResponse";
  }
  protected:
  explicit RespondCaptureStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondCaptureStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeFormatStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeFormatStorageRequest) */ {
 public:
  inline SubscribeFormatStorageRequest() : SubscribeFormatStorageRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeFormatStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeFormatStorageRequest(const SubscribeFormatStorageRequest& from);
  SubscribeFormatStorageRequest(SubscribeFormatStorageRequest&& from) noexcept
    : SubscribeFormatStorageRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeFormatStorageRequest& operator=(const SubscribeFormatStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeFormatStorageRequest& operator=(SubscribeFormatStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeFormatStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeFormatStorageRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeFormatStorageRequest*>(
               &_SubscribeFormatStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SubscribeFormatStorageRequest& a, SubscribeFormatStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeFormatStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeFormatStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeFormatStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeFormatStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeFormatStorageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeFormatStorageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeFormatStorageRequest";
  }
  protected:
  explicit SubscribeFormatStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeFormatStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class FormatStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.FormatStorageResponse) */ {
 public:
  inline FormatStorageResponse() : FormatStorageResponse(nullptr) {}
  ~FormatStorageResponse() override;
  explicit PROTOBUF_CONSTEXPR FormatStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatStorageResponse(const FormatStorageResponse& from);
  FormatStorageResponse(FormatStorageResponse&& from) noexcept
    : FormatStorageResponse() {
    *this = ::std::move(from);
  }

  inline FormatStorageResponse& operator=(const FormatStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatStorageResponse& operator=(FormatStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatStorageResponse* internal_default_instance() {
    return reinterpret_cast<const FormatStorageResponse*>(
               &_FormatStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FormatStorageResponse& a, FormatStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormatStorageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormatStorageResponse& from) {
    FormatStorageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatStorageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.FormatStorageResponse";
  }
  protected:
  explicit FormatStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageIdFieldNumber = 1,
  };
  // int32 storage_id = 1;
  void clear_storage_id();
  int32_t storage_id() const;
  void set_storage_id(int32_t value);
  private:
  int32_t _internal_storage_id() const;
  void _internal_set_storage_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.FormatStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t storage_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondFormatStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondFormatStorageRequest) */ {
 public:
  inline RespondFormatStorageRequest() : RespondFormatStorageRequest(nullptr) {}
  ~RespondFormatStorageRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondFormatStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondFormatStorageRequest(const RespondFormatStorageRequest& from);
  RespondFormatStorageRequest(RespondFormatStorageRequest&& from) noexcept
    : RespondFormatStorageRequest() {
    *this = ::std::move(from);
  }

  inline RespondFormatStorageRequest& operator=(const RespondFormatStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondFormatStorageRequest& operator=(RespondFormatStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondFormatStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondFormatStorageRequest* internal_default_instance() {
    return reinterpret_cast<const RespondFormatStorageRequest*>(
               &_RespondFormatStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(RespondFormatStorageRequest& a, RespondFormatStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondFormatStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondFormatStorageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondFormatStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondFormatStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondFormatStorageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondFormatStorageRequest& from) {
    RespondFormatStorageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondFormatStorageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondFormatStorageRequest";
  }
  protected:
  explicit RespondFormatStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatStorageFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback format_storage_feedback = 1;
  void clear_format_storage_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback format_storage_feedback() const;
  void set_format_storage_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_format_storage_feedback() const;
  void _internal_set_format_storage_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondFormatStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int format_storage_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondFormatStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondFormatStorageResponse) */ {
 public:
  inline RespondFormatStorageResponse() : RespondFormatStorageResponse(nullptr) {}
  ~RespondFormatStorageResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondFormatStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondFormatStorageResponse(const RespondFormatStorageResponse& from);
  RespondFormatStorageResponse(RespondFormatStorageResponse&& from) noexcept
    : RespondFormatStorageResponse() {
    *this = ::std::move(from);
  }

  inline RespondFormatStorageResponse& operator=(const RespondFormatStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondFormatStorageResponse& operator=(RespondFormatStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondFormatStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondFormatStorageResponse* internal_default_instance() {
    return reinterpret_cast<const RespondFormatStorageResponse*>(
               &_RespondFormatStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(RespondFormatStorageResponse& a, RespondFormatStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondFormatStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondFormatStorageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondFormatStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondFormatStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondFormatStorageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondFormatStorageResponse& from) {
    RespondFormatStorageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondFormatStorageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondFormatStorageResponse";
  }
  protected:
  explicit RespondFormatStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondFormatStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeResetSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeResetSettingsRequest) */ {
 public:
  inline SubscribeResetSettingsRequest() : SubscribeResetSettingsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeResetSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeResetSettingsRequest(const SubscribeResetSettingsRequest& from);
  SubscribeResetSettingsRequest(SubscribeResetSettingsRequest&& from) noexcept
    : SubscribeResetSettingsRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeResetSettingsRequest& operator=(const SubscribeResetSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeResetSettingsRequest& operator=(SubscribeResetSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeResetSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeResetSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeResetSettingsRequest*>(
               &_SubscribeResetSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SubscribeResetSettingsRequest& a, SubscribeResetSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeResetSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeResetSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeResetSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeResetSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeResetSettingsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeResetSettingsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeResetSettingsRequest";
  }
  protected:
  explicit SubscribeResetSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeResetSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ResetSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.ResetSettingsResponse) */ {
 public:
  inline ResetSettingsResponse() : ResetSettingsResponse(nullptr) {}
  ~ResetSettingsResponse() override;
  explicit PROTOBUF_CONSTEXPR ResetSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetSettingsResponse(const ResetSettingsResponse& from);
  ResetSettingsResponse(ResetSettingsResponse&& from) noexcept
    : ResetSettingsResponse() {
    *this = ::std::move(from);
  }

  inline ResetSettingsResponse& operator=(const ResetSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetSettingsResponse& operator=(ResetSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const ResetSettingsResponse*>(
               &_ResetSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ResetSettingsResponse& a, ResetSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetSettingsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetSettingsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetSettingsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetSettingsResponse& from) {
    ResetSettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.ResetSettingsResponse";
  }
  protected:
  explicit ResetSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
  };
  // int32 reserved = 1;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.ResetSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondResetSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondResetSettingsRequest) */ {
 public:
  inline RespondResetSettingsRequest() : RespondResetSettingsRequest(nullptr) {}
  ~RespondResetSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondResetSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondResetSettingsRequest(const RespondResetSettingsRequest& from);
  RespondResetSettingsRequest(RespondResetSettingsRequest&& from) noexcept
    : RespondResetSettingsRequest() {
    *this = ::std::move(from);
  }

  inline RespondResetSettingsRequest& operator=(const RespondResetSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondResetSettingsRequest& operator=(RespondResetSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondResetSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondResetSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const RespondResetSettingsRequest*>(
               &_RespondResetSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(RespondResetSettingsRequest& a, RespondResetSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondResetSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondResetSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondResetSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondResetSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondResetSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondResetSettingsRequest& from) {
    RespondResetSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondResetSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondResetSettingsRequest";
  }
  protected:
  explicit RespondResetSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResetSettingsFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback reset_settings_feedback = 1;
  void clear_reset_settings_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback reset_settings_feedback() const;
  void set_reset_settings_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_reset_settings_feedback() const;
  void _internal_set_reset_settings_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondResetSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int reset_settings_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondResetSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondResetSettingsResponse) */ {
 public:
  inline RespondResetSettingsResponse() : RespondResetSettingsResponse(nullptr) {}
  ~RespondResetSettingsResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondResetSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondResetSettingsResponse(const RespondResetSettingsResponse& from);
  RespondResetSettingsResponse(RespondResetSettingsResponse&& from) noexcept
    : RespondResetSettingsResponse() {
    *this = ::std::move(from);
  }

  inline RespondResetSettingsResponse& operator=(const RespondResetSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondResetSettingsResponse& operator=(RespondResetSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondResetSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondResetSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const RespondResetSettingsResponse*>(
               &_RespondResetSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RespondResetSettingsResponse& a, RespondResetSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondResetSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondResetSettingsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondResetSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondResetSettingsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondResetSettingsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondResetSettingsResponse& from) {
    RespondResetSettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondResetSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondResetSettingsResponse";
  }
  protected:
  explicit RespondResetSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondResetSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeZoomInStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeZoomInStartRequest) */ {
 public:
  inline SubscribeZoomInStartRequest() : SubscribeZoomInStartRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeZoomInStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeZoomInStartRequest(const SubscribeZoomInStartRequest& from);
  SubscribeZoomInStartRequest(SubscribeZoomInStartRequest&& from) noexcept
    : SubscribeZoomInStartRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeZoomInStartRequest& operator=(const SubscribeZoomInStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeZoomInStartRequest& operator=(SubscribeZoomInStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeZoomInStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeZoomInStartRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeZoomInStartRequest*>(
               &_SubscribeZoomInStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(SubscribeZoomInStartRequest& a, SubscribeZoomInStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeZoomInStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeZoomInStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeZoomInStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeZoomInStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeZoomInStartRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeZoomInStartRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeZoomInStartRequest";
  }
  protected:
  explicit SubscribeZoomInStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeZoomInStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ZoomInStartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.ZoomInStartResponse) */ {
 public:
  inline ZoomInStartResponse() : ZoomInStartResponse(nullptr) {}
  ~ZoomInStartResponse() override;
  explicit PROTOBUF_CONSTEXPR ZoomInStartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoomInStartResponse(const ZoomInStartResponse& from);
  ZoomInStartResponse(ZoomInStartResponse&& from) noexcept
    : ZoomInStartResponse() {
    *this = ::std::move(from);
  }

  inline ZoomInStartResponse& operator=(const ZoomInStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomInStartResponse& operator=(ZoomInStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomInStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomInStartResponse* internal_default_instance() {
    return reinterpret_cast<const ZoomInStartResponse*>(
               &_ZoomInStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ZoomInStartResponse& a, ZoomInStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomInStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomInStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomInStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomInStartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoomInStartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZoomInStartResponse& from) {
    ZoomInStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoomInStartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.ZoomInStartResponse";
  }
  protected:
  explicit ZoomInStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
  };
  // int32 reserved = 1;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.ZoomInStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomInStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomInStartRequest) */ {
 public:
  inline RespondZoomInStartRequest() : RespondZoomInStartRequest(nullptr) {}
  ~RespondZoomInStartRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomInStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomInStartRequest(const RespondZoomInStartRequest& from);
  RespondZoomInStartRequest(RespondZoomInStartRequest&& from) noexcept
    : RespondZoomInStartRequest() {
    *this = ::std::move(from);
  }

  inline RespondZoomInStartRequest& operator=(const RespondZoomInStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomInStartRequest& operator=(RespondZoomInStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomInStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomInStartRequest* internal_default_instance() {
    return reinterpret_cast<const RespondZoomInStartRequest*>(
               &_RespondZoomInStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(RespondZoomInStartRequest& a, RespondZoomInStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomInStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomInStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomInStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomInStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomInStartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomInStartRequest& from) {
    RespondZoomInStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomInStartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomInStartRequest";
  }
  protected:
  explicit RespondZoomInStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoomInStartFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback zoom_in_start_feedback = 1;
  void clear_zoom_in_start_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback zoom_in_start_feedback() const;
  void set_zoom_in_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_zoom_in_start_feedback() const;
  void _internal_set_zoom_in_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomInStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int zoom_in_start_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomInStartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomInStartResponse) */ {
 public:
  inline RespondZoomInStartResponse() : RespondZoomInStartResponse(nullptr) {}
  ~RespondZoomInStartResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomInStartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomInStartResponse(const RespondZoomInStartResponse& from);
  RespondZoomInStartResponse(RespondZoomInStartResponse&& from) noexcept
    : RespondZoomInStartResponse() {
    *this = ::std::move(from);
  }

  inline RespondZoomInStartResponse& operator=(const RespondZoomInStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomInStartResponse& operator=(RespondZoomInStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomInStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomInStartResponse* internal_default_instance() {
    return reinterpret_cast<const RespondZoomInStartResponse*>(
               &_RespondZoomInStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(RespondZoomInStartResponse& a, RespondZoomInStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomInStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomInStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomInStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomInStartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomInStartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomInStartResponse& from) {
    RespondZoomInStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomInStartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomInStartResponse";
  }
  protected:
  explicit RespondZoomInStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomInStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeZoomOutStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest) */ {
 public:
  inline SubscribeZoomOutStartRequest() : SubscribeZoomOutStartRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeZoomOutStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeZoomOutStartRequest(const SubscribeZoomOutStartRequest& from);
  SubscribeZoomOutStartRequest(SubscribeZoomOutStartRequest&& from) noexcept
    : SubscribeZoomOutStartRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeZoomOutStartRequest& operator=(const SubscribeZoomOutStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeZoomOutStartRequest& operator=(SubscribeZoomOutStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeZoomOutStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeZoomOutStartRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeZoomOutStartRequest*>(
               &_SubscribeZoomOutStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(SubscribeZoomOutStartRequest& a, SubscribeZoomOutStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeZoomOutStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeZoomOutStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeZoomOutStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeZoomOutStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeZoomOutStartRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeZoomOutStartRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest";
  }
  protected:
  explicit SubscribeZoomOutStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ZoomOutStartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.ZoomOutStartResponse) */ {
 public:
  inline ZoomOutStartResponse() : ZoomOutStartResponse(nullptr) {}
  ~ZoomOutStartResponse() override;
  explicit PROTOBUF_CONSTEXPR ZoomOutStartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoomOutStartResponse(const ZoomOutStartResponse& from);
  ZoomOutStartResponse(ZoomOutStartResponse&& from) noexcept
    : ZoomOutStartResponse() {
    *this = ::std::move(from);
  }

  inline ZoomOutStartResponse& operator=(const ZoomOutStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomOutStartResponse& operator=(ZoomOutStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomOutStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomOutStartResponse* internal_default_instance() {
    return reinterpret_cast<const ZoomOutStartResponse*>(
               &_ZoomOutStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ZoomOutStartResponse& a, ZoomOutStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomOutStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomOutStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomOutStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomOutStartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoomOutStartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZoomOutStartResponse& from) {
    ZoomOutStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoomOutStartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.ZoomOutStartResponse";
  }
  protected:
  explicit ZoomOutStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
  };
  // int32 reserved = 1;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.ZoomOutStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomOutStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomOutStartRequest) */ {
 public:
  inline RespondZoomOutStartRequest() : RespondZoomOutStartRequest(nullptr) {}
  ~RespondZoomOutStartRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomOutStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomOutStartRequest(const RespondZoomOutStartRequest& from);
  RespondZoomOutStartRequest(RespondZoomOutStartRequest&& from) noexcept
    : RespondZoomOutStartRequest() {
    *this = ::std::move(from);
  }

  inline RespondZoomOutStartRequest& operator=(const RespondZoomOutStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomOutStartRequest& operator=(RespondZoomOutStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomOutStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomOutStartRequest* internal_default_instance() {
    return reinterpret_cast<const RespondZoomOutStartRequest*>(
               &_RespondZoomOutStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(RespondZoomOutStartRequest& a, RespondZoomOutStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomOutStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomOutStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomOutStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomOutStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomOutStartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomOutStartRequest& from) {
    RespondZoomOutStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomOutStartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomOutStartRequest";
  }
  protected:
  explicit RespondZoomOutStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoomOutStartFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback zoom_out_start_feedback = 1;
  void clear_zoom_out_start_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback zoom_out_start_feedback() const;
  void set_zoom_out_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_zoom_out_start_feedback() const;
  void _internal_set_zoom_out_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomOutStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int zoom_out_start_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomOutStartResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomOutStartResponse) */ {
 public:
  inline RespondZoomOutStartResponse() : RespondZoomOutStartResponse(nullptr) {}
  ~RespondZoomOutStartResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomOutStartResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomOutStartResponse(const RespondZoomOutStartResponse& from);
  RespondZoomOutStartResponse(RespondZoomOutStartResponse&& from) noexcept
    : RespondZoomOutStartResponse() {
    *this = ::std::move(from);
  }

  inline RespondZoomOutStartResponse& operator=(const RespondZoomOutStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomOutStartResponse& operator=(RespondZoomOutStartResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomOutStartResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomOutStartResponse* internal_default_instance() {
    return reinterpret_cast<const RespondZoomOutStartResponse*>(
               &_RespondZoomOutStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(RespondZoomOutStartResponse& a, RespondZoomOutStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomOutStartResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomOutStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomOutStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomOutStartResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomOutStartResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomOutStartResponse& from) {
    RespondZoomOutStartResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomOutStartResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomOutStartResponse";
  }
  protected:
  explicit RespondZoomOutStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomOutStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeZoomStopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeZoomStopRequest) */ {
 public:
  inline SubscribeZoomStopRequest() : SubscribeZoomStopRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeZoomStopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeZoomStopRequest(const SubscribeZoomStopRequest& from);
  SubscribeZoomStopRequest(SubscribeZoomStopRequest&& from) noexcept
    : SubscribeZoomStopRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeZoomStopRequest& operator=(const SubscribeZoomStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeZoomStopRequest& operator=(SubscribeZoomStopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeZoomStopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeZoomStopRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeZoomStopRequest*>(
               &_SubscribeZoomStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(SubscribeZoomStopRequest& a, SubscribeZoomStopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeZoomStopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeZoomStopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeZoomStopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeZoomStopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeZoomStopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeZoomStopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeZoomStopRequest";
  }
  protected:
  explicit SubscribeZoomStopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeZoomStopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ZoomStopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.ZoomStopResponse) */ {
 public:
  inline ZoomStopResponse() : ZoomStopResponse(nullptr) {}
  ~ZoomStopResponse() override;
  explicit PROTOBUF_CONSTEXPR ZoomStopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoomStopResponse(const ZoomStopResponse& from);
  ZoomStopResponse(ZoomStopResponse&& from) noexcept
    : ZoomStopResponse() {
    *this = ::std::move(from);
  }

  inline ZoomStopResponse& operator=(const ZoomStopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomStopResponse& operator=(ZoomStopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomStopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomStopResponse* internal_default_instance() {
    return reinterpret_cast<const ZoomStopResponse*>(
               &_ZoomStopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ZoomStopResponse& a, ZoomStopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomStopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomStopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomStopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomStopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoomStopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZoomStopResponse& from) {
    ZoomStopResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoomStopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.ZoomStopResponse";
  }
  protected:
  explicit ZoomStopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReservedFieldNumber = 1,
  };
  // int32 reserved = 1;
  void clear_reserved();
  int32_t reserved() const;
  void set_reserved(int32_t value);
  private:
  int32_t _internal_reserved() const;
  void _internal_set_reserved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.ZoomStopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reserved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomStopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomStopRequest) */ {
 public:
  inline RespondZoomStopRequest() : RespondZoomStopRequest(nullptr) {}
  ~RespondZoomStopRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomStopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomStopRequest(const RespondZoomStopRequest& from);
  RespondZoomStopRequest(RespondZoomStopRequest&& from) noexcept
    : RespondZoomStopRequest() {
    *this = ::std::move(from);
  }

  inline RespondZoomStopRequest& operator=(const RespondZoomStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomStopRequest& operator=(RespondZoomStopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomStopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomStopRequest* internal_default_instance() {
    return reinterpret_cast<const RespondZoomStopRequest*>(
               &_RespondZoomStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(RespondZoomStopRequest& a, RespondZoomStopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomStopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomStopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomStopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomStopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomStopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomStopRequest& from) {
    RespondZoomStopRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomStopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomStopRequest";
  }
  protected:
  explicit RespondZoomStopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoomStopFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback zoom_stop_feedback = 1;
  void clear_zoom_stop_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback zoom_stop_feedback() const;
  void set_zoom_stop_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_zoom_stop_feedback() const;
  void _internal_set_zoom_stop_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomStopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int zoom_stop_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomStopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomStopResponse) */ {
 public:
  inline RespondZoomStopResponse() : RespondZoomStopResponse(nullptr) {}
  ~RespondZoomStopResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomStopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomStopResponse(const RespondZoomStopResponse& from);
  RespondZoomStopResponse(RespondZoomStopResponse&& from) noexcept
    : RespondZoomStopResponse() {
    *this = ::std::move(from);
  }

  inline RespondZoomStopResponse& operator=(const RespondZoomStopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomStopResponse& operator=(RespondZoomStopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomStopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomStopResponse* internal_default_instance() {
    return reinterpret_cast<const RespondZoomStopResponse*>(
               &_RespondZoomStopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(RespondZoomStopResponse& a, RespondZoomStopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomStopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomStopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomStopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomStopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomStopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomStopResponse& from) {
    RespondZoomStopResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomStopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomStopResponse";
  }
  protected:
  explicit RespondZoomStopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomStopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeZoomRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeZoomRangeRequest) */ {
 public:
  inline SubscribeZoomRangeRequest() : SubscribeZoomRangeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeZoomRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeZoomRangeRequest(const SubscribeZoomRangeRequest& from);
  SubscribeZoomRangeRequest(SubscribeZoomRangeRequest&& from) noexcept
    : SubscribeZoomRangeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeZoomRangeRequest& operator=(const SubscribeZoomRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeZoomRangeRequest& operator=(SubscribeZoomRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeZoomRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeZoomRangeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeZoomRangeRequest*>(
               &_SubscribeZoomRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SubscribeZoomRangeRequest& a, SubscribeZoomRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeZoomRangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeZoomRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeZoomRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeZoomRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeZoomRangeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeZoomRangeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeZoomRangeRequest";
  }
  protected:
  explicit SubscribeZoomRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeZoomRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ZoomRangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.ZoomRangeResponse) */ {
 public:
  inline ZoomRangeResponse() : ZoomRangeResponse(nullptr) {}
  ~ZoomRangeResponse() override;
  explicit PROTOBUF_CONSTEXPR ZoomRangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZoomRangeResponse(const ZoomRangeResponse& from);
  ZoomRangeResponse(ZoomRangeResponse&& from) noexcept
    : ZoomRangeResponse() {
    *this = ::std::move(from);
  }

  inline ZoomRangeResponse& operator=(const ZoomRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomRangeResponse& operator=(ZoomRangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomRangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomRangeResponse* internal_default_instance() {
    return reinterpret_cast<const ZoomRangeResponse*>(
               &_ZoomRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ZoomRangeResponse& a, ZoomRangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomRangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomRangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomRangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomRangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZoomRangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZoomRangeResponse& from) {
    ZoomRangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZoomRangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.ZoomRangeResponse";
  }
  protected:
  explicit ZoomRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactorFieldNumber = 1,
  };
  // float factor = 1;
  void clear_factor();
  float factor() const;
  void set_factor(float value);
  private:
  float _internal_factor() const;
  void _internal_set_factor(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.ZoomRangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float factor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomRangeRequest) */ {
 public:
  inline RespondZoomRangeRequest() : RespondZoomRangeRequest(nullptr) {}
  ~RespondZoomRangeRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomRangeRequest(const RespondZoomRangeRequest& from);
  RespondZoomRangeRequest(RespondZoomRangeRequest&& from) noexcept
    : RespondZoomRangeRequest() {
    *this = ::std::move(from);
  }

  inline RespondZoomRangeRequest& operator=(const RespondZoomRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomRangeRequest& operator=(RespondZoomRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomRangeRequest* internal_default_instance() {
    return reinterpret_cast<const RespondZoomRangeRequest*>(
               &_RespondZoomRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(RespondZoomRangeRequest& a, RespondZoomRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomRangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomRangeRequest& from) {
    RespondZoomRangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomRangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomRangeRequest";
  }
  protected:
  explicit RespondZoomRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoomRangeFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback zoom_range_feedback = 1;
  void clear_zoom_range_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback zoom_range_feedback() const;
  void set_zoom_range_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_zoom_range_feedback() const;
  void _internal_set_zoom_range_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int zoom_range_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondZoomRangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondZoomRangeResponse) */ {
 public:
  inline RespondZoomRangeResponse() : RespondZoomRangeResponse(nullptr) {}
  ~RespondZoomRangeResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondZoomRangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondZoomRangeResponse(const RespondZoomRangeResponse& from);
  RespondZoomRangeResponse(RespondZoomRangeResponse&& from) noexcept
    : RespondZoomRangeResponse() {
    *this = ::std::move(from);
  }

  inline RespondZoomRangeResponse& operator=(const RespondZoomRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondZoomRangeResponse& operator=(RespondZoomRangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondZoomRangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondZoomRangeResponse* internal_default_instance() {
    return reinterpret_cast<const RespondZoomRangeResponse*>(
               &_RespondZoomRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(RespondZoomRangeResponse& a, RespondZoomRangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondZoomRangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondZoomRangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondZoomRangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondZoomRangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondZoomRangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondZoomRangeResponse& from) {
    RespondZoomRangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondZoomRangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondZoomRangeResponse";
  }
  protected:
  explicit RespondZoomRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondZoomRangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Information final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.Information) */ {
 public:
  inline Information() : Information(nullptr) {}
  ~Information() override;
  explicit PROTOBUF_CONSTEXPR Information(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Information(const Information& from);
  Information(Information&& from) noexcept
    : Information() {
    *this = ::std::move(from);
  }

  inline Information& operator=(const Information& from) {
    CopyFrom(from);
    return *this;
  }
  inline Information& operator=(Information&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Information& default_instance() {
    return *internal_default_instance();
  }
  static inline const Information* internal_default_instance() {
    return reinterpret_cast<const Information*>(
               &_Information_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Information& a, Information& b) {
    a.Swap(&b);
  }
  inline void Swap(Information* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Information* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Information* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Information>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Information& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Information& from) {
    Information::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Information* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.Information";
  }
  protected:
  explicit Information(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorNameFieldNumber = 1,
    kModelNameFieldNumber = 2,
    kFirmwareVersionFieldNumber = 3,
    kDefinitionFileUriFieldNumber = 11,
    kFocalLengthMmFieldNumber = 4,
    kHorizontalSensorSizeMmFieldNumber = 5,
    kVerticalSensorSizeMmFieldNumber = 6,
    kHorizontalResolutionPxFieldNumber = 7,
    kVerticalResolutionPxFieldNumber = 8,
    kLensIdFieldNumber = 9,
    kDefinitionFileVersionFieldNumber = 10,
    kImageInVideoModeSupportedFieldNumber = 12,
    kVideoInImageModeSupportedFieldNumber = 13,
  };
  // string vendor_name = 1;
  void clear_vendor_name();
  const std::string& vendor_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_name();
  PROTOBUF_NODISCARD std::string* release_vendor_name();
  void set_allocated_vendor_name(std::string* vendor_name);
  private:
  const std::string& _internal_vendor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_name(const std::string& value);
  std::string* _internal_mutable_vendor_name();
  public:

  // string model_name = 2;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string firmware_version = 3;
  void clear_firmware_version();
  const std::string& firmware_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* firmware_version);
  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(const std::string& value);
  std::string* _internal_mutable_firmware_version();
  public:

  // string definition_file_uri = 11;
  void clear_definition_file_uri();
  const std::string& definition_file_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_definition_file_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_definition_file_uri();
  PROTOBUF_NODISCARD std::string* release_definition_file_uri();
  void set_allocated_definition_file_uri(std::string* definition_file_uri);
  private:
  const std::string& _internal_definition_file_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_definition_file_uri(const std::string& value);
  std::string* _internal_mutable_definition_file_uri();
  public:

  // float focal_length_mm = 4;
  void clear_focal_length_mm();
  float focal_length_mm() const;
  void set_focal_length_mm(float value);
  private:
  float _internal_focal_length_mm() const;
  void _internal_set_focal_length_mm(float value);
  public:

  // float horizontal_sensor_size_mm = 5;
  void clear_horizontal_sensor_size_mm();
  float horizontal_sensor_size_mm() const;
  void set_horizontal_sensor_size_mm(float value);
  private:
  float _internal_horizontal_sensor_size_mm() const;
  void _internal_set_horizontal_sensor_size_mm(float value);
  public:

  // float vertical_sensor_size_mm = 6;
  void clear_vertical_sensor_size_mm();
  float vertical_sensor_size_mm() const;
  void set_vertical_sensor_size_mm(float value);
  private:
  float _internal_vertical_sensor_size_mm() const;
  void _internal_set_vertical_sensor_size_mm(float value);
  public:

  // uint32 horizontal_resolution_px = 7;
  void clear_horizontal_resolution_px();
  uint32_t horizontal_resolution_px() const;
  void set_horizontal_resolution_px(uint32_t value);
  private:
  uint32_t _internal_horizontal_resolution_px() const;
  void _internal_set_horizontal_resolution_px(uint32_t value);
  public:

  // uint32 vertical_resolution_px = 8;
  void clear_vertical_resolution_px();
  uint32_t vertical_resolution_px() const;
  void set_vertical_resolution_px(uint32_t value);
  private:
  uint32_t _internal_vertical_resolution_px() const;
  void _internal_set_vertical_resolution_px(uint32_t value);
  public:

  // uint32 lens_id = 9;
  void clear_lens_id();
  uint32_t lens_id() const;
  void set_lens_id(uint32_t value);
  private:
  uint32_t _internal_lens_id() const;
  void _internal_set_lens_id(uint32_t value);
  public:

  // uint32 definition_file_version = 10;
  void clear_definition_file_version();
  uint32_t definition_file_version() const;
  void set_definition_file_version(uint32_t value);
  private:
  uint32_t _internal_definition_file_version() const;
  void _internal_set_definition_file_version(uint32_t value);
  public:

  // bool image_in_video_mode_supported = 12;
  void clear_image_in_video_mode_supported();
  bool image_in_video_mode_supported() const;
  void set_image_in_video_mode_supported(bool value);
  private:
  bool _internal_image_in_video_mode_supported() const;
  void _internal_set_image_in_video_mode_supported(bool value);
  public:

  // bool video_in_image_mode_supported = 13;
  void clear_video_in_image_mode_supported();
  bool video_in_image_mode_supported() const;
  void set_video_in_image_mode_supported(bool value);
  private:
  bool _internal_video_in_image_mode_supported() const;
  void _internal_set_video_in_image_mode_supported(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.Information)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definition_file_uri_;
    float focal_length_mm_;
    float horizontal_sensor_size_mm_;
    float vertical_sensor_size_mm_;
    uint32_t horizontal_resolution_px_;
    uint32_t vertical_resolution_px_;
    uint32_t lens_id_;
    uint32_t definition_file_version_;
    bool image_in_video_mode_supported_;
    bool video_in_image_mode_supported_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class VideoStreaming final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.VideoStreaming) */ {
 public:
  inline VideoStreaming() : VideoStreaming(nullptr) {}
  ~VideoStreaming() override;
  explicit PROTOBUF_CONSTEXPR VideoStreaming(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreaming(const VideoStreaming& from);
  VideoStreaming(VideoStreaming&& from) noexcept
    : VideoStreaming() {
    *this = ::std::move(from);
  }

  inline VideoStreaming& operator=(const VideoStreaming& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreaming& operator=(VideoStreaming&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreaming& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreaming* internal_default_instance() {
    return reinterpret_cast<const VideoStreaming*>(
               &_VideoStreaming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(VideoStreaming& a, VideoStreaming& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreaming* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreaming* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreaming* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreaming>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreaming& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreaming& from) {
    VideoStreaming::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreaming* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.VideoStreaming";
  }
  protected:
  explicit VideoStreaming(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRtspUriFieldNumber = 2,
    kHasRtspServerFieldNumber = 1,
  };
  // string rtsp_uri = 2;
  void clear_rtsp_uri();
  const std::string& rtsp_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rtsp_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rtsp_uri();
  PROTOBUF_NODISCARD std::string* release_rtsp_uri();
  void set_allocated_rtsp_uri(std::string* rtsp_uri);
  private:
  const std::string& _internal_rtsp_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtsp_uri(const std::string& value);
  std::string* _internal_mutable_rtsp_uri();
  public:

  // bool has_rtsp_server = 1;
  void clear_has_rtsp_server();
  bool has_rtsp_server() const;
  void set_has_rtsp_server(bool value);
  private:
  bool _internal_has_rtsp_server() const;
  void _internal_set_has_rtsp_server(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.VideoStreaming)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rtsp_uri_;
    bool has_rtsp_server_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeDegFieldNumber = 1,
    kLongitudeDegFieldNumber = 2,
    kAbsoluteAltitudeMFieldNumber = 3,
    kRelativeAltitudeMFieldNumber = 4,
  };
  // double latitude_deg = 1;
  void clear_latitude_deg();
  double latitude_deg() const;
  void set_latitude_deg(double value);
  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);
  public:

  // double longitude_deg = 2;
  void clear_longitude_deg();
  double longitude_deg() const;
  void set_longitude_deg(double value);
  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);
  public:

  // float absolute_altitude_m = 3;
  void clear_absolute_altitude_m();
  float absolute_altitude_m() const;
  void set_absolute_altitude_m(float value);
  private:
  float _internal_absolute_altitude_m() const;
  void _internal_set_absolute_altitude_m(float value);
  public:

  // float relative_altitude_m = 4;
  void clear_relative_altitude_m();
  float relative_altitude_m() const;
  void set_relative_altitude_m(float value);
  private:
  float _internal_relative_altitude_m() const;
  void _internal_set_relative_altitude_m(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double latitude_deg_;
    double longitude_deg_;
    float absolute_altitude_m_;
    float relative_altitude_m_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // float w = 1;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float w_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class CaptureInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.CaptureInfo) */ {
 public:
  inline CaptureInfo() : CaptureInfo(nullptr) {}
  ~CaptureInfo() override;
  explicit PROTOBUF_CONSTEXPR CaptureInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureInfo(const CaptureInfo& from);
  CaptureInfo(CaptureInfo&& from) noexcept
    : CaptureInfo() {
    *this = ::std::move(from);
  }

  inline CaptureInfo& operator=(const CaptureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureInfo& operator=(CaptureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureInfo* internal_default_instance() {
    return reinterpret_cast<const CaptureInfo*>(
               &_CaptureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CaptureInfo& a, CaptureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureInfo& from) {
    CaptureInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.CaptureInfo";
  }
  protected:
  explicit CaptureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileUrlFieldNumber = 6,
    kPositionFieldNumber = 1,
    kAttitudeQuaternionFieldNumber = 2,
    kTimeUtcUsFieldNumber = 3,
    kIsSuccessFieldNumber = 4,
    kIndexFieldNumber = 5,
  };
  // string file_url = 6;
  void clear_file_url();
  const std::string& file_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_url();
  PROTOBUF_NODISCARD std::string* release_file_url();
  void set_allocated_file_url(std::string* file_url);
  private:
  const std::string& _internal_file_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_url(const std::string& value);
  std::string* _internal_mutable_file_url();
  public:

  // .mavsdk.rpc.camera_server.Position position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::mavsdk::rpc::camera_server::Position& position() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::Position* release_position();
  ::mavsdk::rpc::camera_server::Position* mutable_position();
  void set_allocated_position(::mavsdk::rpc::camera_server::Position* position);
  private:
  const ::mavsdk::rpc::camera_server::Position& _internal_position() const;
  ::mavsdk::rpc::camera_server::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::mavsdk::rpc::camera_server::Position* position);
  ::mavsdk::rpc::camera_server::Position* unsafe_arena_release_position();

  // .mavsdk.rpc.camera_server.Quaternion attitude_quaternion = 2;
  bool has_attitude_quaternion() const;
  private:
  bool _internal_has_attitude_quaternion() const;
  public:
  void clear_attitude_quaternion();
  const ::mavsdk::rpc::camera_server::Quaternion& attitude_quaternion() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::Quaternion* release_attitude_quaternion();
  ::mavsdk::rpc::camera_server::Quaternion* mutable_attitude_quaternion();
  void set_allocated_attitude_quaternion(::mavsdk::rpc::camera_server::Quaternion* attitude_quaternion);
  private:
  const ::mavsdk::rpc::camera_server::Quaternion& _internal_attitude_quaternion() const;
  ::mavsdk::rpc::camera_server::Quaternion* _internal_mutable_attitude_quaternion();
  public:
  void unsafe_arena_set_allocated_attitude_quaternion(
      ::mavsdk::rpc::camera_server::Quaternion* attitude_quaternion);
  ::mavsdk::rpc::camera_server::Quaternion* unsafe_arena_release_attitude_quaternion();

  // uint64 time_utc_us = 3;
  void clear_time_utc_us();
  uint64_t time_utc_us() const;
  void set_time_utc_us(uint64_t value);
  private:
  uint64_t _internal_time_utc_us() const;
  void _internal_set_time_utc_us(uint64_t value);
  public:

  // bool is_success = 4;
  void clear_is_success();
  bool is_success() const;
  void set_is_success(bool value);
  private:
  bool _internal_is_success() const;
  void _internal_set_is_success(bool value);
  public:

  // int32 index = 5;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.CaptureInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_url_;
    ::mavsdk::rpc::camera_server::Position* position_;
    ::mavsdk::rpc::camera_server::Quaternion* attitude_quaternion_;
    uint64_t time_utc_us_;
    bool is_success_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class CameraServerResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.CameraServerResult) */ {
 public:
  inline CameraServerResult() : CameraServerResult(nullptr) {}
  ~CameraServerResult() override;
  explicit PROTOBUF_CONSTEXPR CameraServerResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraServerResult(const CameraServerResult& from);
  CameraServerResult(CameraServerResult&& from) noexcept
    : CameraServerResult() {
    *this = ::std::move(from);
  }

  inline CameraServerResult& operator=(const CameraServerResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraServerResult& operator=(CameraServerResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraServerResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraServerResult* internal_default_instance() {
    return reinterpret_cast<const CameraServerResult*>(
               &_CameraServerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CameraServerResult& a, CameraServerResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraServerResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraServerResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraServerResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraServerResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraServerResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraServerResult& from) {
    CameraServerResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraServerResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.CameraServerResult";
  }
  protected:
  explicit CameraServerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CameraServerResult_Result Result;
  static constexpr Result RESULT_UNKNOWN =
    CameraServerResult_Result_RESULT_UNKNOWN;
  static constexpr Result RESULT_SUCCESS =
    CameraServerResult_Result_RESULT_SUCCESS;
  static constexpr Result RESULT_IN_PROGRESS =
    CameraServerResult_Result_RESULT_IN_PROGRESS;
  static constexpr Result RESULT_BUSY =
    CameraServerResult_Result_RESULT_BUSY;
  static constexpr Result RESULT_DENIED =
    CameraServerResult_Result_RESULT_DENIED;
  static constexpr Result RESULT_ERROR =
    CameraServerResult_Result_RESULT_ERROR;
  static constexpr Result RESULT_TIMEOUT =
    CameraServerResult_Result_RESULT_TIMEOUT;
  static constexpr Result RESULT_WRONG_ARGUMENT =
    CameraServerResult_Result_RESULT_WRONG_ARGUMENT;
  static constexpr Result RESULT_NO_SYSTEM =
    CameraServerResult_Result_RESULT_NO_SYSTEM;
  static inline bool Result_IsValid(int value) {
    return CameraServerResult_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CameraServerResult_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CameraServerResult_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CameraServerResult_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CameraServerResult_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CameraServerResult_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CameraServerResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultStrFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string result_str = 2;
  void clear_result_str();
  const std::string& result_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_str();
  PROTOBUF_NODISCARD std::string* release_result_str();
  void set_allocated_result_str(std::string* result_str);
  private:
  const std::string& _internal_result_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_str(const std::string& value);
  std::string* _internal_mutable_result_str();
  public:

  // .mavsdk.rpc.camera_server.CameraServerResult.Result result = 1;
  void clear_result();
  ::mavsdk::rpc::camera_server::CameraServerResult_Result result() const;
  void set_result(::mavsdk::rpc::camera_server::CameraServerResult_Result value);
  private:
  ::mavsdk::rpc::camera_server::CameraServerResult_Result _internal_result() const;
  void _internal_set_result(::mavsdk::rpc::camera_server::CameraServerResult_Result value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.CameraServerResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_str_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class StorageInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.StorageInformation) */ {
 public:
  inline StorageInformation() : StorageInformation(nullptr) {}
  ~StorageInformation() override;
  explicit PROTOBUF_CONSTEXPR StorageInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageInformation(const StorageInformation& from);
  StorageInformation(StorageInformation&& from) noexcept
    : StorageInformation() {
    *this = ::std::move(from);
  }

  inline StorageInformation& operator=(const StorageInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageInformation& operator=(StorageInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageInformation* internal_default_instance() {
    return reinterpret_cast<const StorageInformation*>(
               &_StorageInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(StorageInformation& a, StorageInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageInformation& from) {
    StorageInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.StorageInformation";
  }
  protected:
  explicit StorageInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StorageInformation_StorageStatus StorageStatus;
  static constexpr StorageStatus STORAGE_STATUS_NOT_AVAILABLE =
    StorageInformation_StorageStatus_STORAGE_STATUS_NOT_AVAILABLE;
  static constexpr StorageStatus STORAGE_STATUS_UNFORMATTED =
    StorageInformation_StorageStatus_STORAGE_STATUS_UNFORMATTED;
  static constexpr StorageStatus STORAGE_STATUS_FORMATTED =
    StorageInformation_StorageStatus_STORAGE_STATUS_FORMATTED;
  static constexpr StorageStatus STORAGE_STATUS_NOT_SUPPORTED =
    StorageInformation_StorageStatus_STORAGE_STATUS_NOT_SUPPORTED;
  static inline bool StorageStatus_IsValid(int value) {
    return StorageInformation_StorageStatus_IsValid(value);
  }
  static constexpr StorageStatus StorageStatus_MIN =
    StorageInformation_StorageStatus_StorageStatus_MIN;
  static constexpr StorageStatus StorageStatus_MAX =
    StorageInformation_StorageStatus_StorageStatus_MAX;
  static constexpr int StorageStatus_ARRAYSIZE =
    StorageInformation_StorageStatus_StorageStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StorageStatus_descriptor() {
    return StorageInformation_StorageStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& StorageStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StorageStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StorageStatus_Name.");
    return StorageInformation_StorageStatus_Name(enum_t_value);
  }
  static inline bool StorageStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StorageStatus* value) {
    return StorageInformation_StorageStatus_Parse(name, value);
  }

  typedef StorageInformation_StorageType StorageType;
  static constexpr StorageType STORAGE_TYPE_UNKNOWN =
    StorageInformation_StorageType_STORAGE_TYPE_UNKNOWN;
  static constexpr StorageType STORAGE_TYPE_USB_STICK =
    StorageInformation_StorageType_STORAGE_TYPE_USB_STICK;
  static constexpr StorageType STORAGE_TYPE_SD =
    StorageInformation_StorageType_STORAGE_TYPE_SD;
  static constexpr StorageType STORAGE_TYPE_MICROSD =
    StorageInformation_StorageType_STORAGE_TYPE_MICROSD;
  static constexpr StorageType STORAGE_TYPE_HD =
    StorageInformation_StorageType_STORAGE_TYPE_HD;
  static constexpr StorageType STORAGE_TYPE_OTHER =
    StorageInformation_StorageType_STORAGE_TYPE_OTHER;
  static inline bool StorageType_IsValid(int value) {
    return StorageInformation_StorageType_IsValid(value);
  }
  static constexpr StorageType StorageType_MIN =
    StorageInformation_StorageType_StorageType_MIN;
  static constexpr StorageType StorageType_MAX =
    StorageInformation_StorageType_StorageType_MAX;
  static constexpr int StorageType_ARRAYSIZE =
    StorageInformation_StorageType_StorageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StorageType_descriptor() {
    return StorageInformation_StorageType_descriptor();
  }
  template<typename T>
  static inline const std::string& StorageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StorageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StorageType_Name.");
    return StorageInformation_StorageType_Name(enum_t_value);
  }
  static inline bool StorageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StorageType* value) {
    return StorageInformation_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsedStorageMibFieldNumber = 1,
    kAvailableStorageMibFieldNumber = 2,
    kTotalStorageMibFieldNumber = 3,
    kStorageStatusFieldNumber = 4,
    kStorageIdFieldNumber = 5,
    kStorageTypeFieldNumber = 6,
    kReadSpeedMibSFieldNumber = 7,
    kWriteSpeedMibSFieldNumber = 8,
  };
  // float used_storage_mib = 1;
  void clear_used_storage_mib();
  float used_storage_mib() const;
  void set_used_storage_mib(float value);
  private:
  float _internal_used_storage_mib() const;
  void _internal_set_used_storage_mib(float value);
  public:

  // float available_storage_mib = 2;
  void clear_available_storage_mib();
  float available_storage_mib() const;
  void set_available_storage_mib(float value);
  private:
  float _internal_available_storage_mib() const;
  void _internal_set_available_storage_mib(float value);
  public:

  // float total_storage_mib = 3;
  void clear_total_storage_mib();
  float total_storage_mib() const;
  void set_total_storage_mib(float value);
  private:
  float _internal_total_storage_mib() const;
  void _internal_set_total_storage_mib(float value);
  public:

  // .mavsdk.rpc.camera_server.StorageInformation.StorageStatus storage_status = 4;
  void clear_storage_status();
  ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus storage_status() const;
  void set_storage_status(::mavsdk::rpc::camera_server::StorageInformation_StorageStatus value);
  private:
  ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus _internal_storage_status() const;
  void _internal_set_storage_status(::mavsdk::rpc::camera_server::StorageInformation_StorageStatus value);
  public:

  // uint32 storage_id = 5;
  void clear_storage_id();
  uint32_t storage_id() const;
  void set_storage_id(uint32_t value);
  private:
  uint32_t _internal_storage_id() const;
  void _internal_set_storage_id(uint32_t value);
  public:

  // .mavsdk.rpc.camera_server.StorageInformation.StorageType storage_type = 6;
  void clear_storage_type();
  ::mavsdk::rpc::camera_server::StorageInformation_StorageType storage_type() const;
  void set_storage_type(::mavsdk::rpc::camera_server::StorageInformation_StorageType value);
  private:
  ::mavsdk::rpc::camera_server::StorageInformation_StorageType _internal_storage_type() const;
  void _internal_set_storage_type(::mavsdk::rpc::camera_server::StorageInformation_StorageType value);
  public:

  // float read_speed_mib_s = 7;
  void clear_read_speed_mib_s();
  float read_speed_mib_s() const;
  void set_read_speed_mib_s(float value);
  private:
  float _internal_read_speed_mib_s() const;
  void _internal_set_read_speed_mib_s(float value);
  public:

  // float write_speed_mib_s = 8;
  void clear_write_speed_mib_s();
  float write_speed_mib_s() const;
  void set_write_speed_mib_s(float value);
  private:
  float _internal_write_speed_mib_s() const;
  void _internal_set_write_speed_mib_s(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.StorageInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float used_storage_mib_;
    float available_storage_mib_;
    float total_storage_mib_;
    int storage_status_;
    uint32_t storage_id_;
    int storage_type_;
    float read_speed_mib_s_;
    float write_speed_mib_s_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class CaptureStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.CaptureStatus) */ {
 public:
  inline CaptureStatus() : CaptureStatus(nullptr) {}
  ~CaptureStatus() override;
  explicit PROTOBUF_CONSTEXPR CaptureStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureStatus(const CaptureStatus& from);
  CaptureStatus(CaptureStatus&& from) noexcept
    : CaptureStatus() {
    *this = ::std::move(from);
  }

  inline CaptureStatus& operator=(const CaptureStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureStatus& operator=(CaptureStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureStatus* internal_default_instance() {
    return reinterpret_cast<const CaptureStatus*>(
               &_CaptureStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CaptureStatus& a, CaptureStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureStatus& from) {
    CaptureStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.CaptureStatus";
  }
  protected:
  explicit CaptureStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CaptureStatus_ImageStatus ImageStatus;
  static constexpr ImageStatus IMAGE_STATUS_IDLE =
    CaptureStatus_ImageStatus_IMAGE_STATUS_IDLE;
  static constexpr ImageStatus IMAGE_STATUS_CAPTURE_IN_PROGRESS =
    CaptureStatus_ImageStatus_IMAGE_STATUS_CAPTURE_IN_PROGRESS;
  static constexpr ImageStatus IMAGE_STATUS_INTERVAL_IDLE =
    CaptureStatus_ImageStatus_IMAGE_STATUS_INTERVAL_IDLE;
  static constexpr ImageStatus IMAGE_STATUS_INTERVAL_IN_PROGRESS =
    CaptureStatus_ImageStatus_IMAGE_STATUS_INTERVAL_IN_PROGRESS;
  static inline bool ImageStatus_IsValid(int value) {
    return CaptureStatus_ImageStatus_IsValid(value);
  }
  static constexpr ImageStatus ImageStatus_MIN =
    CaptureStatus_ImageStatus_ImageStatus_MIN;
  static constexpr ImageStatus ImageStatus_MAX =
    CaptureStatus_ImageStatus_ImageStatus_MAX;
  static constexpr int ImageStatus_ARRAYSIZE =
    CaptureStatus_ImageStatus_ImageStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageStatus_descriptor() {
    return CaptureStatus_ImageStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageStatus_Name.");
    return CaptureStatus_ImageStatus_Name(enum_t_value);
  }
  static inline bool ImageStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageStatus* value) {
    return CaptureStatus_ImageStatus_Parse(name, value);
  }

  typedef CaptureStatus_VideoStatus VideoStatus;
  static constexpr VideoStatus VIDEO_STATUS_IDLE =
    CaptureStatus_VideoStatus_VIDEO_STATUS_IDLE;
  static constexpr VideoStatus VIDEO_STATUS_CAPTURE_IN_PROGRESS =
    CaptureStatus_VideoStatus_VIDEO_STATUS_CAPTURE_IN_PROGRESS;
  static inline bool VideoStatus_IsValid(int value) {
    return CaptureStatus_VideoStatus_IsValid(value);
  }
  static constexpr VideoStatus VideoStatus_MIN =
    CaptureStatus_VideoStatus_VideoStatus_MIN;
  static constexpr VideoStatus VideoStatus_MAX =
    CaptureStatus_VideoStatus_VideoStatus_MAX;
  static constexpr int VideoStatus_ARRAYSIZE =
    CaptureStatus_VideoStatus_VideoStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VideoStatus_descriptor() {
    return CaptureStatus_VideoStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& VideoStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VideoStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VideoStatus_Name.");
    return CaptureStatus_VideoStatus_Name(enum_t_value);
  }
  static inline bool VideoStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VideoStatus* value) {
    return CaptureStatus_VideoStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageIntervalSFieldNumber = 1,
    kRecordingTimeSFieldNumber = 2,
    kAvailableCapacityMibFieldNumber = 3,
    kImageStatusFieldNumber = 4,
    kVideoStatusFieldNumber = 5,
    kImageCountFieldNumber = 6,
  };
  // float image_interval_s = 1;
  void clear_image_interval_s();
  float image_interval_s() const;
  void set_image_interval_s(float value);
  private:
  float _internal_image_interval_s() const;
  void _internal_set_image_interval_s(float value);
  public:

  // float recording_time_s = 2;
  void clear_recording_time_s();
  float recording_time_s() const;
  void set_recording_time_s(float value);
  private:
  float _internal_recording_time_s() const;
  void _internal_set_recording_time_s(float value);
  public:

  // float available_capacity_mib = 3;
  void clear_available_capacity_mib();
  float available_capacity_mib() const;
  void set_available_capacity_mib(float value);
  private:
  float _internal_available_capacity_mib() const;
  void _internal_set_available_capacity_mib(float value);
  public:

  // .mavsdk.rpc.camera_server.CaptureStatus.ImageStatus image_status = 4;
  void clear_image_status();
  ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus image_status() const;
  void set_image_status(::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus value);
  private:
  ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus _internal_image_status() const;
  void _internal_set_image_status(::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus value);
  public:

  // .mavsdk.rpc.camera_server.CaptureStatus.VideoStatus video_status = 5;
  void clear_video_status();
  ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus video_status() const;
  void set_video_status(::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus value);
  private:
  ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus _internal_video_status() const;
  void _internal_set_video_status(::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus value);
  public:

  // int32 image_count = 6;
  void clear_image_count();
  int32_t image_count() const;
  void set_image_count(int32_t value);
  private:
  int32_t _internal_image_count() const;
  void _internal_set_image_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.CaptureStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float image_interval_s_;
    float recording_time_s_;
    float available_capacity_mib_;
    int image_status_;
    int video_status_;
    int32_t image_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingPointStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest) */ {
 public:
  inline SetTrackingPointStatusRequest() : SetTrackingPointStatusRequest(nullptr) {}
  ~SetTrackingPointStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR SetTrackingPointStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingPointStatusRequest(const SetTrackingPointStatusRequest& from);
  SetTrackingPointStatusRequest(SetTrackingPointStatusRequest&& from) noexcept
    : SetTrackingPointStatusRequest() {
    *this = ::std::move(from);
  }

  inline SetTrackingPointStatusRequest& operator=(const SetTrackingPointStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingPointStatusRequest& operator=(SetTrackingPointStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingPointStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingPointStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SetTrackingPointStatusRequest*>(
               &_SetTrackingPointStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(SetTrackingPointStatusRequest& a, SetTrackingPointStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingPointStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingPointStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingPointStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingPointStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTrackingPointStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTrackingPointStatusRequest& from) {
    SetTrackingPointStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTrackingPointStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingPointStatusRequest";
  }
  protected:
  explicit SetTrackingPointStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackedPointFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.TrackPoint tracked_point = 1;
  bool has_tracked_point() const;
  private:
  bool _internal_has_tracked_point() const;
  public:
  void clear_tracked_point();
  const ::mavsdk::rpc::camera_server::TrackPoint& tracked_point() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::TrackPoint* release_tracked_point();
  ::mavsdk::rpc::camera_server::TrackPoint* mutable_tracked_point();
  void set_allocated_tracked_point(::mavsdk::rpc::camera_server::TrackPoint* tracked_point);
  private:
  const ::mavsdk::rpc::camera_server::TrackPoint& _internal_tracked_point() const;
  ::mavsdk::rpc::camera_server::TrackPoint* _internal_mutable_tracked_point();
  public:
  void unsafe_arena_set_allocated_tracked_point(
      ::mavsdk::rpc::camera_server::TrackPoint* tracked_point);
  ::mavsdk::rpc::camera_server::TrackPoint* unsafe_arena_release_tracked_point();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::TrackPoint* tracked_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingPointStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingPointStatusResponse) */ {
 public:
  inline SetTrackingPointStatusResponse() : SetTrackingPointStatusResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetTrackingPointStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingPointStatusResponse(const SetTrackingPointStatusResponse& from);
  SetTrackingPointStatusResponse(SetTrackingPointStatusResponse&& from) noexcept
    : SetTrackingPointStatusResponse() {
    *this = ::std::move(from);
  }

  inline SetTrackingPointStatusResponse& operator=(const SetTrackingPointStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingPointStatusResponse& operator=(SetTrackingPointStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingPointStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingPointStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SetTrackingPointStatusResponse*>(
               &_SetTrackingPointStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SetTrackingPointStatusResponse& a, SetTrackingPointStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingPointStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingPointStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingPointStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingPointStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTrackingPointStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTrackingPointStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingPointStatusResponse";
  }
  protected:
  explicit SetTrackingPointStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingPointStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingRectangleStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest) */ {
 public:
  inline SetTrackingRectangleStatusRequest() : SetTrackingRectangleStatusRequest(nullptr) {}
  ~SetTrackingRectangleStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR SetTrackingRectangleStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingRectangleStatusRequest(const SetTrackingRectangleStatusRequest& from);
  SetTrackingRectangleStatusRequest(SetTrackingRectangleStatusRequest&& from) noexcept
    : SetTrackingRectangleStatusRequest() {
    *this = ::std::move(from);
  }

  inline SetTrackingRectangleStatusRequest& operator=(const SetTrackingRectangleStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingRectangleStatusRequest& operator=(SetTrackingRectangleStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingRectangleStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingRectangleStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SetTrackingRectangleStatusRequest*>(
               &_SetTrackingRectangleStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SetTrackingRectangleStatusRequest& a, SetTrackingRectangleStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingRectangleStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingRectangleStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingRectangleStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingRectangleStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTrackingRectangleStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTrackingRectangleStatusRequest& from) {
    SetTrackingRectangleStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTrackingRectangleStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest";
  }
  protected:
  explicit SetTrackingRectangleStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackedRectangleFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.TrackRectangle tracked_rectangle = 1;
  bool has_tracked_rectangle() const;
  private:
  bool _internal_has_tracked_rectangle() const;
  public:
  void clear_tracked_rectangle();
  const ::mavsdk::rpc::camera_server::TrackRectangle& tracked_rectangle() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::TrackRectangle* release_tracked_rectangle();
  ::mavsdk::rpc::camera_server::TrackRectangle* mutable_tracked_rectangle();
  void set_allocated_tracked_rectangle(::mavsdk::rpc::camera_server::TrackRectangle* tracked_rectangle);
  private:
  const ::mavsdk::rpc::camera_server::TrackRectangle& _internal_tracked_rectangle() const;
  ::mavsdk::rpc::camera_server::TrackRectangle* _internal_mutable_tracked_rectangle();
  public:
  void unsafe_arena_set_allocated_tracked_rectangle(
      ::mavsdk::rpc::camera_server::TrackRectangle* tracked_rectangle);
  ::mavsdk::rpc::camera_server::TrackRectangle* unsafe_arena_release_tracked_rectangle();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::TrackRectangle* tracked_rectangle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingRectangleStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse) */ {
 public:
  inline SetTrackingRectangleStatusResponse() : SetTrackingRectangleStatusResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetTrackingRectangleStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingRectangleStatusResponse(const SetTrackingRectangleStatusResponse& from);
  SetTrackingRectangleStatusResponse(SetTrackingRectangleStatusResponse&& from) noexcept
    : SetTrackingRectangleStatusResponse() {
    *this = ::std::move(from);
  }

  inline SetTrackingRectangleStatusResponse& operator=(const SetTrackingRectangleStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingRectangleStatusResponse& operator=(SetTrackingRectangleStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingRectangleStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingRectangleStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SetTrackingRectangleStatusResponse*>(
               &_SetTrackingRectangleStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(SetTrackingRectangleStatusResponse& a, SetTrackingRectangleStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingRectangleStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingRectangleStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingRectangleStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingRectangleStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTrackingRectangleStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTrackingRectangleStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse";
  }
  protected:
  explicit SetTrackingRectangleStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingOffStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingOffStatusRequest) */ {
 public:
  inline SetTrackingOffStatusRequest() : SetTrackingOffStatusRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetTrackingOffStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingOffStatusRequest(const SetTrackingOffStatusRequest& from);
  SetTrackingOffStatusRequest(SetTrackingOffStatusRequest&& from) noexcept
    : SetTrackingOffStatusRequest() {
    *this = ::std::move(from);
  }

  inline SetTrackingOffStatusRequest& operator=(const SetTrackingOffStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingOffStatusRequest& operator=(SetTrackingOffStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingOffStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingOffStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SetTrackingOffStatusRequest*>(
               &_SetTrackingOffStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(SetTrackingOffStatusRequest& a, SetTrackingOffStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingOffStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingOffStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingOffStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingOffStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTrackingOffStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTrackingOffStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingOffStatusRequest";
  }
  protected:
  explicit SetTrackingOffStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingOffStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SetTrackingOffStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SetTrackingOffStatusResponse) */ {
 public:
  inline SetTrackingOffStatusResponse() : SetTrackingOffStatusResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetTrackingOffStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackingOffStatusResponse(const SetTrackingOffStatusResponse& from);
  SetTrackingOffStatusResponse(SetTrackingOffStatusResponse&& from) noexcept
    : SetTrackingOffStatusResponse() {
    *this = ::std::move(from);
  }

  inline SetTrackingOffStatusResponse& operator=(const SetTrackingOffStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackingOffStatusResponse& operator=(SetTrackingOffStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackingOffStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackingOffStatusResponse* internal_default_instance() {
    return reinterpret_cast<const SetTrackingOffStatusResponse*>(
               &_SetTrackingOffStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(SetTrackingOffStatusResponse& a, SetTrackingOffStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackingOffStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackingOffStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackingOffStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackingOffStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTrackingOffStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTrackingOffStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SetTrackingOffStatusResponse";
  }
  protected:
  explicit SetTrackingOffStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SetTrackingOffStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTrackingPointCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest) */ {
 public:
  inline SubscribeTrackingPointCommandRequest() : SubscribeTrackingPointCommandRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeTrackingPointCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTrackingPointCommandRequest(const SubscribeTrackingPointCommandRequest& from);
  SubscribeTrackingPointCommandRequest(SubscribeTrackingPointCommandRequest&& from) noexcept
    : SubscribeTrackingPointCommandRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeTrackingPointCommandRequest& operator=(const SubscribeTrackingPointCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTrackingPointCommandRequest& operator=(SubscribeTrackingPointCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTrackingPointCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTrackingPointCommandRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeTrackingPointCommandRequest*>(
               &_SubscribeTrackingPointCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(SubscribeTrackingPointCommandRequest& a, SubscribeTrackingPointCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTrackingPointCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTrackingPointCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTrackingPointCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTrackingPointCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeTrackingPointCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeTrackingPointCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest";
  }
  protected:
  explicit SubscribeTrackingPointCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TrackingPointCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TrackingPointCommandResponse) */ {
 public:
  inline TrackingPointCommandResponse() : TrackingPointCommandResponse(nullptr) {}
  ~TrackingPointCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR TrackingPointCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackingPointCommandResponse(const TrackingPointCommandResponse& from);
  TrackingPointCommandResponse(TrackingPointCommandResponse&& from) noexcept
    : TrackingPointCommandResponse() {
    *this = ::std::move(from);
  }

  inline TrackingPointCommandResponse& operator=(const TrackingPointCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingPointCommandResponse& operator=(TrackingPointCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingPointCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingPointCommandResponse* internal_default_instance() {
    return reinterpret_cast<const TrackingPointCommandResponse*>(
               &_TrackingPointCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(TrackingPointCommandResponse& a, TrackingPointCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackingPointCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingPointCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingPointCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackingPointCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackingPointCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackingPointCommandResponse& from) {
    TrackingPointCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackingPointCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TrackingPointCommandResponse";
  }
  protected:
  explicit TrackingPointCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackPointFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.TrackPoint track_point = 1;
  bool has_track_point() const;
  private:
  bool _internal_has_track_point() const;
  public:
  void clear_track_point();
  const ::mavsdk::rpc::camera_server::TrackPoint& track_point() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::TrackPoint* release_track_point();
  ::mavsdk::rpc::camera_server::TrackPoint* mutable_track_point();
  void set_allocated_track_point(::mavsdk::rpc::camera_server::TrackPoint* track_point);
  private:
  const ::mavsdk::rpc::camera_server::TrackPoint& _internal_track_point() const;
  ::mavsdk::rpc::camera_server::TrackPoint* _internal_mutable_track_point();
  public:
  void unsafe_arena_set_allocated_track_point(
      ::mavsdk::rpc::camera_server::TrackPoint* track_point);
  ::mavsdk::rpc::camera_server::TrackPoint* unsafe_arena_release_track_point();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TrackingPointCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::TrackPoint* track_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTrackingRectangleCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest) */ {
 public:
  inline SubscribeTrackingRectangleCommandRequest() : SubscribeTrackingRectangleCommandRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeTrackingRectangleCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTrackingRectangleCommandRequest(const SubscribeTrackingRectangleCommandRequest& from);
  SubscribeTrackingRectangleCommandRequest(SubscribeTrackingRectangleCommandRequest&& from) noexcept
    : SubscribeTrackingRectangleCommandRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeTrackingRectangleCommandRequest& operator=(const SubscribeTrackingRectangleCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTrackingRectangleCommandRequest& operator=(SubscribeTrackingRectangleCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTrackingRectangleCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTrackingRectangleCommandRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeTrackingRectangleCommandRequest*>(
               &_SubscribeTrackingRectangleCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(SubscribeTrackingRectangleCommandRequest& a, SubscribeTrackingRectangleCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTrackingRectangleCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTrackingRectangleCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTrackingRectangleCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTrackingRectangleCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeTrackingRectangleCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeTrackingRectangleCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest";
  }
  protected:
  explicit SubscribeTrackingRectangleCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TrackingRectangleCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse) */ {
 public:
  inline TrackingRectangleCommandResponse() : TrackingRectangleCommandResponse(nullptr) {}
  ~TrackingRectangleCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR TrackingRectangleCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackingRectangleCommandResponse(const TrackingRectangleCommandResponse& from);
  TrackingRectangleCommandResponse(TrackingRectangleCommandResponse&& from) noexcept
    : TrackingRectangleCommandResponse() {
    *this = ::std::move(from);
  }

  inline TrackingRectangleCommandResponse& operator=(const TrackingRectangleCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingRectangleCommandResponse& operator=(TrackingRectangleCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingRectangleCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingRectangleCommandResponse* internal_default_instance() {
    return reinterpret_cast<const TrackingRectangleCommandResponse*>(
               &_TrackingRectangleCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(TrackingRectangleCommandResponse& a, TrackingRectangleCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackingRectangleCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingRectangleCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingRectangleCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackingRectangleCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackingRectangleCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackingRectangleCommandResponse& from) {
    TrackingRectangleCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackingRectangleCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TrackingRectangleCommandResponse";
  }
  protected:
  explicit TrackingRectangleCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackRectangleFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.TrackRectangle track_rectangle = 1;
  bool has_track_rectangle() const;
  private:
  bool _internal_has_track_rectangle() const;
  public:
  void clear_track_rectangle();
  const ::mavsdk::rpc::camera_server::TrackRectangle& track_rectangle() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::TrackRectangle* release_track_rectangle();
  ::mavsdk::rpc::camera_server::TrackRectangle* mutable_track_rectangle();
  void set_allocated_track_rectangle(::mavsdk::rpc::camera_server::TrackRectangle* track_rectangle);
  private:
  const ::mavsdk::rpc::camera_server::TrackRectangle& _internal_track_rectangle() const;
  ::mavsdk::rpc::camera_server::TrackRectangle* _internal_mutable_track_rectangle();
  public:
  void unsafe_arena_set_allocated_track_rectangle(
      ::mavsdk::rpc::camera_server::TrackRectangle* track_rectangle);
  ::mavsdk::rpc::camera_server::TrackRectangle* unsafe_arena_release_track_rectangle();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::TrackRectangle* track_rectangle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTrackingOffCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest) */ {
 public:
  inline SubscribeTrackingOffCommandRequest() : SubscribeTrackingOffCommandRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeTrackingOffCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTrackingOffCommandRequest(const SubscribeTrackingOffCommandRequest& from);
  SubscribeTrackingOffCommandRequest(SubscribeTrackingOffCommandRequest&& from) noexcept
    : SubscribeTrackingOffCommandRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeTrackingOffCommandRequest& operator=(const SubscribeTrackingOffCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTrackingOffCommandRequest& operator=(SubscribeTrackingOffCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTrackingOffCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTrackingOffCommandRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeTrackingOffCommandRequest*>(
               &_SubscribeTrackingOffCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(SubscribeTrackingOffCommandRequest& a, SubscribeTrackingOffCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTrackingOffCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTrackingOffCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTrackingOffCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTrackingOffCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeTrackingOffCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeTrackingOffCommandRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest";
  }
  protected:
  explicit SubscribeTrackingOffCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TrackingOffCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TrackingOffCommandResponse) */ {
 public:
  inline TrackingOffCommandResponse() : TrackingOffCommandResponse(nullptr) {}
  ~TrackingOffCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR TrackingOffCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackingOffCommandResponse(const TrackingOffCommandResponse& from);
  TrackingOffCommandResponse(TrackingOffCommandResponse&& from) noexcept
    : TrackingOffCommandResponse() {
    *this = ::std::move(from);
  }

  inline TrackingOffCommandResponse& operator=(const TrackingOffCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingOffCommandResponse& operator=(TrackingOffCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackingOffCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackingOffCommandResponse* internal_default_instance() {
    return reinterpret_cast<const TrackingOffCommandResponse*>(
               &_TrackingOffCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(TrackingOffCommandResponse& a, TrackingOffCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackingOffCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingOffCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackingOffCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackingOffCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackingOffCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackingOffCommandResponse& from) {
    TrackingOffCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackingOffCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TrackingOffCommandResponse";
  }
  protected:
  explicit TrackingOffCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // int32 dummy = 1;
  void clear_dummy();
  int32_t dummy() const;
  void set_dummy(int32_t value);
  private:
  int32_t _internal_dummy() const;
  void _internal_set_dummy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TrackingOffCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t dummy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingPointCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest) */ {
 public:
  inline RespondTrackingPointCommandRequest() : RespondTrackingPointCommandRequest(nullptr) {}
  ~RespondTrackingPointCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingPointCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingPointCommandRequest(const RespondTrackingPointCommandRequest& from);
  RespondTrackingPointCommandRequest(RespondTrackingPointCommandRequest&& from) noexcept
    : RespondTrackingPointCommandRequest() {
    *this = ::std::move(from);
  }

  inline RespondTrackingPointCommandRequest& operator=(const RespondTrackingPointCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingPointCommandRequest& operator=(RespondTrackingPointCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingPointCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingPointCommandRequest* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingPointCommandRequest*>(
               &_RespondTrackingPointCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(RespondTrackingPointCommandRequest& a, RespondTrackingPointCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingPointCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingPointCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingPointCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingPointCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingPointCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingPointCommandRequest& from) {
    RespondTrackingPointCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingPointCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest";
  }
  protected:
  explicit RespondTrackingPointCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopVideoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
  void clear_stop_video_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback stop_video_feedback() const;
  void set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_stop_video_feedback() const;
  void _internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stop_video_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingPointCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse) */ {
 public:
  inline RespondTrackingPointCommandResponse() : RespondTrackingPointCommandResponse(nullptr) {}
  ~RespondTrackingPointCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingPointCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingPointCommandResponse(const RespondTrackingPointCommandResponse& from);
  RespondTrackingPointCommandResponse(RespondTrackingPointCommandResponse&& from) noexcept
    : RespondTrackingPointCommandResponse() {
    *this = ::std::move(from);
  }

  inline RespondTrackingPointCommandResponse& operator=(const RespondTrackingPointCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingPointCommandResponse& operator=(RespondTrackingPointCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingPointCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingPointCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingPointCommandResponse*>(
               &_RespondTrackingPointCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(RespondTrackingPointCommandResponse& a, RespondTrackingPointCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingPointCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingPointCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingPointCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingPointCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingPointCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingPointCommandResponse& from) {
    RespondTrackingPointCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingPointCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse";
  }
  protected:
  explicit RespondTrackingPointCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingRectangleCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest) */ {
 public:
  inline RespondTrackingRectangleCommandRequest() : RespondTrackingRectangleCommandRequest(nullptr) {}
  ~RespondTrackingRectangleCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingRectangleCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingRectangleCommandRequest(const RespondTrackingRectangleCommandRequest& from);
  RespondTrackingRectangleCommandRequest(RespondTrackingRectangleCommandRequest&& from) noexcept
    : RespondTrackingRectangleCommandRequest() {
    *this = ::std::move(from);
  }

  inline RespondTrackingRectangleCommandRequest& operator=(const RespondTrackingRectangleCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingRectangleCommandRequest& operator=(RespondTrackingRectangleCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingRectangleCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingRectangleCommandRequest* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingRectangleCommandRequest*>(
               &_RespondTrackingRectangleCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(RespondTrackingRectangleCommandRequest& a, RespondTrackingRectangleCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingRectangleCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingRectangleCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingRectangleCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingRectangleCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingRectangleCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingRectangleCommandRequest& from) {
    RespondTrackingRectangleCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingRectangleCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest";
  }
  protected:
  explicit RespondTrackingRectangleCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopVideoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
  void clear_stop_video_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback stop_video_feedback() const;
  void set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_stop_video_feedback() const;
  void _internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stop_video_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingRectangleCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse) */ {
 public:
  inline RespondTrackingRectangleCommandResponse() : RespondTrackingRectangleCommandResponse(nullptr) {}
  ~RespondTrackingRectangleCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingRectangleCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingRectangleCommandResponse(const RespondTrackingRectangleCommandResponse& from);
  RespondTrackingRectangleCommandResponse(RespondTrackingRectangleCommandResponse&& from) noexcept
    : RespondTrackingRectangleCommandResponse() {
    *this = ::std::move(from);
  }

  inline RespondTrackingRectangleCommandResponse& operator=(const RespondTrackingRectangleCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingRectangleCommandResponse& operator=(RespondTrackingRectangleCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingRectangleCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingRectangleCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingRectangleCommandResponse*>(
               &_RespondTrackingRectangleCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(RespondTrackingRectangleCommandResponse& a, RespondTrackingRectangleCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingRectangleCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingRectangleCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingRectangleCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingRectangleCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingRectangleCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingRectangleCommandResponse& from) {
    RespondTrackingRectangleCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingRectangleCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse";
  }
  protected:
  explicit RespondTrackingRectangleCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingOffCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest) */ {
 public:
  inline RespondTrackingOffCommandRequest() : RespondTrackingOffCommandRequest(nullptr) {}
  ~RespondTrackingOffCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingOffCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingOffCommandRequest(const RespondTrackingOffCommandRequest& from);
  RespondTrackingOffCommandRequest(RespondTrackingOffCommandRequest&& from) noexcept
    : RespondTrackingOffCommandRequest() {
    *this = ::std::move(from);
  }

  inline RespondTrackingOffCommandRequest& operator=(const RespondTrackingOffCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingOffCommandRequest& operator=(RespondTrackingOffCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingOffCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingOffCommandRequest* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingOffCommandRequest*>(
               &_RespondTrackingOffCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(RespondTrackingOffCommandRequest& a, RespondTrackingOffCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingOffCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingOffCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingOffCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingOffCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingOffCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingOffCommandRequest& from) {
    RespondTrackingOffCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingOffCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest";
  }
  protected:
  explicit RespondTrackingOffCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopVideoFeedbackFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
  void clear_stop_video_feedback();
  ::mavsdk::rpc::camera_server::CameraFeedback stop_video_feedback() const;
  void set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  private:
  ::mavsdk::rpc::camera_server::CameraFeedback _internal_stop_video_feedback() const;
  void _internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stop_video_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RespondTrackingOffCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse) */ {
 public:
  inline RespondTrackingOffCommandResponse() : RespondTrackingOffCommandResponse(nullptr) {}
  ~RespondTrackingOffCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR RespondTrackingOffCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespondTrackingOffCommandResponse(const RespondTrackingOffCommandResponse& from);
  RespondTrackingOffCommandResponse(RespondTrackingOffCommandResponse&& from) noexcept
    : RespondTrackingOffCommandResponse() {
    *this = ::std::move(from);
  }

  inline RespondTrackingOffCommandResponse& operator=(const RespondTrackingOffCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespondTrackingOffCommandResponse& operator=(RespondTrackingOffCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespondTrackingOffCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespondTrackingOffCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RespondTrackingOffCommandResponse*>(
               &_RespondTrackingOffCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(RespondTrackingOffCommandResponse& a, RespondTrackingOffCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RespondTrackingOffCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespondTrackingOffCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespondTrackingOffCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespondTrackingOffCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespondTrackingOffCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespondTrackingOffCommandResponse& from) {
    RespondTrackingOffCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespondTrackingOffCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse";
  }
  protected:
  explicit RespondTrackingOffCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServerResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
  bool has_camera_server_result() const;
  private:
  bool _internal_has_camera_server_result() const;
  public:
  void clear_camera_server_result();
  const ::mavsdk::rpc::camera_server::CameraServerResult& camera_server_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera_server::CameraServerResult* release_camera_server_result();
  ::mavsdk::rpc::camera_server::CameraServerResult* mutable_camera_server_result();
  void set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  private:
  const ::mavsdk::rpc::camera_server::CameraServerResult& _internal_camera_server_result() const;
  ::mavsdk::rpc::camera_server::CameraServerResult* _internal_mutable_camera_server_result();
  public:
  void unsafe_arena_set_allocated_camera_server_result(
      ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result);
  ::mavsdk::rpc::camera_server::CameraServerResult* unsafe_arena_release_camera_server_result();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TrackPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TrackPoint) */ {
 public:
  inline TrackPoint() : TrackPoint(nullptr) {}
  ~TrackPoint() override;
  explicit PROTOBUF_CONSTEXPR TrackPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPoint(const TrackPoint& from);
  TrackPoint(TrackPoint&& from) noexcept
    : TrackPoint() {
    *this = ::std::move(from);
  }

  inline TrackPoint& operator=(const TrackPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPoint& operator=(TrackPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPoint* internal_default_instance() {
    return reinterpret_cast<const TrackPoint*>(
               &_TrackPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(TrackPoint& a, TrackPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPoint& from) {
    TrackPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TrackPoint";
  }
  protected:
  explicit TrackPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointXFieldNumber = 1,
    kPointYFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // float point_x = 1;
  void clear_point_x();
  float point_x() const;
  void set_point_x(float value);
  private:
  float _internal_point_x() const;
  void _internal_set_point_x(float value);
  public:

  // float point_y = 2;
  void clear_point_y();
  float point_y() const;
  void set_point_y(float value);
  private:
  float _internal_point_y() const;
  void _internal_set_point_y(float value);
  public:

  // float radius = 3;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TrackPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float point_x_;
    float point_y_;
    float radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// -------------------------------------------------------------------

class TrackRectangle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera_server.TrackRectangle) */ {
 public:
  inline TrackRectangle() : TrackRectangle(nullptr) {}
  ~TrackRectangle() override;
  explicit PROTOBUF_CONSTEXPR TrackRectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackRectangle(const TrackRectangle& from);
  TrackRectangle(TrackRectangle&& from) noexcept
    : TrackRectangle() {
    *this = ::std::move(from);
  }

  inline TrackRectangle& operator=(const TrackRectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackRectangle& operator=(TrackRectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackRectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackRectangle* internal_default_instance() {
    return reinterpret_cast<const TrackRectangle*>(
               &_TrackRectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(TrackRectangle& a, TrackRectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackRectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackRectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackRectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackRectangle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackRectangle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackRectangle& from) {
    TrackRectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackRectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.camera_server.TrackRectangle";
  }
  protected:
  explicit TrackRectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopLeftCornerXFieldNumber = 1,
    kTopLeftCornerYFieldNumber = 2,
    kBottomRightCornerXFieldNumber = 3,
    kBottomRightCornerYFieldNumber = 4,
  };
  // float top_left_corner_x = 1;
  void clear_top_left_corner_x();
  float top_left_corner_x() const;
  void set_top_left_corner_x(float value);
  private:
  float _internal_top_left_corner_x() const;
  void _internal_set_top_left_corner_x(float value);
  public:

  // float top_left_corner_y = 2;
  void clear_top_left_corner_y();
  float top_left_corner_y() const;
  void set_top_left_corner_y(float value);
  private:
  float _internal_top_left_corner_y() const;
  void _internal_set_top_left_corner_y(float value);
  public:

  // float bottom_right_corner_x = 3;
  void clear_bottom_right_corner_x();
  float bottom_right_corner_x() const;
  void set_bottom_right_corner_x(float value);
  private:
  float _internal_bottom_right_corner_x() const;
  void _internal_set_bottom_right_corner_x(float value);
  public:

  // float bottom_right_corner_y = 4;
  void clear_bottom_right_corner_y();
  float bottom_right_corner_y() const;
  void set_bottom_right_corner_y(float value);
  private:
  float _internal_bottom_right_corner_y() const;
  void _internal_set_bottom_right_corner_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera_server.TrackRectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float top_left_corner_x_;
    float top_left_corner_y_;
    float bottom_right_corner_x_;
    float bottom_right_corner_y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_5fserver_2fcamera_5fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetInformationRequest

// .mavsdk.rpc.camera_server.Information information = 1;
inline bool SetInformationRequest::_internal_has_information() const {
  return this != internal_default_instance() && _impl_.information_ != nullptr;
}
inline bool SetInformationRequest::has_information() const {
  return _internal_has_information();
}
inline void SetInformationRequest::clear_information() {
  if (GetArenaForAllocation() == nullptr && _impl_.information_ != nullptr) {
    delete _impl_.information_;
  }
  _impl_.information_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::Information& SetInformationRequest::_internal_information() const {
  const ::mavsdk::rpc::camera_server::Information* p = _impl_.information_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::Information&>(
      ::mavsdk::rpc::camera_server::_Information_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::Information& SetInformationRequest::information() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetInformationRequest.information)
  return _internal_information();
}
inline void SetInformationRequest::unsafe_arena_set_allocated_information(
    ::mavsdk::rpc::camera_server::Information* information) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.information_);
  }
  _impl_.information_ = information;
  if (information) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetInformationRequest.information)
}
inline ::mavsdk::rpc::camera_server::Information* SetInformationRequest::release_information() {
  
  ::mavsdk::rpc::camera_server::Information* temp = _impl_.information_;
  _impl_.information_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::Information* SetInformationRequest::unsafe_arena_release_information() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetInformationRequest.information)
  
  ::mavsdk::rpc::camera_server::Information* temp = _impl_.information_;
  _impl_.information_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::Information* SetInformationRequest::_internal_mutable_information() {
  
  if (_impl_.information_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::Information>(GetArenaForAllocation());
    _impl_.information_ = p;
  }
  return _impl_.information_;
}
inline ::mavsdk::rpc::camera_server::Information* SetInformationRequest::mutable_information() {
  ::mavsdk::rpc::camera_server::Information* _msg = _internal_mutable_information();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetInformationRequest.information)
  return _msg;
}
inline void SetInformationRequest::set_allocated_information(::mavsdk::rpc::camera_server::Information* information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.information_;
  }
  if (information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(information);
    if (message_arena != submessage_arena) {
      information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, information, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.information_ = information;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetInformationRequest.information)
}

// -------------------------------------------------------------------

// SetInformationResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool SetInformationResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool SetInformationResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void SetInformationResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetInformationResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetInformationResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetInformationResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void SetInformationResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetInformationResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInformationResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInformationResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetInformationResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInformationResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInformationResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetInformationResponse.camera_server_result)
  return _msg;
}
inline void SetInformationResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetInformationResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SetVideoStreamingRequest

// .mavsdk.rpc.camera_server.VideoStreaming video_streaming = 1;
inline bool SetVideoStreamingRequest::_internal_has_video_streaming() const {
  return this != internal_default_instance() && _impl_.video_streaming_ != nullptr;
}
inline bool SetVideoStreamingRequest::has_video_streaming() const {
  return _internal_has_video_streaming();
}
inline void SetVideoStreamingRequest::clear_video_streaming() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_streaming_ != nullptr) {
    delete _impl_.video_streaming_;
  }
  _impl_.video_streaming_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::VideoStreaming& SetVideoStreamingRequest::_internal_video_streaming() const {
  const ::mavsdk::rpc::camera_server::VideoStreaming* p = _impl_.video_streaming_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::VideoStreaming&>(
      ::mavsdk::rpc::camera_server::_VideoStreaming_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::VideoStreaming& SetVideoStreamingRequest::video_streaming() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetVideoStreamingRequest.video_streaming)
  return _internal_video_streaming();
}
inline void SetVideoStreamingRequest::unsafe_arena_set_allocated_video_streaming(
    ::mavsdk::rpc::camera_server::VideoStreaming* video_streaming) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_streaming_);
  }
  _impl_.video_streaming_ = video_streaming;
  if (video_streaming) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetVideoStreamingRequest.video_streaming)
}
inline ::mavsdk::rpc::camera_server::VideoStreaming* SetVideoStreamingRequest::release_video_streaming() {
  
  ::mavsdk::rpc::camera_server::VideoStreaming* temp = _impl_.video_streaming_;
  _impl_.video_streaming_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::VideoStreaming* SetVideoStreamingRequest::unsafe_arena_release_video_streaming() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetVideoStreamingRequest.video_streaming)
  
  ::mavsdk::rpc::camera_server::VideoStreaming* temp = _impl_.video_streaming_;
  _impl_.video_streaming_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::VideoStreaming* SetVideoStreamingRequest::_internal_mutable_video_streaming() {
  
  if (_impl_.video_streaming_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::VideoStreaming>(GetArenaForAllocation());
    _impl_.video_streaming_ = p;
  }
  return _impl_.video_streaming_;
}
inline ::mavsdk::rpc::camera_server::VideoStreaming* SetVideoStreamingRequest::mutable_video_streaming() {
  ::mavsdk::rpc::camera_server::VideoStreaming* _msg = _internal_mutable_video_streaming();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetVideoStreamingRequest.video_streaming)
  return _msg;
}
inline void SetVideoStreamingRequest::set_allocated_video_streaming(::mavsdk::rpc::camera_server::VideoStreaming* video_streaming) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_streaming_;
  }
  if (video_streaming) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_streaming);
    if (message_arena != submessage_arena) {
      video_streaming = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_streaming, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_streaming_ = video_streaming;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetVideoStreamingRequest.video_streaming)
}

// -------------------------------------------------------------------

// SetVideoStreamingResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool SetVideoStreamingResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool SetVideoStreamingResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void SetVideoStreamingResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetVideoStreamingResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetVideoStreamingResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetVideoStreamingResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void SetVideoStreamingResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetVideoStreamingResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetVideoStreamingResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetVideoStreamingResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetVideoStreamingResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetVideoStreamingResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetVideoStreamingResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetVideoStreamingResponse.camera_server_result)
  return _msg;
}
inline void SetVideoStreamingResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetVideoStreamingResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SetInProgressRequest

// bool in_progress = 1;
inline void SetInProgressRequest::clear_in_progress() {
  _impl_.in_progress_ = false;
}
inline bool SetInProgressRequest::_internal_in_progress() const {
  return _impl_.in_progress_;
}
inline bool SetInProgressRequest::in_progress() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetInProgressRequest.in_progress)
  return _internal_in_progress();
}
inline void SetInProgressRequest::_internal_set_in_progress(bool value) {
  
  _impl_.in_progress_ = value;
}
inline void SetInProgressRequest::set_in_progress(bool value) {
  _internal_set_in_progress(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.SetInProgressRequest.in_progress)
}

// -------------------------------------------------------------------

// SetInProgressResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool SetInProgressResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool SetInProgressResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void SetInProgressResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetInProgressResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& SetInProgressResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetInProgressResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void SetInProgressResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetInProgressResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInProgressResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInProgressResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetInProgressResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInProgressResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* SetInProgressResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetInProgressResponse.camera_server_result)
  return _msg;
}
inline void SetInProgressResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetInProgressResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeTakePhotoRequest

// -------------------------------------------------------------------

// TakePhotoResponse

// int32 index = 1;
inline void TakePhotoResponse::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t TakePhotoResponse::_internal_index() const {
  return _impl_.index_;
}
inline int32_t TakePhotoResponse::index() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TakePhotoResponse.index)
  return _internal_index();
}
inline void TakePhotoResponse::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void TakePhotoResponse::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TakePhotoResponse.index)
}

// -------------------------------------------------------------------

// RespondTakePhotoRequest

// .mavsdk.rpc.camera_server.CameraFeedback take_photo_feedback = 1;
inline void RespondTakePhotoRequest::clear_take_photo_feedback() {
  _impl_.take_photo_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTakePhotoRequest::_internal_take_photo_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.take_photo_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTakePhotoRequest::take_photo_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTakePhotoRequest.take_photo_feedback)
  return _internal_take_photo_feedback();
}
inline void RespondTakePhotoRequest::_internal_set_take_photo_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.take_photo_feedback_ = value;
}
inline void RespondTakePhotoRequest::set_take_photo_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_take_photo_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondTakePhotoRequest.take_photo_feedback)
}

// .mavsdk.rpc.camera_server.CaptureInfo capture_info = 2;
inline bool RespondTakePhotoRequest::_internal_has_capture_info() const {
  return this != internal_default_instance() && _impl_.capture_info_ != nullptr;
}
inline bool RespondTakePhotoRequest::has_capture_info() const {
  return _internal_has_capture_info();
}
inline void RespondTakePhotoRequest::clear_capture_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.capture_info_ != nullptr) {
    delete _impl_.capture_info_;
  }
  _impl_.capture_info_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CaptureInfo& RespondTakePhotoRequest::_internal_capture_info() const {
  const ::mavsdk::rpc::camera_server::CaptureInfo* p = _impl_.capture_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CaptureInfo&>(
      ::mavsdk::rpc::camera_server::_CaptureInfo_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CaptureInfo& RespondTakePhotoRequest::capture_info() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTakePhotoRequest.capture_info)
  return _internal_capture_info();
}
inline void RespondTakePhotoRequest::unsafe_arena_set_allocated_capture_info(
    ::mavsdk::rpc::camera_server::CaptureInfo* capture_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capture_info_);
  }
  _impl_.capture_info_ = capture_info;
  if (capture_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondTakePhotoRequest.capture_info)
}
inline ::mavsdk::rpc::camera_server::CaptureInfo* RespondTakePhotoRequest::release_capture_info() {
  
  ::mavsdk::rpc::camera_server::CaptureInfo* temp = _impl_.capture_info_;
  _impl_.capture_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CaptureInfo* RespondTakePhotoRequest::unsafe_arena_release_capture_info() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondTakePhotoRequest.capture_info)
  
  ::mavsdk::rpc::camera_server::CaptureInfo* temp = _impl_.capture_info_;
  _impl_.capture_info_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CaptureInfo* RespondTakePhotoRequest::_internal_mutable_capture_info() {
  
  if (_impl_.capture_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CaptureInfo>(GetArenaForAllocation());
    _impl_.capture_info_ = p;
  }
  return _impl_.capture_info_;
}
inline ::mavsdk::rpc::camera_server::CaptureInfo* RespondTakePhotoRequest::mutable_capture_info() {
  ::mavsdk::rpc::camera_server::CaptureInfo* _msg = _internal_mutable_capture_info();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondTakePhotoRequest.capture_info)
  return _msg;
}
inline void RespondTakePhotoRequest::set_allocated_capture_info(::mavsdk::rpc::camera_server::CaptureInfo* capture_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capture_info_;
  }
  if (capture_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capture_info);
    if (message_arena != submessage_arena) {
      capture_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capture_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capture_info_ = capture_info;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondTakePhotoRequest.capture_info)
}

// -------------------------------------------------------------------

// RespondTakePhotoResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondTakePhotoResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondTakePhotoResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondTakePhotoResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTakePhotoResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTakePhotoResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTakePhotoResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondTakePhotoResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondTakePhotoResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTakePhotoResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTakePhotoResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondTakePhotoResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTakePhotoResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTakePhotoResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondTakePhotoResponse.camera_server_result)
  return _msg;
}
inline void RespondTakePhotoResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondTakePhotoResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeStartVideoRequest

// -------------------------------------------------------------------

// StartVideoResponse

// int32 stream_id = 1;
inline void StartVideoResponse::clear_stream_id() {
  _impl_.stream_id_ = 0;
}
inline int32_t StartVideoResponse::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline int32_t StartVideoResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StartVideoResponse.stream_id)
  return _internal_stream_id();
}
inline void StartVideoResponse::_internal_set_stream_id(int32_t value) {
  
  _impl_.stream_id_ = value;
}
inline void StartVideoResponse::set_stream_id(int32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StartVideoResponse.stream_id)
}

// -------------------------------------------------------------------

// RespondStartVideoRequest

// .mavsdk.rpc.camera_server.CameraFeedback start_video_feedback = 1;
inline void RespondStartVideoRequest::clear_start_video_feedback() {
  _impl_.start_video_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStartVideoRequest::_internal_start_video_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.start_video_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStartVideoRequest::start_video_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStartVideoRequest.start_video_feedback)
  return _internal_start_video_feedback();
}
inline void RespondStartVideoRequest::_internal_set_start_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.start_video_feedback_ = value;
}
inline void RespondStartVideoRequest::set_start_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_start_video_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondStartVideoRequest.start_video_feedback)
}

// -------------------------------------------------------------------

// RespondStartVideoResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondStartVideoResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondStartVideoResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondStartVideoResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStartVideoResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStartVideoResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStartVideoResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondStartVideoResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStartVideoResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStartVideoResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStartVideoResponse.camera_server_result)
  return _msg;
}
inline void RespondStartVideoResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStartVideoResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeStopVideoRequest

// -------------------------------------------------------------------

// StopVideoResponse

// int32 stream_id = 1;
inline void StopVideoResponse::clear_stream_id() {
  _impl_.stream_id_ = 0;
}
inline int32_t StopVideoResponse::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline int32_t StopVideoResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StopVideoResponse.stream_id)
  return _internal_stream_id();
}
inline void StopVideoResponse::_internal_set_stream_id(int32_t value) {
  
  _impl_.stream_id_ = value;
}
inline void StopVideoResponse::set_stream_id(int32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StopVideoResponse.stream_id)
}

// -------------------------------------------------------------------

// RespondStopVideoRequest

// .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
inline void RespondStopVideoRequest::clear_stop_video_feedback() {
  _impl_.stop_video_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStopVideoRequest::_internal_stop_video_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.stop_video_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStopVideoRequest::stop_video_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStopVideoRequest.stop_video_feedback)
  return _internal_stop_video_feedback();
}
inline void RespondStopVideoRequest::_internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.stop_video_feedback_ = value;
}
inline void RespondStopVideoRequest::set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_stop_video_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondStopVideoRequest.stop_video_feedback)
}

// -------------------------------------------------------------------

// RespondStopVideoResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondStopVideoResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondStopVideoResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondStopVideoResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStopVideoResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStopVideoResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStopVideoResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondStopVideoResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStopVideoResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStopVideoResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStopVideoResponse.camera_server_result)
  return _msg;
}
inline void RespondStopVideoResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStopVideoResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeStartVideoStreamingRequest

// -------------------------------------------------------------------

// StartVideoStreamingResponse

// int32 stream_id = 1;
inline void StartVideoStreamingResponse::clear_stream_id() {
  _impl_.stream_id_ = 0;
}
inline int32_t StartVideoStreamingResponse::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline int32_t StartVideoStreamingResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StartVideoStreamingResponse.stream_id)
  return _internal_stream_id();
}
inline void StartVideoStreamingResponse::_internal_set_stream_id(int32_t value) {
  
  _impl_.stream_id_ = value;
}
inline void StartVideoStreamingResponse::set_stream_id(int32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StartVideoStreamingResponse.stream_id)
}

// -------------------------------------------------------------------

// RespondStartVideoStreamingRequest

// .mavsdk.rpc.camera_server.CameraFeedback start_video_streaming_feedback = 1;
inline void RespondStartVideoStreamingRequest::clear_start_video_streaming_feedback() {
  _impl_.start_video_streaming_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStartVideoStreamingRequest::_internal_start_video_streaming_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.start_video_streaming_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStartVideoStreamingRequest::start_video_streaming_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest.start_video_streaming_feedback)
  return _internal_start_video_streaming_feedback();
}
inline void RespondStartVideoStreamingRequest::_internal_set_start_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.start_video_streaming_feedback_ = value;
}
inline void RespondStartVideoStreamingRequest::set_start_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_start_video_streaming_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest.start_video_streaming_feedback)
}

// -------------------------------------------------------------------

// RespondStartVideoStreamingResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondStartVideoStreamingResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondStartVideoStreamingResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondStartVideoStreamingResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStartVideoStreamingResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStartVideoStreamingResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondStartVideoStreamingResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoStreamingResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoStreamingResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoStreamingResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStartVideoStreamingResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse.camera_server_result)
  return _msg;
}
inline void RespondStartVideoStreamingResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeStopVideoStreamingRequest

// -------------------------------------------------------------------

// StopVideoStreamingResponse

// int32 stream_id = 1;
inline void StopVideoStreamingResponse::clear_stream_id() {
  _impl_.stream_id_ = 0;
}
inline int32_t StopVideoStreamingResponse::_internal_stream_id() const {
  return _impl_.stream_id_;
}
inline int32_t StopVideoStreamingResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StopVideoStreamingResponse.stream_id)
  return _internal_stream_id();
}
inline void StopVideoStreamingResponse::_internal_set_stream_id(int32_t value) {
  
  _impl_.stream_id_ = value;
}
inline void StopVideoStreamingResponse::set_stream_id(int32_t value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StopVideoStreamingResponse.stream_id)
}

// -------------------------------------------------------------------

// RespondStopVideoStreamingRequest

// .mavsdk.rpc.camera_server.CameraFeedback stop_video_streaming_feedback = 1;
inline void RespondStopVideoStreamingRequest::clear_stop_video_streaming_feedback() {
  _impl_.stop_video_streaming_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStopVideoStreamingRequest::_internal_stop_video_streaming_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.stop_video_streaming_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStopVideoStreamingRequest::stop_video_streaming_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest.stop_video_streaming_feedback)
  return _internal_stop_video_streaming_feedback();
}
inline void RespondStopVideoStreamingRequest::_internal_set_stop_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.stop_video_streaming_feedback_ = value;
}
inline void RespondStopVideoStreamingRequest::set_stop_video_streaming_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_stop_video_streaming_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest.stop_video_streaming_feedback)
}

// -------------------------------------------------------------------

// RespondStopVideoStreamingResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondStopVideoStreamingResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondStopVideoStreamingResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondStopVideoStreamingResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStopVideoStreamingResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStopVideoStreamingResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondStopVideoStreamingResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoStreamingResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoStreamingResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoStreamingResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStopVideoStreamingResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse.camera_server_result)
  return _msg;
}
inline void RespondStopVideoStreamingResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeSetModeRequest

// -------------------------------------------------------------------

// SetModeResponse

// .mavsdk.rpc.camera_server.Mode mode = 1;
inline void SetModeResponse::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::mavsdk::rpc::camera_server::Mode SetModeResponse::_internal_mode() const {
  return static_cast< ::mavsdk::rpc::camera_server::Mode >(_impl_.mode_);
}
inline ::mavsdk::rpc::camera_server::Mode SetModeResponse::mode() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetModeResponse.mode)
  return _internal_mode();
}
inline void SetModeResponse::_internal_set_mode(::mavsdk::rpc::camera_server::Mode value) {
  
  _impl_.mode_ = value;
}
inline void SetModeResponse::set_mode(::mavsdk::rpc::camera_server::Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.SetModeResponse.mode)
}

// -------------------------------------------------------------------

// RespondSetModeRequest

// .mavsdk.rpc.camera_server.CameraFeedback set_mode_feedback = 1;
inline void RespondSetModeRequest::clear_set_mode_feedback() {
  _impl_.set_mode_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondSetModeRequest::_internal_set_mode_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.set_mode_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondSetModeRequest::set_mode_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondSetModeRequest.set_mode_feedback)
  return _internal_set_mode_feedback();
}
inline void RespondSetModeRequest::_internal_set_set_mode_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.set_mode_feedback_ = value;
}
inline void RespondSetModeRequest::set_set_mode_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_set_mode_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondSetModeRequest.set_mode_feedback)
}

// -------------------------------------------------------------------

// RespondSetModeResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondSetModeResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondSetModeResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondSetModeResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondSetModeResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondSetModeResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondSetModeResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondSetModeResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondSetModeResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondSetModeResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondSetModeResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondSetModeResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondSetModeResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondSetModeResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondSetModeResponse.camera_server_result)
  return _msg;
}
inline void RespondSetModeResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondSetModeResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeStorageInformationRequest

// -------------------------------------------------------------------

// StorageInformationResponse

// int32 storage_id = 1;
inline void StorageInformationResponse::clear_storage_id() {
  _impl_.storage_id_ = 0;
}
inline int32_t StorageInformationResponse::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline int32_t StorageInformationResponse::storage_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformationResponse.storage_id)
  return _internal_storage_id();
}
inline void StorageInformationResponse::_internal_set_storage_id(int32_t value) {
  
  _impl_.storage_id_ = value;
}
inline void StorageInformationResponse::set_storage_id(int32_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformationResponse.storage_id)
}

// -------------------------------------------------------------------

// RespondStorageInformationRequest

// .mavsdk.rpc.camera_server.CameraFeedback storage_information_feedback = 1;
inline void RespondStorageInformationRequest::clear_storage_information_feedback() {
  _impl_.storage_information_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStorageInformationRequest::_internal_storage_information_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.storage_information_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondStorageInformationRequest::storage_information_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information_feedback)
  return _internal_storage_information_feedback();
}
inline void RespondStorageInformationRequest::_internal_set_storage_information_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.storage_information_feedback_ = value;
}
inline void RespondStorageInformationRequest::set_storage_information_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_storage_information_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information_feedback)
}

// .mavsdk.rpc.camera_server.StorageInformation storage_information = 2;
inline bool RespondStorageInformationRequest::_internal_has_storage_information() const {
  return this != internal_default_instance() && _impl_.storage_information_ != nullptr;
}
inline bool RespondStorageInformationRequest::has_storage_information() const {
  return _internal_has_storage_information();
}
inline void RespondStorageInformationRequest::clear_storage_information() {
  if (GetArenaForAllocation() == nullptr && _impl_.storage_information_ != nullptr) {
    delete _impl_.storage_information_;
  }
  _impl_.storage_information_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::StorageInformation& RespondStorageInformationRequest::_internal_storage_information() const {
  const ::mavsdk::rpc::camera_server::StorageInformation* p = _impl_.storage_information_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::StorageInformation&>(
      ::mavsdk::rpc::camera_server::_StorageInformation_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::StorageInformation& RespondStorageInformationRequest::storage_information() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information)
  return _internal_storage_information();
}
inline void RespondStorageInformationRequest::unsafe_arena_set_allocated_storage_information(
    ::mavsdk::rpc::camera_server::StorageInformation* storage_information) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_information_);
  }
  _impl_.storage_information_ = storage_information;
  if (storage_information) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information)
}
inline ::mavsdk::rpc::camera_server::StorageInformation* RespondStorageInformationRequest::release_storage_information() {
  
  ::mavsdk::rpc::camera_server::StorageInformation* temp = _impl_.storage_information_;
  _impl_.storage_information_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::StorageInformation* RespondStorageInformationRequest::unsafe_arena_release_storage_information() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information)
  
  ::mavsdk::rpc::camera_server::StorageInformation* temp = _impl_.storage_information_;
  _impl_.storage_information_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::StorageInformation* RespondStorageInformationRequest::_internal_mutable_storage_information() {
  
  if (_impl_.storage_information_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::StorageInformation>(GetArenaForAllocation());
    _impl_.storage_information_ = p;
  }
  return _impl_.storage_information_;
}
inline ::mavsdk::rpc::camera_server::StorageInformation* RespondStorageInformationRequest::mutable_storage_information() {
  ::mavsdk::rpc::camera_server::StorageInformation* _msg = _internal_mutable_storage_information();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information)
  return _msg;
}
inline void RespondStorageInformationRequest::set_allocated_storage_information(::mavsdk::rpc::camera_server::StorageInformation* storage_information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.storage_information_;
  }
  if (storage_information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(storage_information);
    if (message_arena != submessage_arena) {
      storage_information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_information, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.storage_information_ = storage_information;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStorageInformationRequest.storage_information)
}

// -------------------------------------------------------------------

// RespondStorageInformationResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondStorageInformationResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondStorageInformationResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondStorageInformationResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStorageInformationResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondStorageInformationResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondStorageInformationResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondStorageInformationResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondStorageInformationResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStorageInformationResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStorageInformationResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondStorageInformationResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStorageInformationResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondStorageInformationResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondStorageInformationResponse.camera_server_result)
  return _msg;
}
inline void RespondStorageInformationResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondStorageInformationResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeCaptureStatusRequest

// -------------------------------------------------------------------

// CaptureStatusResponse

// int32 reserved = 1;
inline void CaptureStatusResponse::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t CaptureStatusResponse::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t CaptureStatusResponse::reserved() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatusResponse.reserved)
  return _internal_reserved();
}
inline void CaptureStatusResponse::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void CaptureStatusResponse::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatusResponse.reserved)
}

// -------------------------------------------------------------------

// RespondCaptureStatusRequest

// .mavsdk.rpc.camera_server.CameraFeedback capture_status_feedback = 1;
inline void RespondCaptureStatusRequest::clear_capture_status_feedback() {
  _impl_.capture_status_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondCaptureStatusRequest::_internal_capture_status_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.capture_status_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondCaptureStatusRequest::capture_status_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status_feedback)
  return _internal_capture_status_feedback();
}
inline void RespondCaptureStatusRequest::_internal_set_capture_status_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.capture_status_feedback_ = value;
}
inline void RespondCaptureStatusRequest::set_capture_status_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_capture_status_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status_feedback)
}

// .mavsdk.rpc.camera_server.CaptureStatus capture_status = 2;
inline bool RespondCaptureStatusRequest::_internal_has_capture_status() const {
  return this != internal_default_instance() && _impl_.capture_status_ != nullptr;
}
inline bool RespondCaptureStatusRequest::has_capture_status() const {
  return _internal_has_capture_status();
}
inline void RespondCaptureStatusRequest::clear_capture_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.capture_status_ != nullptr) {
    delete _impl_.capture_status_;
  }
  _impl_.capture_status_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CaptureStatus& RespondCaptureStatusRequest::_internal_capture_status() const {
  const ::mavsdk::rpc::camera_server::CaptureStatus* p = _impl_.capture_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CaptureStatus&>(
      ::mavsdk::rpc::camera_server::_CaptureStatus_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CaptureStatus& RespondCaptureStatusRequest::capture_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status)
  return _internal_capture_status();
}
inline void RespondCaptureStatusRequest::unsafe_arena_set_allocated_capture_status(
    ::mavsdk::rpc::camera_server::CaptureStatus* capture_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capture_status_);
  }
  _impl_.capture_status_ = capture_status;
  if (capture_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status)
}
inline ::mavsdk::rpc::camera_server::CaptureStatus* RespondCaptureStatusRequest::release_capture_status() {
  
  ::mavsdk::rpc::camera_server::CaptureStatus* temp = _impl_.capture_status_;
  _impl_.capture_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CaptureStatus* RespondCaptureStatusRequest::unsafe_arena_release_capture_status() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status)
  
  ::mavsdk::rpc::camera_server::CaptureStatus* temp = _impl_.capture_status_;
  _impl_.capture_status_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CaptureStatus* RespondCaptureStatusRequest::_internal_mutable_capture_status() {
  
  if (_impl_.capture_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CaptureStatus>(GetArenaForAllocation());
    _impl_.capture_status_ = p;
  }
  return _impl_.capture_status_;
}
inline ::mavsdk::rpc::camera_server::CaptureStatus* RespondCaptureStatusRequest::mutable_capture_status() {
  ::mavsdk::rpc::camera_server::CaptureStatus* _msg = _internal_mutable_capture_status();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status)
  return _msg;
}
inline void RespondCaptureStatusRequest::set_allocated_capture_status(::mavsdk::rpc::camera_server::CaptureStatus* capture_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capture_status_;
  }
  if (capture_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capture_status);
    if (message_arena != submessage_arena) {
      capture_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capture_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capture_status_ = capture_status;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondCaptureStatusRequest.capture_status)
}

// -------------------------------------------------------------------

// RespondCaptureStatusResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondCaptureStatusResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondCaptureStatusResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondCaptureStatusResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondCaptureStatusResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondCaptureStatusResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondCaptureStatusResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondCaptureStatusResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondCaptureStatusResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondCaptureStatusResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondCaptureStatusResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondCaptureStatusResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondCaptureStatusResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondCaptureStatusResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondCaptureStatusResponse.camera_server_result)
  return _msg;
}
inline void RespondCaptureStatusResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondCaptureStatusResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeFormatStorageRequest

// -------------------------------------------------------------------

// FormatStorageResponse

// int32 storage_id = 1;
inline void FormatStorageResponse::clear_storage_id() {
  _impl_.storage_id_ = 0;
}
inline int32_t FormatStorageResponse::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline int32_t FormatStorageResponse::storage_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.FormatStorageResponse.storage_id)
  return _internal_storage_id();
}
inline void FormatStorageResponse::_internal_set_storage_id(int32_t value) {
  
  _impl_.storage_id_ = value;
}
inline void FormatStorageResponse::set_storage_id(int32_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.FormatStorageResponse.storage_id)
}

// -------------------------------------------------------------------

// RespondFormatStorageRequest

// .mavsdk.rpc.camera_server.CameraFeedback format_storage_feedback = 1;
inline void RespondFormatStorageRequest::clear_format_storage_feedback() {
  _impl_.format_storage_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondFormatStorageRequest::_internal_format_storage_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.format_storage_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondFormatStorageRequest::format_storage_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondFormatStorageRequest.format_storage_feedback)
  return _internal_format_storage_feedback();
}
inline void RespondFormatStorageRequest::_internal_set_format_storage_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.format_storage_feedback_ = value;
}
inline void RespondFormatStorageRequest::set_format_storage_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_format_storage_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondFormatStorageRequest.format_storage_feedback)
}

// -------------------------------------------------------------------

// RespondFormatStorageResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondFormatStorageResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondFormatStorageResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondFormatStorageResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondFormatStorageResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondFormatStorageResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondFormatStorageResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondFormatStorageResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondFormatStorageResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondFormatStorageResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondFormatStorageResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondFormatStorageResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondFormatStorageResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondFormatStorageResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondFormatStorageResponse.camera_server_result)
  return _msg;
}
inline void RespondFormatStorageResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondFormatStorageResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeResetSettingsRequest

// -------------------------------------------------------------------

// ResetSettingsResponse

// int32 reserved = 1;
inline void ResetSettingsResponse::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t ResetSettingsResponse::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t ResetSettingsResponse::reserved() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.ResetSettingsResponse.reserved)
  return _internal_reserved();
}
inline void ResetSettingsResponse::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void ResetSettingsResponse::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.ResetSettingsResponse.reserved)
}

// -------------------------------------------------------------------

// RespondResetSettingsRequest

// .mavsdk.rpc.camera_server.CameraFeedback reset_settings_feedback = 1;
inline void RespondResetSettingsRequest::clear_reset_settings_feedback() {
  _impl_.reset_settings_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondResetSettingsRequest::_internal_reset_settings_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.reset_settings_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondResetSettingsRequest::reset_settings_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondResetSettingsRequest.reset_settings_feedback)
  return _internal_reset_settings_feedback();
}
inline void RespondResetSettingsRequest::_internal_set_reset_settings_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.reset_settings_feedback_ = value;
}
inline void RespondResetSettingsRequest::set_reset_settings_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_reset_settings_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondResetSettingsRequest.reset_settings_feedback)
}

// -------------------------------------------------------------------

// RespondResetSettingsResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondResetSettingsResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondResetSettingsResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondResetSettingsResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondResetSettingsResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondResetSettingsResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondResetSettingsResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondResetSettingsResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondResetSettingsResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondResetSettingsResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondResetSettingsResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondResetSettingsResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondResetSettingsResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondResetSettingsResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondResetSettingsResponse.camera_server_result)
  return _msg;
}
inline void RespondResetSettingsResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondResetSettingsResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeZoomInStartRequest

// -------------------------------------------------------------------

// ZoomInStartResponse

// int32 reserved = 1;
inline void ZoomInStartResponse::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t ZoomInStartResponse::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t ZoomInStartResponse::reserved() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.ZoomInStartResponse.reserved)
  return _internal_reserved();
}
inline void ZoomInStartResponse::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void ZoomInStartResponse::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.ZoomInStartResponse.reserved)
}

// -------------------------------------------------------------------

// RespondZoomInStartRequest

// .mavsdk.rpc.camera_server.CameraFeedback zoom_in_start_feedback = 1;
inline void RespondZoomInStartRequest::clear_zoom_in_start_feedback() {
  _impl_.zoom_in_start_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomInStartRequest::_internal_zoom_in_start_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.zoom_in_start_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomInStartRequest::zoom_in_start_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomInStartRequest.zoom_in_start_feedback)
  return _internal_zoom_in_start_feedback();
}
inline void RespondZoomInStartRequest::_internal_set_zoom_in_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.zoom_in_start_feedback_ = value;
}
inline void RespondZoomInStartRequest::set_zoom_in_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_zoom_in_start_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondZoomInStartRequest.zoom_in_start_feedback)
}

// -------------------------------------------------------------------

// RespondZoomInStartResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondZoomInStartResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondZoomInStartResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondZoomInStartResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomInStartResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomInStartResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomInStartResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondZoomInStartResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondZoomInStartResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomInStartResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomInStartResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondZoomInStartResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomInStartResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomInStartResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondZoomInStartResponse.camera_server_result)
  return _msg;
}
inline void RespondZoomInStartResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondZoomInStartResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeZoomOutStartRequest

// -------------------------------------------------------------------

// ZoomOutStartResponse

// int32 reserved = 1;
inline void ZoomOutStartResponse::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t ZoomOutStartResponse::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t ZoomOutStartResponse::reserved() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.ZoomOutStartResponse.reserved)
  return _internal_reserved();
}
inline void ZoomOutStartResponse::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void ZoomOutStartResponse::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.ZoomOutStartResponse.reserved)
}

// -------------------------------------------------------------------

// RespondZoomOutStartRequest

// .mavsdk.rpc.camera_server.CameraFeedback zoom_out_start_feedback = 1;
inline void RespondZoomOutStartRequest::clear_zoom_out_start_feedback() {
  _impl_.zoom_out_start_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomOutStartRequest::_internal_zoom_out_start_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.zoom_out_start_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomOutStartRequest::zoom_out_start_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomOutStartRequest.zoom_out_start_feedback)
  return _internal_zoom_out_start_feedback();
}
inline void RespondZoomOutStartRequest::_internal_set_zoom_out_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.zoom_out_start_feedback_ = value;
}
inline void RespondZoomOutStartRequest::set_zoom_out_start_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_zoom_out_start_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondZoomOutStartRequest.zoom_out_start_feedback)
}

// -------------------------------------------------------------------

// RespondZoomOutStartResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondZoomOutStartResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondZoomOutStartResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondZoomOutStartResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomOutStartResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomOutStartResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomOutStartResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondZoomOutStartResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondZoomOutStartResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomOutStartResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomOutStartResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondZoomOutStartResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomOutStartResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomOutStartResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondZoomOutStartResponse.camera_server_result)
  return _msg;
}
inline void RespondZoomOutStartResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondZoomOutStartResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeZoomStopRequest

// -------------------------------------------------------------------

// ZoomStopResponse

// int32 reserved = 1;
inline void ZoomStopResponse::clear_reserved() {
  _impl_.reserved_ = 0;
}
inline int32_t ZoomStopResponse::_internal_reserved() const {
  return _impl_.reserved_;
}
inline int32_t ZoomStopResponse::reserved() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.ZoomStopResponse.reserved)
  return _internal_reserved();
}
inline void ZoomStopResponse::_internal_set_reserved(int32_t value) {
  
  _impl_.reserved_ = value;
}
inline void ZoomStopResponse::set_reserved(int32_t value) {
  _internal_set_reserved(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.ZoomStopResponse.reserved)
}

// -------------------------------------------------------------------

// RespondZoomStopRequest

// .mavsdk.rpc.camera_server.CameraFeedback zoom_stop_feedback = 1;
inline void RespondZoomStopRequest::clear_zoom_stop_feedback() {
  _impl_.zoom_stop_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomStopRequest::_internal_zoom_stop_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.zoom_stop_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomStopRequest::zoom_stop_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomStopRequest.zoom_stop_feedback)
  return _internal_zoom_stop_feedback();
}
inline void RespondZoomStopRequest::_internal_set_zoom_stop_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.zoom_stop_feedback_ = value;
}
inline void RespondZoomStopRequest::set_zoom_stop_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_zoom_stop_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondZoomStopRequest.zoom_stop_feedback)
}

// -------------------------------------------------------------------

// RespondZoomStopResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondZoomStopResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondZoomStopResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondZoomStopResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomStopResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomStopResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomStopResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondZoomStopResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondZoomStopResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomStopResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomStopResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondZoomStopResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomStopResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomStopResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondZoomStopResponse.camera_server_result)
  return _msg;
}
inline void RespondZoomStopResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondZoomStopResponse.camera_server_result)
}

// -------------------------------------------------------------------

// SubscribeZoomRangeRequest

// -------------------------------------------------------------------

// ZoomRangeResponse

// float factor = 1;
inline void ZoomRangeResponse::clear_factor() {
  _impl_.factor_ = 0;
}
inline float ZoomRangeResponse::_internal_factor() const {
  return _impl_.factor_;
}
inline float ZoomRangeResponse::factor() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.ZoomRangeResponse.factor)
  return _internal_factor();
}
inline void ZoomRangeResponse::_internal_set_factor(float value) {
  
  _impl_.factor_ = value;
}
inline void ZoomRangeResponse::set_factor(float value) {
  _internal_set_factor(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.ZoomRangeResponse.factor)
}

// -------------------------------------------------------------------

// RespondZoomRangeRequest

// .mavsdk.rpc.camera_server.CameraFeedback zoom_range_feedback = 1;
inline void RespondZoomRangeRequest::clear_zoom_range_feedback() {
  _impl_.zoom_range_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomRangeRequest::_internal_zoom_range_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.zoom_range_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondZoomRangeRequest::zoom_range_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomRangeRequest.zoom_range_feedback)
  return _internal_zoom_range_feedback();
}
inline void RespondZoomRangeRequest::_internal_set_zoom_range_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.zoom_range_feedback_ = value;
}
inline void RespondZoomRangeRequest::set_zoom_range_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_zoom_range_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondZoomRangeRequest.zoom_range_feedback)
}

// -------------------------------------------------------------------

// RespondZoomRangeResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondZoomRangeResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondZoomRangeResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondZoomRangeResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomRangeResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondZoomRangeResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondZoomRangeResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondZoomRangeResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondZoomRangeResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomRangeResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomRangeResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondZoomRangeResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomRangeResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondZoomRangeResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondZoomRangeResponse.camera_server_result)
  return _msg;
}
inline void RespondZoomRangeResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondZoomRangeResponse.camera_server_result)
}

// -------------------------------------------------------------------

// Information

// string vendor_name = 1;
inline void Information::clear_vendor_name() {
  _impl_.vendor_name_.ClearToEmpty();
}
inline const std::string& Information::vendor_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.vendor_name)
  return _internal_vendor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Information::set_vendor_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.vendor_name)
}
inline std::string* Information::mutable_vendor_name() {
  std::string* _s = _internal_mutable_vendor_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.Information.vendor_name)
  return _s;
}
inline const std::string& Information::_internal_vendor_name() const {
  return _impl_.vendor_name_.Get();
}
inline void Information::_internal_set_vendor_name(const std::string& value) {
  
  _impl_.vendor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_vendor_name() {
  
  return _impl_.vendor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Information::release_vendor_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.Information.vendor_name)
  return _impl_.vendor_name_.Release();
}
inline void Information::set_allocated_vendor_name(std::string* vendor_name) {
  if (vendor_name != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_name_.SetAllocated(vendor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_name_.IsDefault()) {
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.Information.vendor_name)
}

// string model_name = 2;
inline void Information::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& Information::model_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Information::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.model_name)
}
inline std::string* Information::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.Information.model_name)
  return _s;
}
inline const std::string& Information::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void Information::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Information::release_model_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.Information.model_name)
  return _impl_.model_name_.Release();
}
inline void Information::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.Information.model_name)
}

// string firmware_version = 3;
inline void Information::clear_firmware_version() {
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& Information::firmware_version() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.firmware_version)
  return _internal_firmware_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Information::set_firmware_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.firmware_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.firmware_version)
}
inline std::string* Information::mutable_firmware_version() {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.Information.firmware_version)
  return _s;
}
inline const std::string& Information::_internal_firmware_version() const {
  return _impl_.firmware_version_.Get();
}
inline void Information::_internal_set_firmware_version(const std::string& value) {
  
  _impl_.firmware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_firmware_version() {
  
  return _impl_.firmware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Information::release_firmware_version() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.Information.firmware_version)
  return _impl_.firmware_version_.Release();
}
inline void Information::set_allocated_firmware_version(std::string* firmware_version) {
  if (firmware_version != nullptr) {
    
  } else {
    
  }
  _impl_.firmware_version_.SetAllocated(firmware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.Information.firmware_version)
}

// float focal_length_mm = 4;
inline void Information::clear_focal_length_mm() {
  _impl_.focal_length_mm_ = 0;
}
inline float Information::_internal_focal_length_mm() const {
  return _impl_.focal_length_mm_;
}
inline float Information::focal_length_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.focal_length_mm)
  return _internal_focal_length_mm();
}
inline void Information::_internal_set_focal_length_mm(float value) {
  
  _impl_.focal_length_mm_ = value;
}
inline void Information::set_focal_length_mm(float value) {
  _internal_set_focal_length_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.focal_length_mm)
}

// float horizontal_sensor_size_mm = 5;
inline void Information::clear_horizontal_sensor_size_mm() {
  _impl_.horizontal_sensor_size_mm_ = 0;
}
inline float Information::_internal_horizontal_sensor_size_mm() const {
  return _impl_.horizontal_sensor_size_mm_;
}
inline float Information::horizontal_sensor_size_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.horizontal_sensor_size_mm)
  return _internal_horizontal_sensor_size_mm();
}
inline void Information::_internal_set_horizontal_sensor_size_mm(float value) {
  
  _impl_.horizontal_sensor_size_mm_ = value;
}
inline void Information::set_horizontal_sensor_size_mm(float value) {
  _internal_set_horizontal_sensor_size_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.horizontal_sensor_size_mm)
}

// float vertical_sensor_size_mm = 6;
inline void Information::clear_vertical_sensor_size_mm() {
  _impl_.vertical_sensor_size_mm_ = 0;
}
inline float Information::_internal_vertical_sensor_size_mm() const {
  return _impl_.vertical_sensor_size_mm_;
}
inline float Information::vertical_sensor_size_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.vertical_sensor_size_mm)
  return _internal_vertical_sensor_size_mm();
}
inline void Information::_internal_set_vertical_sensor_size_mm(float value) {
  
  _impl_.vertical_sensor_size_mm_ = value;
}
inline void Information::set_vertical_sensor_size_mm(float value) {
  _internal_set_vertical_sensor_size_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.vertical_sensor_size_mm)
}

// uint32 horizontal_resolution_px = 7;
inline void Information::clear_horizontal_resolution_px() {
  _impl_.horizontal_resolution_px_ = 0u;
}
inline uint32_t Information::_internal_horizontal_resolution_px() const {
  return _impl_.horizontal_resolution_px_;
}
inline uint32_t Information::horizontal_resolution_px() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.horizontal_resolution_px)
  return _internal_horizontal_resolution_px();
}
inline void Information::_internal_set_horizontal_resolution_px(uint32_t value) {
  
  _impl_.horizontal_resolution_px_ = value;
}
inline void Information::set_horizontal_resolution_px(uint32_t value) {
  _internal_set_horizontal_resolution_px(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.horizontal_resolution_px)
}

// uint32 vertical_resolution_px = 8;
inline void Information::clear_vertical_resolution_px() {
  _impl_.vertical_resolution_px_ = 0u;
}
inline uint32_t Information::_internal_vertical_resolution_px() const {
  return _impl_.vertical_resolution_px_;
}
inline uint32_t Information::vertical_resolution_px() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.vertical_resolution_px)
  return _internal_vertical_resolution_px();
}
inline void Information::_internal_set_vertical_resolution_px(uint32_t value) {
  
  _impl_.vertical_resolution_px_ = value;
}
inline void Information::set_vertical_resolution_px(uint32_t value) {
  _internal_set_vertical_resolution_px(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.vertical_resolution_px)
}

// uint32 lens_id = 9;
inline void Information::clear_lens_id() {
  _impl_.lens_id_ = 0u;
}
inline uint32_t Information::_internal_lens_id() const {
  return _impl_.lens_id_;
}
inline uint32_t Information::lens_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.lens_id)
  return _internal_lens_id();
}
inline void Information::_internal_set_lens_id(uint32_t value) {
  
  _impl_.lens_id_ = value;
}
inline void Information::set_lens_id(uint32_t value) {
  _internal_set_lens_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.lens_id)
}

// uint32 definition_file_version = 10;
inline void Information::clear_definition_file_version() {
  _impl_.definition_file_version_ = 0u;
}
inline uint32_t Information::_internal_definition_file_version() const {
  return _impl_.definition_file_version_;
}
inline uint32_t Information::definition_file_version() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.definition_file_version)
  return _internal_definition_file_version();
}
inline void Information::_internal_set_definition_file_version(uint32_t value) {
  
  _impl_.definition_file_version_ = value;
}
inline void Information::set_definition_file_version(uint32_t value) {
  _internal_set_definition_file_version(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.definition_file_version)
}

// string definition_file_uri = 11;
inline void Information::clear_definition_file_uri() {
  _impl_.definition_file_uri_.ClearToEmpty();
}
inline const std::string& Information::definition_file_uri() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.definition_file_uri)
  return _internal_definition_file_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Information::set_definition_file_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.definition_file_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.definition_file_uri)
}
inline std::string* Information::mutable_definition_file_uri() {
  std::string* _s = _internal_mutable_definition_file_uri();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.Information.definition_file_uri)
  return _s;
}
inline const std::string& Information::_internal_definition_file_uri() const {
  return _impl_.definition_file_uri_.Get();
}
inline void Information::_internal_set_definition_file_uri(const std::string& value) {
  
  _impl_.definition_file_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_definition_file_uri() {
  
  return _impl_.definition_file_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Information::release_definition_file_uri() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.Information.definition_file_uri)
  return _impl_.definition_file_uri_.Release();
}
inline void Information::set_allocated_definition_file_uri(std::string* definition_file_uri) {
  if (definition_file_uri != nullptr) {
    
  } else {
    
  }
  _impl_.definition_file_uri_.SetAllocated(definition_file_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.definition_file_uri_.IsDefault()) {
    _impl_.definition_file_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.Information.definition_file_uri)
}

// bool image_in_video_mode_supported = 12;
inline void Information::clear_image_in_video_mode_supported() {
  _impl_.image_in_video_mode_supported_ = false;
}
inline bool Information::_internal_image_in_video_mode_supported() const {
  return _impl_.image_in_video_mode_supported_;
}
inline bool Information::image_in_video_mode_supported() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.image_in_video_mode_supported)
  return _internal_image_in_video_mode_supported();
}
inline void Information::_internal_set_image_in_video_mode_supported(bool value) {
  
  _impl_.image_in_video_mode_supported_ = value;
}
inline void Information::set_image_in_video_mode_supported(bool value) {
  _internal_set_image_in_video_mode_supported(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.image_in_video_mode_supported)
}

// bool video_in_image_mode_supported = 13;
inline void Information::clear_video_in_image_mode_supported() {
  _impl_.video_in_image_mode_supported_ = false;
}
inline bool Information::_internal_video_in_image_mode_supported() const {
  return _impl_.video_in_image_mode_supported_;
}
inline bool Information::video_in_image_mode_supported() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Information.video_in_image_mode_supported)
  return _internal_video_in_image_mode_supported();
}
inline void Information::_internal_set_video_in_image_mode_supported(bool value) {
  
  _impl_.video_in_image_mode_supported_ = value;
}
inline void Information::set_video_in_image_mode_supported(bool value) {
  _internal_set_video_in_image_mode_supported(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Information.video_in_image_mode_supported)
}

// -------------------------------------------------------------------

// VideoStreaming

// bool has_rtsp_server = 1;
inline void VideoStreaming::clear_has_rtsp_server() {
  _impl_.has_rtsp_server_ = false;
}
inline bool VideoStreaming::_internal_has_rtsp_server() const {
  return _impl_.has_rtsp_server_;
}
inline bool VideoStreaming::has_rtsp_server() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.VideoStreaming.has_rtsp_server)
  return _internal_has_rtsp_server();
}
inline void VideoStreaming::_internal_set_has_rtsp_server(bool value) {
  
  _impl_.has_rtsp_server_ = value;
}
inline void VideoStreaming::set_has_rtsp_server(bool value) {
  _internal_set_has_rtsp_server(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.VideoStreaming.has_rtsp_server)
}

// string rtsp_uri = 2;
inline void VideoStreaming::clear_rtsp_uri() {
  _impl_.rtsp_uri_.ClearToEmpty();
}
inline const std::string& VideoStreaming::rtsp_uri() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.VideoStreaming.rtsp_uri)
  return _internal_rtsp_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoStreaming::set_rtsp_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rtsp_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.VideoStreaming.rtsp_uri)
}
inline std::string* VideoStreaming::mutable_rtsp_uri() {
  std::string* _s = _internal_mutable_rtsp_uri();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.VideoStreaming.rtsp_uri)
  return _s;
}
inline const std::string& VideoStreaming::_internal_rtsp_uri() const {
  return _impl_.rtsp_uri_.Get();
}
inline void VideoStreaming::_internal_set_rtsp_uri(const std::string& value) {
  
  _impl_.rtsp_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoStreaming::_internal_mutable_rtsp_uri() {
  
  return _impl_.rtsp_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoStreaming::release_rtsp_uri() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.VideoStreaming.rtsp_uri)
  return _impl_.rtsp_uri_.Release();
}
inline void VideoStreaming::set_allocated_rtsp_uri(std::string* rtsp_uri) {
  if (rtsp_uri != nullptr) {
    
  } else {
    
  }
  _impl_.rtsp_uri_.SetAllocated(rtsp_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rtsp_uri_.IsDefault()) {
    _impl_.rtsp_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.VideoStreaming.rtsp_uri)
}

// -------------------------------------------------------------------

// Position

// double latitude_deg = 1;
inline void Position::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
}
inline double Position::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline double Position::latitude_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Position.latitude_deg)
  return _internal_latitude_deg();
}
inline void Position::_internal_set_latitude_deg(double value) {
  
  _impl_.latitude_deg_ = value;
}
inline void Position::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Position.latitude_deg)
}

// double longitude_deg = 2;
inline void Position::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
}
inline double Position::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline double Position::longitude_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Position.longitude_deg)
  return _internal_longitude_deg();
}
inline void Position::_internal_set_longitude_deg(double value) {
  
  _impl_.longitude_deg_ = value;
}
inline void Position::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Position.longitude_deg)
}

// float absolute_altitude_m = 3;
inline void Position::clear_absolute_altitude_m() {
  _impl_.absolute_altitude_m_ = 0;
}
inline float Position::_internal_absolute_altitude_m() const {
  return _impl_.absolute_altitude_m_;
}
inline float Position::absolute_altitude_m() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Position.absolute_altitude_m)
  return _internal_absolute_altitude_m();
}
inline void Position::_internal_set_absolute_altitude_m(float value) {
  
  _impl_.absolute_altitude_m_ = value;
}
inline void Position::set_absolute_altitude_m(float value) {
  _internal_set_absolute_altitude_m(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Position.absolute_altitude_m)
}

// float relative_altitude_m = 4;
inline void Position::clear_relative_altitude_m() {
  _impl_.relative_altitude_m_ = 0;
}
inline float Position::_internal_relative_altitude_m() const {
  return _impl_.relative_altitude_m_;
}
inline float Position::relative_altitude_m() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Position.relative_altitude_m)
  return _internal_relative_altitude_m();
}
inline void Position::_internal_set_relative_altitude_m(float value) {
  
  _impl_.relative_altitude_m_ = value;
}
inline void Position::set_relative_altitude_m(float value) {
  _internal_set_relative_altitude_m(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Position.relative_altitude_m)
}

// -------------------------------------------------------------------

// Quaternion

// float w = 1;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline float Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void Quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Quaternion.w)
}

// float x = 2;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline float Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Quaternion.x)
}

// float y = 3;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline float Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Quaternion.y)
}

// float z = 4;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline float Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.Quaternion.z)
}

// -------------------------------------------------------------------

// CaptureInfo

// .mavsdk.rpc.camera_server.Position position = 1;
inline bool CaptureInfo::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool CaptureInfo::has_position() const {
  return _internal_has_position();
}
inline void CaptureInfo::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::Position& CaptureInfo::_internal_position() const {
  const ::mavsdk::rpc::camera_server::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::Position&>(
      ::mavsdk::rpc::camera_server::_Position_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::Position& CaptureInfo::position() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.position)
  return _internal_position();
}
inline void CaptureInfo::unsafe_arena_set_allocated_position(
    ::mavsdk::rpc::camera_server::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.CaptureInfo.position)
}
inline ::mavsdk::rpc::camera_server::Position* CaptureInfo::release_position() {
  
  ::mavsdk::rpc::camera_server::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::Position* CaptureInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.CaptureInfo.position)
  
  ::mavsdk::rpc::camera_server::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::Position* CaptureInfo::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::mavsdk::rpc::camera_server::Position* CaptureInfo::mutable_position() {
  ::mavsdk::rpc::camera_server::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.CaptureInfo.position)
  return _msg;
}
inline void CaptureInfo::set_allocated_position(::mavsdk::rpc::camera_server::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.CaptureInfo.position)
}

// .mavsdk.rpc.camera_server.Quaternion attitude_quaternion = 2;
inline bool CaptureInfo::_internal_has_attitude_quaternion() const {
  return this != internal_default_instance() && _impl_.attitude_quaternion_ != nullptr;
}
inline bool CaptureInfo::has_attitude_quaternion() const {
  return _internal_has_attitude_quaternion();
}
inline void CaptureInfo::clear_attitude_quaternion() {
  if (GetArenaForAllocation() == nullptr && _impl_.attitude_quaternion_ != nullptr) {
    delete _impl_.attitude_quaternion_;
  }
  _impl_.attitude_quaternion_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::Quaternion& CaptureInfo::_internal_attitude_quaternion() const {
  const ::mavsdk::rpc::camera_server::Quaternion* p = _impl_.attitude_quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::Quaternion&>(
      ::mavsdk::rpc::camera_server::_Quaternion_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::Quaternion& CaptureInfo::attitude_quaternion() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.attitude_quaternion)
  return _internal_attitude_quaternion();
}
inline void CaptureInfo::unsafe_arena_set_allocated_attitude_quaternion(
    ::mavsdk::rpc::camera_server::Quaternion* attitude_quaternion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_quaternion_);
  }
  _impl_.attitude_quaternion_ = attitude_quaternion;
  if (attitude_quaternion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.CaptureInfo.attitude_quaternion)
}
inline ::mavsdk::rpc::camera_server::Quaternion* CaptureInfo::release_attitude_quaternion() {
  
  ::mavsdk::rpc::camera_server::Quaternion* temp = _impl_.attitude_quaternion_;
  _impl_.attitude_quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::Quaternion* CaptureInfo::unsafe_arena_release_attitude_quaternion() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.CaptureInfo.attitude_quaternion)
  
  ::mavsdk::rpc::camera_server::Quaternion* temp = _impl_.attitude_quaternion_;
  _impl_.attitude_quaternion_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::Quaternion* CaptureInfo::_internal_mutable_attitude_quaternion() {
  
  if (_impl_.attitude_quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::Quaternion>(GetArenaForAllocation());
    _impl_.attitude_quaternion_ = p;
  }
  return _impl_.attitude_quaternion_;
}
inline ::mavsdk::rpc::camera_server::Quaternion* CaptureInfo::mutable_attitude_quaternion() {
  ::mavsdk::rpc::camera_server::Quaternion* _msg = _internal_mutable_attitude_quaternion();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.CaptureInfo.attitude_quaternion)
  return _msg;
}
inline void CaptureInfo::set_allocated_attitude_quaternion(::mavsdk::rpc::camera_server::Quaternion* attitude_quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attitude_quaternion_;
  }
  if (attitude_quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attitude_quaternion);
    if (message_arena != submessage_arena) {
      attitude_quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude_quaternion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attitude_quaternion_ = attitude_quaternion;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.CaptureInfo.attitude_quaternion)
}

// uint64 time_utc_us = 3;
inline void CaptureInfo::clear_time_utc_us() {
  _impl_.time_utc_us_ = uint64_t{0u};
}
inline uint64_t CaptureInfo::_internal_time_utc_us() const {
  return _impl_.time_utc_us_;
}
inline uint64_t CaptureInfo::time_utc_us() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.time_utc_us)
  return _internal_time_utc_us();
}
inline void CaptureInfo::_internal_set_time_utc_us(uint64_t value) {
  
  _impl_.time_utc_us_ = value;
}
inline void CaptureInfo::set_time_utc_us(uint64_t value) {
  _internal_set_time_utc_us(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureInfo.time_utc_us)
}

// bool is_success = 4;
inline void CaptureInfo::clear_is_success() {
  _impl_.is_success_ = false;
}
inline bool CaptureInfo::_internal_is_success() const {
  return _impl_.is_success_;
}
inline bool CaptureInfo::is_success() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.is_success)
  return _internal_is_success();
}
inline void CaptureInfo::_internal_set_is_success(bool value) {
  
  _impl_.is_success_ = value;
}
inline void CaptureInfo::set_is_success(bool value) {
  _internal_set_is_success(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureInfo.is_success)
}

// int32 index = 5;
inline void CaptureInfo::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t CaptureInfo::_internal_index() const {
  return _impl_.index_;
}
inline int32_t CaptureInfo::index() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.index)
  return _internal_index();
}
inline void CaptureInfo::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void CaptureInfo::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureInfo.index)
}

// string file_url = 6;
inline void CaptureInfo::clear_file_url() {
  _impl_.file_url_.ClearToEmpty();
}
inline const std::string& CaptureInfo::file_url() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureInfo.file_url)
  return _internal_file_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaptureInfo::set_file_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureInfo.file_url)
}
inline std::string* CaptureInfo::mutable_file_url() {
  std::string* _s = _internal_mutable_file_url();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.CaptureInfo.file_url)
  return _s;
}
inline const std::string& CaptureInfo::_internal_file_url() const {
  return _impl_.file_url_.Get();
}
inline void CaptureInfo::_internal_set_file_url(const std::string& value) {
  
  _impl_.file_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureInfo::_internal_mutable_file_url() {
  
  return _impl_.file_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CaptureInfo::release_file_url() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.CaptureInfo.file_url)
  return _impl_.file_url_.Release();
}
inline void CaptureInfo::set_allocated_file_url(std::string* file_url) {
  if (file_url != nullptr) {
    
  } else {
    
  }
  _impl_.file_url_.SetAllocated(file_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_url_.IsDefault()) {
    _impl_.file_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.CaptureInfo.file_url)
}

// -------------------------------------------------------------------

// CameraServerResult

// .mavsdk.rpc.camera_server.CameraServerResult.Result result = 1;
inline void CameraServerResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult_Result CameraServerResult::_internal_result() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraServerResult_Result >(_impl_.result_);
}
inline ::mavsdk::rpc::camera_server::CameraServerResult_Result CameraServerResult::result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CameraServerResult.result)
  return _internal_result();
}
inline void CameraServerResult::_internal_set_result(::mavsdk::rpc::camera_server::CameraServerResult_Result value) {
  
  _impl_.result_ = value;
}
inline void CameraServerResult::set_result(::mavsdk::rpc::camera_server::CameraServerResult_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CameraServerResult.result)
}

// string result_str = 2;
inline void CameraServerResult::clear_result_str() {
  _impl_.result_str_.ClearToEmpty();
}
inline const std::string& CameraServerResult::result_str() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CameraServerResult.result_str)
  return _internal_result_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CameraServerResult::set_result_str(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CameraServerResult.result_str)
}
inline std::string* CameraServerResult::mutable_result_str() {
  std::string* _s = _internal_mutable_result_str();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.CameraServerResult.result_str)
  return _s;
}
inline const std::string& CameraServerResult::_internal_result_str() const {
  return _impl_.result_str_.Get();
}
inline void CameraServerResult::_internal_set_result_str(const std::string& value) {
  
  _impl_.result_str_.Set(value, GetArenaForAllocation());
}
inline std::string* CameraServerResult::_internal_mutable_result_str() {
  
  return _impl_.result_str_.Mutable(GetArenaForAllocation());
}
inline std::string* CameraServerResult::release_result_str() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.CameraServerResult.result_str)
  return _impl_.result_str_.Release();
}
inline void CameraServerResult::set_allocated_result_str(std::string* result_str) {
  if (result_str != nullptr) {
    
  } else {
    
  }
  _impl_.result_str_.SetAllocated(result_str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_str_.IsDefault()) {
    _impl_.result_str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.CameraServerResult.result_str)
}

// -------------------------------------------------------------------

// StorageInformation

// float used_storage_mib = 1;
inline void StorageInformation::clear_used_storage_mib() {
  _impl_.used_storage_mib_ = 0;
}
inline float StorageInformation::_internal_used_storage_mib() const {
  return _impl_.used_storage_mib_;
}
inline float StorageInformation::used_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.used_storage_mib)
  return _internal_used_storage_mib();
}
inline void StorageInformation::_internal_set_used_storage_mib(float value) {
  
  _impl_.used_storage_mib_ = value;
}
inline void StorageInformation::set_used_storage_mib(float value) {
  _internal_set_used_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.used_storage_mib)
}

// float available_storage_mib = 2;
inline void StorageInformation::clear_available_storage_mib() {
  _impl_.available_storage_mib_ = 0;
}
inline float StorageInformation::_internal_available_storage_mib() const {
  return _impl_.available_storage_mib_;
}
inline float StorageInformation::available_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.available_storage_mib)
  return _internal_available_storage_mib();
}
inline void StorageInformation::_internal_set_available_storage_mib(float value) {
  
  _impl_.available_storage_mib_ = value;
}
inline void StorageInformation::set_available_storage_mib(float value) {
  _internal_set_available_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.available_storage_mib)
}

// float total_storage_mib = 3;
inline void StorageInformation::clear_total_storage_mib() {
  _impl_.total_storage_mib_ = 0;
}
inline float StorageInformation::_internal_total_storage_mib() const {
  return _impl_.total_storage_mib_;
}
inline float StorageInformation::total_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.total_storage_mib)
  return _internal_total_storage_mib();
}
inline void StorageInformation::_internal_set_total_storage_mib(float value) {
  
  _impl_.total_storage_mib_ = value;
}
inline void StorageInformation::set_total_storage_mib(float value) {
  _internal_set_total_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.total_storage_mib)
}

// .mavsdk.rpc.camera_server.StorageInformation.StorageStatus storage_status = 4;
inline void StorageInformation::clear_storage_status() {
  _impl_.storage_status_ = 0;
}
inline ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus StorageInformation::_internal_storage_status() const {
  return static_cast< ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus >(_impl_.storage_status_);
}
inline ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus StorageInformation::storage_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.storage_status)
  return _internal_storage_status();
}
inline void StorageInformation::_internal_set_storage_status(::mavsdk::rpc::camera_server::StorageInformation_StorageStatus value) {
  
  _impl_.storage_status_ = value;
}
inline void StorageInformation::set_storage_status(::mavsdk::rpc::camera_server::StorageInformation_StorageStatus value) {
  _internal_set_storage_status(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.storage_status)
}

// uint32 storage_id = 5;
inline void StorageInformation::clear_storage_id() {
  _impl_.storage_id_ = 0u;
}
inline uint32_t StorageInformation::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline uint32_t StorageInformation::storage_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.storage_id)
  return _internal_storage_id();
}
inline void StorageInformation::_internal_set_storage_id(uint32_t value) {
  
  _impl_.storage_id_ = value;
}
inline void StorageInformation::set_storage_id(uint32_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.storage_id)
}

// .mavsdk.rpc.camera_server.StorageInformation.StorageType storage_type = 6;
inline void StorageInformation::clear_storage_type() {
  _impl_.storage_type_ = 0;
}
inline ::mavsdk::rpc::camera_server::StorageInformation_StorageType StorageInformation::_internal_storage_type() const {
  return static_cast< ::mavsdk::rpc::camera_server::StorageInformation_StorageType >(_impl_.storage_type_);
}
inline ::mavsdk::rpc::camera_server::StorageInformation_StorageType StorageInformation::storage_type() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.storage_type)
  return _internal_storage_type();
}
inline void StorageInformation::_internal_set_storage_type(::mavsdk::rpc::camera_server::StorageInformation_StorageType value) {
  
  _impl_.storage_type_ = value;
}
inline void StorageInformation::set_storage_type(::mavsdk::rpc::camera_server::StorageInformation_StorageType value) {
  _internal_set_storage_type(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.storage_type)
}

// float read_speed_mib_s = 7;
inline void StorageInformation::clear_read_speed_mib_s() {
  _impl_.read_speed_mib_s_ = 0;
}
inline float StorageInformation::_internal_read_speed_mib_s() const {
  return _impl_.read_speed_mib_s_;
}
inline float StorageInformation::read_speed_mib_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.read_speed_mib_s)
  return _internal_read_speed_mib_s();
}
inline void StorageInformation::_internal_set_read_speed_mib_s(float value) {
  
  _impl_.read_speed_mib_s_ = value;
}
inline void StorageInformation::set_read_speed_mib_s(float value) {
  _internal_set_read_speed_mib_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.read_speed_mib_s)
}

// float write_speed_mib_s = 8;
inline void StorageInformation::clear_write_speed_mib_s() {
  _impl_.write_speed_mib_s_ = 0;
}
inline float StorageInformation::_internal_write_speed_mib_s() const {
  return _impl_.write_speed_mib_s_;
}
inline float StorageInformation::write_speed_mib_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.StorageInformation.write_speed_mib_s)
  return _internal_write_speed_mib_s();
}
inline void StorageInformation::_internal_set_write_speed_mib_s(float value) {
  
  _impl_.write_speed_mib_s_ = value;
}
inline void StorageInformation::set_write_speed_mib_s(float value) {
  _internal_set_write_speed_mib_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.StorageInformation.write_speed_mib_s)
}

// -------------------------------------------------------------------

// CaptureStatus

// float image_interval_s = 1;
inline void CaptureStatus::clear_image_interval_s() {
  _impl_.image_interval_s_ = 0;
}
inline float CaptureStatus::_internal_image_interval_s() const {
  return _impl_.image_interval_s_;
}
inline float CaptureStatus::image_interval_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.image_interval_s)
  return _internal_image_interval_s();
}
inline void CaptureStatus::_internal_set_image_interval_s(float value) {
  
  _impl_.image_interval_s_ = value;
}
inline void CaptureStatus::set_image_interval_s(float value) {
  _internal_set_image_interval_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.image_interval_s)
}

// float recording_time_s = 2;
inline void CaptureStatus::clear_recording_time_s() {
  _impl_.recording_time_s_ = 0;
}
inline float CaptureStatus::_internal_recording_time_s() const {
  return _impl_.recording_time_s_;
}
inline float CaptureStatus::recording_time_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.recording_time_s)
  return _internal_recording_time_s();
}
inline void CaptureStatus::_internal_set_recording_time_s(float value) {
  
  _impl_.recording_time_s_ = value;
}
inline void CaptureStatus::set_recording_time_s(float value) {
  _internal_set_recording_time_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.recording_time_s)
}

// float available_capacity_mib = 3;
inline void CaptureStatus::clear_available_capacity_mib() {
  _impl_.available_capacity_mib_ = 0;
}
inline float CaptureStatus::_internal_available_capacity_mib() const {
  return _impl_.available_capacity_mib_;
}
inline float CaptureStatus::available_capacity_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.available_capacity_mib)
  return _internal_available_capacity_mib();
}
inline void CaptureStatus::_internal_set_available_capacity_mib(float value) {
  
  _impl_.available_capacity_mib_ = value;
}
inline void CaptureStatus::set_available_capacity_mib(float value) {
  _internal_set_available_capacity_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.available_capacity_mib)
}

// .mavsdk.rpc.camera_server.CaptureStatus.ImageStatus image_status = 4;
inline void CaptureStatus::clear_image_status() {
  _impl_.image_status_ = 0;
}
inline ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus CaptureStatus::_internal_image_status() const {
  return static_cast< ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus >(_impl_.image_status_);
}
inline ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus CaptureStatus::image_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.image_status)
  return _internal_image_status();
}
inline void CaptureStatus::_internal_set_image_status(::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus value) {
  
  _impl_.image_status_ = value;
}
inline void CaptureStatus::set_image_status(::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus value) {
  _internal_set_image_status(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.image_status)
}

// .mavsdk.rpc.camera_server.CaptureStatus.VideoStatus video_status = 5;
inline void CaptureStatus::clear_video_status() {
  _impl_.video_status_ = 0;
}
inline ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus CaptureStatus::_internal_video_status() const {
  return static_cast< ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus >(_impl_.video_status_);
}
inline ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus CaptureStatus::video_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.video_status)
  return _internal_video_status();
}
inline void CaptureStatus::_internal_set_video_status(::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus value) {
  
  _impl_.video_status_ = value;
}
inline void CaptureStatus::set_video_status(::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus value) {
  _internal_set_video_status(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.video_status)
}

// int32 image_count = 6;
inline void CaptureStatus::clear_image_count() {
  _impl_.image_count_ = 0;
}
inline int32_t CaptureStatus::_internal_image_count() const {
  return _impl_.image_count_;
}
inline int32_t CaptureStatus::image_count() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.CaptureStatus.image_count)
  return _internal_image_count();
}
inline void CaptureStatus::_internal_set_image_count(int32_t value) {
  
  _impl_.image_count_ = value;
}
inline void CaptureStatus::set_image_count(int32_t value) {
  _internal_set_image_count(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.CaptureStatus.image_count)
}

// -------------------------------------------------------------------

// SetTrackingPointStatusRequest

// .mavsdk.rpc.camera_server.TrackPoint tracked_point = 1;
inline bool SetTrackingPointStatusRequest::_internal_has_tracked_point() const {
  return this != internal_default_instance() && _impl_.tracked_point_ != nullptr;
}
inline bool SetTrackingPointStatusRequest::has_tracked_point() const {
  return _internal_has_tracked_point();
}
inline void SetTrackingPointStatusRequest::clear_tracked_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.tracked_point_ != nullptr) {
    delete _impl_.tracked_point_;
  }
  _impl_.tracked_point_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::TrackPoint& SetTrackingPointStatusRequest::_internal_tracked_point() const {
  const ::mavsdk::rpc::camera_server::TrackPoint* p = _impl_.tracked_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::TrackPoint&>(
      ::mavsdk::rpc::camera_server::_TrackPoint_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::TrackPoint& SetTrackingPointStatusRequest::tracked_point() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest.tracked_point)
  return _internal_tracked_point();
}
inline void SetTrackingPointStatusRequest::unsafe_arena_set_allocated_tracked_point(
    ::mavsdk::rpc::camera_server::TrackPoint* tracked_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tracked_point_);
  }
  _impl_.tracked_point_ = tracked_point;
  if (tracked_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest.tracked_point)
}
inline ::mavsdk::rpc::camera_server::TrackPoint* SetTrackingPointStatusRequest::release_tracked_point() {
  
  ::mavsdk::rpc::camera_server::TrackPoint* temp = _impl_.tracked_point_;
  _impl_.tracked_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* SetTrackingPointStatusRequest::unsafe_arena_release_tracked_point() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest.tracked_point)
  
  ::mavsdk::rpc::camera_server::TrackPoint* temp = _impl_.tracked_point_;
  _impl_.tracked_point_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* SetTrackingPointStatusRequest::_internal_mutable_tracked_point() {
  
  if (_impl_.tracked_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackPoint>(GetArenaForAllocation());
    _impl_.tracked_point_ = p;
  }
  return _impl_.tracked_point_;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* SetTrackingPointStatusRequest::mutable_tracked_point() {
  ::mavsdk::rpc::camera_server::TrackPoint* _msg = _internal_mutable_tracked_point();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest.tracked_point)
  return _msg;
}
inline void SetTrackingPointStatusRequest::set_allocated_tracked_point(::mavsdk::rpc::camera_server::TrackPoint* tracked_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tracked_point_;
  }
  if (tracked_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tracked_point);
    if (message_arena != submessage_arena) {
      tracked_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tracked_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tracked_point_ = tracked_point;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetTrackingPointStatusRequest.tracked_point)
}

// -------------------------------------------------------------------

// SetTrackingPointStatusResponse

// -------------------------------------------------------------------

// SetTrackingRectangleStatusRequest

// .mavsdk.rpc.camera_server.TrackRectangle tracked_rectangle = 1;
inline bool SetTrackingRectangleStatusRequest::_internal_has_tracked_rectangle() const {
  return this != internal_default_instance() && _impl_.tracked_rectangle_ != nullptr;
}
inline bool SetTrackingRectangleStatusRequest::has_tracked_rectangle() const {
  return _internal_has_tracked_rectangle();
}
inline void SetTrackingRectangleStatusRequest::clear_tracked_rectangle() {
  if (GetArenaForAllocation() == nullptr && _impl_.tracked_rectangle_ != nullptr) {
    delete _impl_.tracked_rectangle_;
  }
  _impl_.tracked_rectangle_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::TrackRectangle& SetTrackingRectangleStatusRequest::_internal_tracked_rectangle() const {
  const ::mavsdk::rpc::camera_server::TrackRectangle* p = _impl_.tracked_rectangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::TrackRectangle&>(
      ::mavsdk::rpc::camera_server::_TrackRectangle_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::TrackRectangle& SetTrackingRectangleStatusRequest::tracked_rectangle() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest.tracked_rectangle)
  return _internal_tracked_rectangle();
}
inline void SetTrackingRectangleStatusRequest::unsafe_arena_set_allocated_tracked_rectangle(
    ::mavsdk::rpc::camera_server::TrackRectangle* tracked_rectangle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tracked_rectangle_);
  }
  _impl_.tracked_rectangle_ = tracked_rectangle;
  if (tracked_rectangle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest.tracked_rectangle)
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* SetTrackingRectangleStatusRequest::release_tracked_rectangle() {
  
  ::mavsdk::rpc::camera_server::TrackRectangle* temp = _impl_.tracked_rectangle_;
  _impl_.tracked_rectangle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* SetTrackingRectangleStatusRequest::unsafe_arena_release_tracked_rectangle() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest.tracked_rectangle)
  
  ::mavsdk::rpc::camera_server::TrackRectangle* temp = _impl_.tracked_rectangle_;
  _impl_.tracked_rectangle_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* SetTrackingRectangleStatusRequest::_internal_mutable_tracked_rectangle() {
  
  if (_impl_.tracked_rectangle_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackRectangle>(GetArenaForAllocation());
    _impl_.tracked_rectangle_ = p;
  }
  return _impl_.tracked_rectangle_;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* SetTrackingRectangleStatusRequest::mutable_tracked_rectangle() {
  ::mavsdk::rpc::camera_server::TrackRectangle* _msg = _internal_mutable_tracked_rectangle();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest.tracked_rectangle)
  return _msg;
}
inline void SetTrackingRectangleStatusRequest::set_allocated_tracked_rectangle(::mavsdk::rpc::camera_server::TrackRectangle* tracked_rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tracked_rectangle_;
  }
  if (tracked_rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tracked_rectangle);
    if (message_arena != submessage_arena) {
      tracked_rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tracked_rectangle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tracked_rectangle_ = tracked_rectangle;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest.tracked_rectangle)
}

// -------------------------------------------------------------------

// SetTrackingRectangleStatusResponse

// -------------------------------------------------------------------

// SetTrackingOffStatusRequest

// -------------------------------------------------------------------

// SetTrackingOffStatusResponse

// -------------------------------------------------------------------

// SubscribeTrackingPointCommandRequest

// -------------------------------------------------------------------

// TrackingPointCommandResponse

// .mavsdk.rpc.camera_server.TrackPoint track_point = 1;
inline bool TrackingPointCommandResponse::_internal_has_track_point() const {
  return this != internal_default_instance() && _impl_.track_point_ != nullptr;
}
inline bool TrackingPointCommandResponse::has_track_point() const {
  return _internal_has_track_point();
}
inline void TrackingPointCommandResponse::clear_track_point() {
  if (GetArenaForAllocation() == nullptr && _impl_.track_point_ != nullptr) {
    delete _impl_.track_point_;
  }
  _impl_.track_point_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::TrackPoint& TrackingPointCommandResponse::_internal_track_point() const {
  const ::mavsdk::rpc::camera_server::TrackPoint* p = _impl_.track_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::TrackPoint&>(
      ::mavsdk::rpc::camera_server::_TrackPoint_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::TrackPoint& TrackingPointCommandResponse::track_point() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackingPointCommandResponse.track_point)
  return _internal_track_point();
}
inline void TrackingPointCommandResponse::unsafe_arena_set_allocated_track_point(
    ::mavsdk::rpc::camera_server::TrackPoint* track_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_point_);
  }
  _impl_.track_point_ = track_point;
  if (track_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.TrackingPointCommandResponse.track_point)
}
inline ::mavsdk::rpc::camera_server::TrackPoint* TrackingPointCommandResponse::release_track_point() {
  
  ::mavsdk::rpc::camera_server::TrackPoint* temp = _impl_.track_point_;
  _impl_.track_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* TrackingPointCommandResponse::unsafe_arena_release_track_point() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.TrackingPointCommandResponse.track_point)
  
  ::mavsdk::rpc::camera_server::TrackPoint* temp = _impl_.track_point_;
  _impl_.track_point_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* TrackingPointCommandResponse::_internal_mutable_track_point() {
  
  if (_impl_.track_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackPoint>(GetArenaForAllocation());
    _impl_.track_point_ = p;
  }
  return _impl_.track_point_;
}
inline ::mavsdk::rpc::camera_server::TrackPoint* TrackingPointCommandResponse::mutable_track_point() {
  ::mavsdk::rpc::camera_server::TrackPoint* _msg = _internal_mutable_track_point();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.TrackingPointCommandResponse.track_point)
  return _msg;
}
inline void TrackingPointCommandResponse::set_allocated_track_point(::mavsdk::rpc::camera_server::TrackPoint* track_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.track_point_;
  }
  if (track_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(track_point);
    if (message_arena != submessage_arena) {
      track_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.track_point_ = track_point;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.TrackingPointCommandResponse.track_point)
}

// -------------------------------------------------------------------

// SubscribeTrackingRectangleCommandRequest

// -------------------------------------------------------------------

// TrackingRectangleCommandResponse

// .mavsdk.rpc.camera_server.TrackRectangle track_rectangle = 1;
inline bool TrackingRectangleCommandResponse::_internal_has_track_rectangle() const {
  return this != internal_default_instance() && _impl_.track_rectangle_ != nullptr;
}
inline bool TrackingRectangleCommandResponse::has_track_rectangle() const {
  return _internal_has_track_rectangle();
}
inline void TrackingRectangleCommandResponse::clear_track_rectangle() {
  if (GetArenaForAllocation() == nullptr && _impl_.track_rectangle_ != nullptr) {
    delete _impl_.track_rectangle_;
  }
  _impl_.track_rectangle_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::TrackRectangle& TrackingRectangleCommandResponse::_internal_track_rectangle() const {
  const ::mavsdk::rpc::camera_server::TrackRectangle* p = _impl_.track_rectangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::TrackRectangle&>(
      ::mavsdk::rpc::camera_server::_TrackRectangle_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::TrackRectangle& TrackingRectangleCommandResponse::track_rectangle() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse.track_rectangle)
  return _internal_track_rectangle();
}
inline void TrackingRectangleCommandResponse::unsafe_arena_set_allocated_track_rectangle(
    ::mavsdk::rpc::camera_server::TrackRectangle* track_rectangle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_rectangle_);
  }
  _impl_.track_rectangle_ = track_rectangle;
  if (track_rectangle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse.track_rectangle)
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* TrackingRectangleCommandResponse::release_track_rectangle() {
  
  ::mavsdk::rpc::camera_server::TrackRectangle* temp = _impl_.track_rectangle_;
  _impl_.track_rectangle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* TrackingRectangleCommandResponse::unsafe_arena_release_track_rectangle() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse.track_rectangle)
  
  ::mavsdk::rpc::camera_server::TrackRectangle* temp = _impl_.track_rectangle_;
  _impl_.track_rectangle_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* TrackingRectangleCommandResponse::_internal_mutable_track_rectangle() {
  
  if (_impl_.track_rectangle_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::TrackRectangle>(GetArenaForAllocation());
    _impl_.track_rectangle_ = p;
  }
  return _impl_.track_rectangle_;
}
inline ::mavsdk::rpc::camera_server::TrackRectangle* TrackingRectangleCommandResponse::mutable_track_rectangle() {
  ::mavsdk::rpc::camera_server::TrackRectangle* _msg = _internal_mutable_track_rectangle();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse.track_rectangle)
  return _msg;
}
inline void TrackingRectangleCommandResponse::set_allocated_track_rectangle(::mavsdk::rpc::camera_server::TrackRectangle* track_rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.track_rectangle_;
  }
  if (track_rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(track_rectangle);
    if (message_arena != submessage_arena) {
      track_rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track_rectangle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.track_rectangle_ = track_rectangle;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.TrackingRectangleCommandResponse.track_rectangle)
}

// -------------------------------------------------------------------

// SubscribeTrackingOffCommandRequest

// -------------------------------------------------------------------

// TrackingOffCommandResponse

// int32 dummy = 1;
inline void TrackingOffCommandResponse::clear_dummy() {
  _impl_.dummy_ = 0;
}
inline int32_t TrackingOffCommandResponse::_internal_dummy() const {
  return _impl_.dummy_;
}
inline int32_t TrackingOffCommandResponse::dummy() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackingOffCommandResponse.dummy)
  return _internal_dummy();
}
inline void TrackingOffCommandResponse::_internal_set_dummy(int32_t value) {
  
  _impl_.dummy_ = value;
}
inline void TrackingOffCommandResponse::set_dummy(int32_t value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackingOffCommandResponse.dummy)
}

// -------------------------------------------------------------------

// RespondTrackingPointCommandRequest

// .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
inline void RespondTrackingPointCommandRequest::clear_stop_video_feedback() {
  _impl_.stop_video_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingPointCommandRequest::_internal_stop_video_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.stop_video_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingPointCommandRequest::stop_video_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest.stop_video_feedback)
  return _internal_stop_video_feedback();
}
inline void RespondTrackingPointCommandRequest::_internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.stop_video_feedback_ = value;
}
inline void RespondTrackingPointCommandRequest::set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_stop_video_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest.stop_video_feedback)
}

// -------------------------------------------------------------------

// RespondTrackingPointCommandResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondTrackingPointCommandResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondTrackingPointCommandResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondTrackingPointCommandResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingPointCommandResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingPointCommandResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondTrackingPointCommandResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingPointCommandResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingPointCommandResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingPointCommandResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingPointCommandResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse.camera_server_result)
  return _msg;
}
inline void RespondTrackingPointCommandResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse.camera_server_result)
}

// -------------------------------------------------------------------

// RespondTrackingRectangleCommandRequest

// .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
inline void RespondTrackingRectangleCommandRequest::clear_stop_video_feedback() {
  _impl_.stop_video_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingRectangleCommandRequest::_internal_stop_video_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.stop_video_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingRectangleCommandRequest::stop_video_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest.stop_video_feedback)
  return _internal_stop_video_feedback();
}
inline void RespondTrackingRectangleCommandRequest::_internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.stop_video_feedback_ = value;
}
inline void RespondTrackingRectangleCommandRequest::set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_stop_video_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest.stop_video_feedback)
}

// -------------------------------------------------------------------

// RespondTrackingRectangleCommandResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondTrackingRectangleCommandResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondTrackingRectangleCommandResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondTrackingRectangleCommandResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingRectangleCommandResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingRectangleCommandResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondTrackingRectangleCommandResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingRectangleCommandResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingRectangleCommandResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingRectangleCommandResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingRectangleCommandResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse.camera_server_result)
  return _msg;
}
inline void RespondTrackingRectangleCommandResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse.camera_server_result)
}

// -------------------------------------------------------------------

// RespondTrackingOffCommandRequest

// .mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
inline void RespondTrackingOffCommandRequest::clear_stop_video_feedback() {
  _impl_.stop_video_feedback_ = 0;
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingOffCommandRequest::_internal_stop_video_feedback() const {
  return static_cast< ::mavsdk::rpc::camera_server::CameraFeedback >(_impl_.stop_video_feedback_);
}
inline ::mavsdk::rpc::camera_server::CameraFeedback RespondTrackingOffCommandRequest::stop_video_feedback() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest.stop_video_feedback)
  return _internal_stop_video_feedback();
}
inline void RespondTrackingOffCommandRequest::_internal_set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  
  _impl_.stop_video_feedback_ = value;
}
inline void RespondTrackingOffCommandRequest::set_stop_video_feedback(::mavsdk::rpc::camera_server::CameraFeedback value) {
  _internal_set_stop_video_feedback(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest.stop_video_feedback)
}

// -------------------------------------------------------------------

// RespondTrackingOffCommandResponse

// .mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
inline bool RespondTrackingOffCommandResponse::_internal_has_camera_server_result() const {
  return this != internal_default_instance() && _impl_.camera_server_result_ != nullptr;
}
inline bool RespondTrackingOffCommandResponse::has_camera_server_result() const {
  return _internal_has_camera_server_result();
}
inline void RespondTrackingOffCommandResponse::clear_camera_server_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.camera_server_result_ != nullptr) {
    delete _impl_.camera_server_result_;
  }
  _impl_.camera_server_result_ = nullptr;
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingOffCommandResponse::_internal_camera_server_result() const {
  const ::mavsdk::rpc::camera_server::CameraServerResult* p = _impl_.camera_server_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera_server::CameraServerResult&>(
      ::mavsdk::rpc::camera_server::_CameraServerResult_default_instance_);
}
inline const ::mavsdk::rpc::camera_server::CameraServerResult& RespondTrackingOffCommandResponse::camera_server_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse.camera_server_result)
  return _internal_camera_server_result();
}
inline void RespondTrackingOffCommandResponse::unsafe_arena_set_allocated_camera_server_result(
    ::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_server_result_);
  }
  _impl_.camera_server_result_ = camera_server_result;
  if (camera_server_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse.camera_server_result)
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingOffCommandResponse::release_camera_server_result() {
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingOffCommandResponse::unsafe_arena_release_camera_server_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse.camera_server_result)
  
  ::mavsdk::rpc::camera_server::CameraServerResult* temp = _impl_.camera_server_result_;
  _impl_.camera_server_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingOffCommandResponse::_internal_mutable_camera_server_result() {
  
  if (_impl_.camera_server_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera_server::CameraServerResult>(GetArenaForAllocation());
    _impl_.camera_server_result_ = p;
  }
  return _impl_.camera_server_result_;
}
inline ::mavsdk::rpc::camera_server::CameraServerResult* RespondTrackingOffCommandResponse::mutable_camera_server_result() {
  ::mavsdk::rpc::camera_server::CameraServerResult* _msg = _internal_mutable_camera_server_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse.camera_server_result)
  return _msg;
}
inline void RespondTrackingOffCommandResponse::set_allocated_camera_server_result(::mavsdk::rpc::camera_server::CameraServerResult* camera_server_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_server_result_;
  }
  if (camera_server_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_server_result);
    if (message_arena != submessage_arena) {
      camera_server_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_server_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.camera_server_result_ = camera_server_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse.camera_server_result)
}

// -------------------------------------------------------------------

// TrackPoint

// float point_x = 1;
inline void TrackPoint::clear_point_x() {
  _impl_.point_x_ = 0;
}
inline float TrackPoint::_internal_point_x() const {
  return _impl_.point_x_;
}
inline float TrackPoint::point_x() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackPoint.point_x)
  return _internal_point_x();
}
inline void TrackPoint::_internal_set_point_x(float value) {
  
  _impl_.point_x_ = value;
}
inline void TrackPoint::set_point_x(float value) {
  _internal_set_point_x(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackPoint.point_x)
}

// float point_y = 2;
inline void TrackPoint::clear_point_y() {
  _impl_.point_y_ = 0;
}
inline float TrackPoint::_internal_point_y() const {
  return _impl_.point_y_;
}
inline float TrackPoint::point_y() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackPoint.point_y)
  return _internal_point_y();
}
inline void TrackPoint::_internal_set_point_y(float value) {
  
  _impl_.point_y_ = value;
}
inline void TrackPoint::set_point_y(float value) {
  _internal_set_point_y(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackPoint.point_y)
}

// float radius = 3;
inline void TrackPoint::clear_radius() {
  _impl_.radius_ = 0;
}
inline float TrackPoint::_internal_radius() const {
  return _impl_.radius_;
}
inline float TrackPoint::radius() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackPoint.radius)
  return _internal_radius();
}
inline void TrackPoint::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void TrackPoint::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackPoint.radius)
}

// -------------------------------------------------------------------

// TrackRectangle

// float top_left_corner_x = 1;
inline void TrackRectangle::clear_top_left_corner_x() {
  _impl_.top_left_corner_x_ = 0;
}
inline float TrackRectangle::_internal_top_left_corner_x() const {
  return _impl_.top_left_corner_x_;
}
inline float TrackRectangle::top_left_corner_x() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackRectangle.top_left_corner_x)
  return _internal_top_left_corner_x();
}
inline void TrackRectangle::_internal_set_top_left_corner_x(float value) {
  
  _impl_.top_left_corner_x_ = value;
}
inline void TrackRectangle::set_top_left_corner_x(float value) {
  _internal_set_top_left_corner_x(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackRectangle.top_left_corner_x)
}

// float top_left_corner_y = 2;
inline void TrackRectangle::clear_top_left_corner_y() {
  _impl_.top_left_corner_y_ = 0;
}
inline float TrackRectangle::_internal_top_left_corner_y() const {
  return _impl_.top_left_corner_y_;
}
inline float TrackRectangle::top_left_corner_y() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackRectangle.top_left_corner_y)
  return _internal_top_left_corner_y();
}
inline void TrackRectangle::_internal_set_top_left_corner_y(float value) {
  
  _impl_.top_left_corner_y_ = value;
}
inline void TrackRectangle::set_top_left_corner_y(float value) {
  _internal_set_top_left_corner_y(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackRectangle.top_left_corner_y)
}

// float bottom_right_corner_x = 3;
inline void TrackRectangle::clear_bottom_right_corner_x() {
  _impl_.bottom_right_corner_x_ = 0;
}
inline float TrackRectangle::_internal_bottom_right_corner_x() const {
  return _impl_.bottom_right_corner_x_;
}
inline float TrackRectangle::bottom_right_corner_x() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackRectangle.bottom_right_corner_x)
  return _internal_bottom_right_corner_x();
}
inline void TrackRectangle::_internal_set_bottom_right_corner_x(float value) {
  
  _impl_.bottom_right_corner_x_ = value;
}
inline void TrackRectangle::set_bottom_right_corner_x(float value) {
  _internal_set_bottom_right_corner_x(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackRectangle.bottom_right_corner_x)
}

// float bottom_right_corner_y = 4;
inline void TrackRectangle::clear_bottom_right_corner_y() {
  _impl_.bottom_right_corner_y_ = 0;
}
inline float TrackRectangle::_internal_bottom_right_corner_y() const {
  return _impl_.bottom_right_corner_y_;
}
inline float TrackRectangle::bottom_right_corner_y() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera_server.TrackRectangle.bottom_right_corner_y)
  return _internal_bottom_right_corner_y();
}
inline void TrackRectangle::_internal_set_bottom_right_corner_y(float value) {
  
  _impl_.bottom_right_corner_y_ = value;
}
inline void TrackRectangle::set_bottom_right_corner_y(float value) {
  _internal_set_bottom_right_corner_y(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera_server.TrackRectangle.bottom_right_corner_y)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace camera_server
}  // namespace rpc
}  // namespace mavsdk

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::CameraServerResult_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::CameraServerResult_Result>() {
  return ::mavsdk::rpc::camera_server::CameraServerResult_Result_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus>() {
  return ::mavsdk::rpc::camera_server::StorageInformation_StorageStatus_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::StorageInformation_StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::StorageInformation_StorageType>() {
  return ::mavsdk::rpc::camera_server::StorageInformation_StorageType_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus>() {
  return ::mavsdk::rpc::camera_server::CaptureStatus_ImageStatus_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus>() {
  return ::mavsdk::rpc::camera_server::CaptureStatus_VideoStatus_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::CameraFeedback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::CameraFeedback>() {
  return ::mavsdk::rpc::camera_server::CameraFeedback_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::camera_server::Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::camera_server::Mode>() {
  return ::mavsdk::rpc::camera_server::Mode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_camera_5fserver_2fcamera_5fserver_2eproto
