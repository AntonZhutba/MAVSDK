// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: events/events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_events_2fevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_events_2fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mavsdk_options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_events_2fevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2fevents_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_events_2fevents_2eproto;
namespace mavsdk {
namespace rpc {
namespace events {
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventsResponse;
struct EventsResponseDefaultTypeInternal;
extern EventsResponseDefaultTypeInternal _EventsResponse_default_instance_;
class EventsResult;
struct EventsResultDefaultTypeInternal;
extern EventsResultDefaultTypeInternal _EventsResult_default_instance_;
class GetHealthAndArmingChecksReportRequest;
struct GetHealthAndArmingChecksReportRequestDefaultTypeInternal;
extern GetHealthAndArmingChecksReportRequestDefaultTypeInternal _GetHealthAndArmingChecksReportRequest_default_instance_;
class GetHealthAndArmingChecksReportResponse;
struct GetHealthAndArmingChecksReportResponseDefaultTypeInternal;
extern GetHealthAndArmingChecksReportResponseDefaultTypeInternal _GetHealthAndArmingChecksReportResponse_default_instance_;
class HealthAndArmingCheckMode;
struct HealthAndArmingCheckModeDefaultTypeInternal;
extern HealthAndArmingCheckModeDefaultTypeInternal _HealthAndArmingCheckMode_default_instance_;
class HealthAndArmingCheckProblem;
struct HealthAndArmingCheckProblemDefaultTypeInternal;
extern HealthAndArmingCheckProblemDefaultTypeInternal _HealthAndArmingCheckProblem_default_instance_;
class HealthAndArmingCheckReport;
struct HealthAndArmingCheckReportDefaultTypeInternal;
extern HealthAndArmingCheckReportDefaultTypeInternal _HealthAndArmingCheckReport_default_instance_;
class HealthAndArmingChecksResponse;
struct HealthAndArmingChecksResponseDefaultTypeInternal;
extern HealthAndArmingChecksResponseDefaultTypeInternal _HealthAndArmingChecksResponse_default_instance_;
class HealthComponentReport;
struct HealthComponentReportDefaultTypeInternal;
extern HealthComponentReportDefaultTypeInternal _HealthComponentReport_default_instance_;
class SubscribeEventsRequest;
struct SubscribeEventsRequestDefaultTypeInternal;
extern SubscribeEventsRequestDefaultTypeInternal _SubscribeEventsRequest_default_instance_;
class SubscribeHealthAndArmingChecksRequest;
struct SubscribeHealthAndArmingChecksRequestDefaultTypeInternal;
extern SubscribeHealthAndArmingChecksRequestDefaultTypeInternal _SubscribeHealthAndArmingChecksRequest_default_instance_;
}  // namespace events
}  // namespace rpc
}  // namespace mavsdk
PROTOBUF_NAMESPACE_OPEN
template<> ::mavsdk::rpc::events::Event* Arena::CreateMaybeMessage<::mavsdk::rpc::events::Event>(Arena*);
template<> ::mavsdk::rpc::events::EventsResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::events::EventsResponse>(Arena*);
template<> ::mavsdk::rpc::events::EventsResult* Arena::CreateMaybeMessage<::mavsdk::rpc::events::EventsResult>(Arena*);
template<> ::mavsdk::rpc::events::GetHealthAndArmingChecksReportRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::events::GetHealthAndArmingChecksReportRequest>(Arena*);
template<> ::mavsdk::rpc::events::GetHealthAndArmingChecksReportResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::events::GetHealthAndArmingChecksReportResponse>(Arena*);
template<> ::mavsdk::rpc::events::HealthAndArmingCheckMode* Arena::CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckMode>(Arena*);
template<> ::mavsdk::rpc::events::HealthAndArmingCheckProblem* Arena::CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckProblem>(Arena*);
template<> ::mavsdk::rpc::events::HealthAndArmingCheckReport* Arena::CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckReport>(Arena*);
template<> ::mavsdk::rpc::events::HealthAndArmingChecksResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingChecksResponse>(Arena*);
template<> ::mavsdk::rpc::events::HealthComponentReport* Arena::CreateMaybeMessage<::mavsdk::rpc::events::HealthComponentReport>(Arena*);
template<> ::mavsdk::rpc::events::SubscribeEventsRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::events::SubscribeEventsRequest>(Arena*);
template<> ::mavsdk::rpc::events::SubscribeHealthAndArmingChecksRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::events::SubscribeHealthAndArmingChecksRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mavsdk {
namespace rpc {
namespace events {

enum EventsResult_Result : int {
  EventsResult_Result_RESULT_SUCCESS = 0,
  EventsResult_Result_RESULT_NOT_AVAILABLE = 1,
  EventsResult_Result_RESULT_CONNECTION_ERROR = 2,
  EventsResult_Result_RESULT_UNSUPPORTED = 3,
  EventsResult_Result_RESULT_DENIED = 4,
  EventsResult_Result_RESULT_FAILED = 5,
  EventsResult_Result_RESULT_TIMEOUT = 6,
  EventsResult_Result_RESULT_NO_SYSTEM = 7,
  EventsResult_Result_RESULT_UNKNOWN = 8,
  EventsResult_Result_EventsResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventsResult_Result_EventsResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventsResult_Result_IsValid(int value);
constexpr EventsResult_Result EventsResult_Result_Result_MIN = EventsResult_Result_RESULT_SUCCESS;
constexpr EventsResult_Result EventsResult_Result_Result_MAX = EventsResult_Result_RESULT_UNKNOWN;
constexpr int EventsResult_Result_Result_ARRAYSIZE = EventsResult_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventsResult_Result_descriptor();
template<typename T>
inline const std::string& EventsResult_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventsResult_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventsResult_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventsResult_Result_descriptor(), enum_t_value);
}
inline bool EventsResult_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventsResult_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventsResult_Result>(
    EventsResult_Result_descriptor(), name, value);
}
enum LogLevel : int {
  LOG_LEVEL_EMERGENCY = 0,
  LOG_LEVEL_ALERT = 1,
  LOG_LEVEL_CRITICAL = 2,
  LOG_LEVEL_ERROR = 3,
  LOG_LEVEL_WARNING = 4,
  LOG_LEVEL_NOTICE = 5,
  LOG_LEVEL_INFO = 6,
  LOG_LEVEL_DEBUG = 7,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LOG_LEVEL_EMERGENCY;
constexpr LogLevel LogLevel_MAX = LOG_LEVEL_DEBUG;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kEventNamespaceFieldNumber = 5,
    kEventNameFieldNumber = 6,
    kCompidFieldNumber = 1,
    kLogLevelFieldNumber = 4,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string event_namespace = 5;
  void clear_event_namespace();
  const std::string& event_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_namespace();
  PROTOBUF_NODISCARD std::string* release_event_namespace();
  void set_allocated_event_namespace(std::string* event_namespace);
  private:
  const std::string& _internal_event_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_namespace(const std::string& value);
  std::string* _internal_mutable_event_namespace();
  public:

  // string event_name = 6;
  void clear_event_name();
  const std::string& event_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_name();
  PROTOBUF_NODISCARD std::string* release_event_name();
  void set_allocated_event_name(std::string* event_name);
  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(const std::string& value);
  std::string* _internal_mutable_event_name();
  public:

  // uint32 compid = 1;
  void clear_compid();
  uint32_t compid() const;
  void set_compid(uint32_t value);
  private:
  uint32_t _internal_compid() const;
  void _internal_set_compid(uint32_t value);
  public:

  // .mavsdk.rpc.events.LogLevel log_level = 4;
  void clear_log_level();
  ::mavsdk::rpc::events::LogLevel log_level() const;
  void set_log_level(::mavsdk::rpc::events::LogLevel value);
  private:
  ::mavsdk::rpc::events::LogLevel _internal_log_level() const;
  void _internal_set_log_level(::mavsdk::rpc::events::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_name_;
    uint32_t compid_;
    int log_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckProblem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckProblem) */ {
 public:
  inline HealthAndArmingCheckProblem() : HealthAndArmingCheckProblem(nullptr) {}
  ~HealthAndArmingCheckProblem() override;
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckProblem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthAndArmingCheckProblem(const HealthAndArmingCheckProblem& from);
  HealthAndArmingCheckProblem(HealthAndArmingCheckProblem&& from) noexcept
    : HealthAndArmingCheckProblem() {
    *this = ::std::move(from);
  }

  inline HealthAndArmingCheckProblem& operator=(const HealthAndArmingCheckProblem& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckProblem& operator=(HealthAndArmingCheckProblem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckProblem& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckProblem* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckProblem*>(
               &_HealthAndArmingCheckProblem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HealthAndArmingCheckProblem& a, HealthAndArmingCheckProblem& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthAndArmingCheckProblem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckProblem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckProblem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthAndArmingCheckProblem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckProblem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthAndArmingCheckProblem& from) {
    HealthAndArmingCheckProblem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthAndArmingCheckProblem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.HealthAndArmingCheckProblem";
  }
  protected:
  explicit HealthAndArmingCheckProblem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kHealthComponentFieldNumber = 4,
    kLogLevelFieldNumber = 3,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string health_component = 4;
  void clear_health_component();
  const std::string& health_component() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_health_component(ArgT0&& arg0, ArgT... args);
  std::string* mutable_health_component();
  PROTOBUF_NODISCARD std::string* release_health_component();
  void set_allocated_health_component(std::string* health_component);
  private:
  const std::string& _internal_health_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_health_component(const std::string& value);
  std::string* _internal_mutable_health_component();
  public:

  // .mavsdk.rpc.events.LogLevel log_level = 3;
  void clear_log_level();
  ::mavsdk::rpc::events::LogLevel log_level() const;
  void set_log_level(::mavsdk::rpc::events::LogLevel value);
  private:
  ::mavsdk::rpc::events::LogLevel _internal_log_level() const;
  void _internal_set_log_level(::mavsdk::rpc::events::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckProblem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr health_component_;
    int log_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckMode) */ {
 public:
  inline HealthAndArmingCheckMode() : HealthAndArmingCheckMode(nullptr) {}
  ~HealthAndArmingCheckMode() override;
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthAndArmingCheckMode(const HealthAndArmingCheckMode& from);
  HealthAndArmingCheckMode(HealthAndArmingCheckMode&& from) noexcept
    : HealthAndArmingCheckMode() {
    *this = ::std::move(from);
  }

  inline HealthAndArmingCheckMode& operator=(const HealthAndArmingCheckMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckMode& operator=(HealthAndArmingCheckMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckMode* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckMode*>(
               &_HealthAndArmingCheckMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HealthAndArmingCheckMode& a, HealthAndArmingCheckMode& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthAndArmingCheckMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthAndArmingCheckMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthAndArmingCheckMode& from) {
    HealthAndArmingCheckMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthAndArmingCheckMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.HealthAndArmingCheckMode";
  }
  protected:
  explicit HealthAndArmingCheckMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProblemsFieldNumber = 3,
    kModeNameFieldNumber = 1,
    kCanArmOrRunFieldNumber = 2,
  };
  // repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3;
  int problems_size() const;
  private:
  int _internal_problems_size() const;
  public:
  void clear_problems();
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* mutable_problems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >*
      mutable_problems();
  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& _internal_problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _internal_add_problems();
  public:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* add_problems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >&
      problems() const;

  // string mode_name = 1;
  void clear_mode_name();
  const std::string& mode_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode_name();
  PROTOBUF_NODISCARD std::string* release_mode_name();
  void set_allocated_mode_name(std::string* mode_name);
  private:
  const std::string& _internal_mode_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode_name(const std::string& value);
  std::string* _internal_mutable_mode_name();
  public:

  // bool can_arm_or_run = 2;
  void clear_can_arm_or_run();
  bool can_arm_or_run() const;
  void set_can_arm_or_run(bool value);
  private:
  bool _internal_can_arm_or_run() const;
  void _internal_set_can_arm_or_run(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem > problems_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_name_;
    bool can_arm_or_run_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthComponentReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthComponentReport) */ {
 public:
  inline HealthComponentReport() : HealthComponentReport(nullptr) {}
  ~HealthComponentReport() override;
  explicit PROTOBUF_CONSTEXPR HealthComponentReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthComponentReport(const HealthComponentReport& from);
  HealthComponentReport(HealthComponentReport&& from) noexcept
    : HealthComponentReport() {
    *this = ::std::move(from);
  }

  inline HealthComponentReport& operator=(const HealthComponentReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthComponentReport& operator=(HealthComponentReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthComponentReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthComponentReport* internal_default_instance() {
    return reinterpret_cast<const HealthComponentReport*>(
               &_HealthComponentReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HealthComponentReport& a, HealthComponentReport& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthComponentReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthComponentReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthComponentReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthComponentReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthComponentReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthComponentReport& from) {
    HealthComponentReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthComponentReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.HealthComponentReport";
  }
  protected:
  explicit HealthComponentReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLabelFieldNumber = 2,
    kIsPresentFieldNumber = 3,
    kHasErrorFieldNumber = 4,
    kHasWarningFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // bool is_present = 3;
  void clear_is_present();
  bool is_present() const;
  void set_is_present(bool value);
  private:
  bool _internal_is_present() const;
  void _internal_set_is_present(bool value);
  public:

  // bool has_error = 4;
  void clear_has_error();
  bool has_error() const;
  void set_has_error(bool value);
  private:
  bool _internal_has_error() const;
  void _internal_set_has_error(bool value);
  public:

  // bool has_warning = 5;
  void clear_has_warning();
  bool has_warning() const;
  void set_has_warning(bool value);
  private:
  bool _internal_has_warning() const;
  void _internal_set_has_warning(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthComponentReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    bool is_present_;
    bool has_error_;
    bool has_warning_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckReport) */ {
 public:
  inline HealthAndArmingCheckReport() : HealthAndArmingCheckReport(nullptr) {}
  ~HealthAndArmingCheckReport() override;
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthAndArmingCheckReport(const HealthAndArmingCheckReport& from);
  HealthAndArmingCheckReport(HealthAndArmingCheckReport&& from) noexcept
    : HealthAndArmingCheckReport() {
    *this = ::std::move(from);
  }

  inline HealthAndArmingCheckReport& operator=(const HealthAndArmingCheckReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckReport& operator=(HealthAndArmingCheckReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckReport* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckReport*>(
               &_HealthAndArmingCheckReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HealthAndArmingCheckReport& a, HealthAndArmingCheckReport& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthAndArmingCheckReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthAndArmingCheckReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthAndArmingCheckReport& from) {
    HealthAndArmingCheckReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthAndArmingCheckReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.HealthAndArmingCheckReport";
  }
  protected:
  explicit HealthAndArmingCheckReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHealthComponentsFieldNumber = 2,
    kAllProblemsFieldNumber = 3,
    kCurrentModeIntentionFieldNumber = 1,
  };
  // repeated .mavsdk.rpc.events.HealthComponentReport health_components = 2;
  int health_components_size() const;
  private:
  int _internal_health_components_size() const;
  public:
  void clear_health_components();
  ::mavsdk::rpc::events::HealthComponentReport* mutable_health_components(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport >*
      mutable_health_components();
  private:
  const ::mavsdk::rpc::events::HealthComponentReport& _internal_health_components(int index) const;
  ::mavsdk::rpc::events::HealthComponentReport* _internal_add_health_components();
  public:
  const ::mavsdk::rpc::events::HealthComponentReport& health_components(int index) const;
  ::mavsdk::rpc::events::HealthComponentReport* add_health_components();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport >&
      health_components() const;

  // repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3;
  int all_problems_size() const;
  private:
  int _internal_all_problems_size() const;
  public:
  void clear_all_problems();
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* mutable_all_problems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >*
      mutable_all_problems();
  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& _internal_all_problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _internal_add_all_problems();
  public:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& all_problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* add_all_problems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >&
      all_problems() const;

  // .mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1;
  bool has_current_mode_intention() const;
  private:
  bool _internal_has_current_mode_intention() const;
  public:
  void clear_current_mode_intention();
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode& current_mode_intention() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckMode* release_current_mode_intention();
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* mutable_current_mode_intention();
  void set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention);
  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode& _internal_current_mode_intention() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* _internal_mutable_current_mode_intention();
  public:
  void unsafe_arena_set_allocated_current_mode_intention(
      ::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention);
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* unsafe_arena_release_current_mode_intention();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport > health_components_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem > all_problems_;
    ::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class EventsResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.EventsResult) */ {
 public:
  inline EventsResult() : EventsResult(nullptr) {}
  ~EventsResult() override;
  explicit PROTOBUF_CONSTEXPR EventsResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResult(const EventsResult& from);
  EventsResult(EventsResult&& from) noexcept
    : EventsResult() {
    *this = ::std::move(from);
  }

  inline EventsResult& operator=(const EventsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResult& operator=(EventsResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResult* internal_default_instance() {
    return reinterpret_cast<const EventsResult*>(
               &_EventsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventsResult& a, EventsResult& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventsResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventsResult& from) {
    EventsResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.EventsResult";
  }
  protected:
  explicit EventsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EventsResult_Result Result;
  static constexpr Result RESULT_SUCCESS =
    EventsResult_Result_RESULT_SUCCESS;
  static constexpr Result RESULT_NOT_AVAILABLE =
    EventsResult_Result_RESULT_NOT_AVAILABLE;
  static constexpr Result RESULT_CONNECTION_ERROR =
    EventsResult_Result_RESULT_CONNECTION_ERROR;
  static constexpr Result RESULT_UNSUPPORTED =
    EventsResult_Result_RESULT_UNSUPPORTED;
  static constexpr Result RESULT_DENIED =
    EventsResult_Result_RESULT_DENIED;
  static constexpr Result RESULT_FAILED =
    EventsResult_Result_RESULT_FAILED;
  static constexpr Result RESULT_TIMEOUT =
    EventsResult_Result_RESULT_TIMEOUT;
  static constexpr Result RESULT_NO_SYSTEM =
    EventsResult_Result_RESULT_NO_SYSTEM;
  static constexpr Result RESULT_UNKNOWN =
    EventsResult_Result_RESULT_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return EventsResult_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    EventsResult_Result_Result_MIN;
  static constexpr Result Result_MAX =
    EventsResult_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    EventsResult_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return EventsResult_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return EventsResult_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return EventsResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultStrFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string result_str = 2;
  void clear_result_str();
  const std::string& result_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_str();
  PROTOBUF_NODISCARD std::string* release_result_str();
  void set_allocated_result_str(std::string* result_str);
  private:
  const std::string& _internal_result_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_str(const std::string& value);
  std::string* _internal_mutable_result_str();
  public:

  // .mavsdk.rpc.events.EventsResult.Result result = 1;
  void clear_result();
  ::mavsdk::rpc::events::EventsResult_Result result() const;
  void set_result(::mavsdk::rpc::events::EventsResult_Result value);
  private:
  ::mavsdk::rpc::events::EventsResult_Result _internal_result() const;
  void _internal_set_result(::mavsdk::rpc::events::EventsResult_Result value);
  public:

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.EventsResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_str_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SubscribeEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.SubscribeEventsRequest) */ {
 public:
  inline SubscribeEventsRequest() : SubscribeEventsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeEventsRequest(const SubscribeEventsRequest& from);
  SubscribeEventsRequest(SubscribeEventsRequest&& from) noexcept
    : SubscribeEventsRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeEventsRequest& operator=(const SubscribeEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeEventsRequest& operator=(SubscribeEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeEventsRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeEventsRequest*>(
               &_SubscribeEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SubscribeEventsRequest& a, SubscribeEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeEventsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeEventsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.SubscribeEventsRequest";
  }
  protected:
  explicit SubscribeEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.SubscribeEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.EventsResponse) */ {
 public:
  inline EventsResponse() : EventsResponse(nullptr) {}
  ~EventsResponse() override;
  explicit PROTOBUF_CONSTEXPR EventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResponse(const EventsResponse& from);
  EventsResponse(EventsResponse&& from) noexcept
    : EventsResponse() {
    *this = ::std::move(from);
  }

  inline EventsResponse& operator=(const EventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse& operator=(EventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse* internal_default_instance() {
    return reinterpret_cast<const EventsResponse*>(
               &_EventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EventsResponse& a, EventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventsResponse& from) {
    EventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.EventsResponse";
  }
  protected:
  explicit EventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .mavsdk.rpc.events.Event event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::mavsdk::rpc::events::Event& event() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::Event* release_event();
  ::mavsdk::rpc::events::Event* mutable_event();
  void set_allocated_event(::mavsdk::rpc::events::Event* event);
  private:
  const ::mavsdk::rpc::events::Event& _internal_event() const;
  ::mavsdk::rpc::events::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::mavsdk::rpc::events::Event* event);
  ::mavsdk::rpc::events::Event* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.EventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::events::Event* event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SubscribeHealthAndArmingChecksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest) */ {
 public:
  inline SubscribeHealthAndArmingChecksRequest() : SubscribeHealthAndArmingChecksRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeHealthAndArmingChecksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeHealthAndArmingChecksRequest(const SubscribeHealthAndArmingChecksRequest& from);
  SubscribeHealthAndArmingChecksRequest(SubscribeHealthAndArmingChecksRequest&& from) noexcept
    : SubscribeHealthAndArmingChecksRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeHealthAndArmingChecksRequest& operator=(const SubscribeHealthAndArmingChecksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeHealthAndArmingChecksRequest& operator=(SubscribeHealthAndArmingChecksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeHealthAndArmingChecksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeHealthAndArmingChecksRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeHealthAndArmingChecksRequest*>(
               &_SubscribeHealthAndArmingChecksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SubscribeHealthAndArmingChecksRequest& a, SubscribeHealthAndArmingChecksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeHealthAndArmingChecksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeHealthAndArmingChecksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeHealthAndArmingChecksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeHealthAndArmingChecksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeHealthAndArmingChecksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeHealthAndArmingChecksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest";
  }
  protected:
  explicit SubscribeHealthAndArmingChecksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingChecksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingChecksResponse) */ {
 public:
  inline HealthAndArmingChecksResponse() : HealthAndArmingChecksResponse(nullptr) {}
  ~HealthAndArmingChecksResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthAndArmingChecksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthAndArmingChecksResponse(const HealthAndArmingChecksResponse& from);
  HealthAndArmingChecksResponse(HealthAndArmingChecksResponse&& from) noexcept
    : HealthAndArmingChecksResponse() {
    *this = ::std::move(from);
  }

  inline HealthAndArmingChecksResponse& operator=(const HealthAndArmingChecksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingChecksResponse& operator=(HealthAndArmingChecksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingChecksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingChecksResponse* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingChecksResponse*>(
               &_HealthAndArmingChecksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HealthAndArmingChecksResponse& a, HealthAndArmingChecksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthAndArmingChecksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingChecksResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingChecksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthAndArmingChecksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingChecksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthAndArmingChecksResponse& from) {
    HealthAndArmingChecksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthAndArmingChecksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.HealthAndArmingChecksResponse";
  }
  protected:
  explicit HealthAndArmingChecksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportFieldNumber = 1,
  };
  // .mavsdk.rpc.events.HealthAndArmingCheckReport report = 1;
  bool has_report() const;
  private:
  bool _internal_has_report() const;
  public:
  void clear_report();
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& report() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckReport* release_report();
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* mutable_report();
  void set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* report);
  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& _internal_report() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _internal_mutable_report();
  public:
  void unsafe_arena_set_allocated_report(
      ::mavsdk::rpc::events::HealthAndArmingCheckReport* report);
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* unsafe_arena_release_report();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingChecksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class GetHealthAndArmingChecksReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest) */ {
 public:
  inline GetHealthAndArmingChecksReportRequest() : GetHealthAndArmingChecksReportRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetHealthAndArmingChecksReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHealthAndArmingChecksReportRequest(const GetHealthAndArmingChecksReportRequest& from);
  GetHealthAndArmingChecksReportRequest(GetHealthAndArmingChecksReportRequest&& from) noexcept
    : GetHealthAndArmingChecksReportRequest() {
    *this = ::std::move(from);
  }

  inline GetHealthAndArmingChecksReportRequest& operator=(const GetHealthAndArmingChecksReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthAndArmingChecksReportRequest& operator=(GetHealthAndArmingChecksReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthAndArmingChecksReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthAndArmingChecksReportRequest* internal_default_instance() {
    return reinterpret_cast<const GetHealthAndArmingChecksReportRequest*>(
               &_GetHealthAndArmingChecksReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetHealthAndArmingChecksReportRequest& a, GetHealthAndArmingChecksReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHealthAndArmingChecksReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthAndArmingChecksReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthAndArmingChecksReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHealthAndArmingChecksReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetHealthAndArmingChecksReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetHealthAndArmingChecksReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest";
  }
  protected:
  explicit GetHealthAndArmingChecksReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class GetHealthAndArmingChecksReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse) */ {
 public:
  inline GetHealthAndArmingChecksReportResponse() : GetHealthAndArmingChecksReportResponse(nullptr) {}
  ~GetHealthAndArmingChecksReportResponse() override;
  explicit PROTOBUF_CONSTEXPR GetHealthAndArmingChecksReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHealthAndArmingChecksReportResponse(const GetHealthAndArmingChecksReportResponse& from);
  GetHealthAndArmingChecksReportResponse(GetHealthAndArmingChecksReportResponse&& from) noexcept
    : GetHealthAndArmingChecksReportResponse() {
    *this = ::std::move(from);
  }

  inline GetHealthAndArmingChecksReportResponse& operator=(const GetHealthAndArmingChecksReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthAndArmingChecksReportResponse& operator=(GetHealthAndArmingChecksReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthAndArmingChecksReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthAndArmingChecksReportResponse* internal_default_instance() {
    return reinterpret_cast<const GetHealthAndArmingChecksReportResponse*>(
               &_GetHealthAndArmingChecksReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetHealthAndArmingChecksReportResponse& a, GetHealthAndArmingChecksReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHealthAndArmingChecksReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthAndArmingChecksReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthAndArmingChecksReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHealthAndArmingChecksReportResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHealthAndArmingChecksReportResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHealthAndArmingChecksReportResponse& from) {
    GetHealthAndArmingChecksReportResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHealthAndArmingChecksReportResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse";
  }
  protected:
  explicit GetHealthAndArmingChecksReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsResultFieldNumber = 1,
    kReportFieldNumber = 2,
  };
  // .mavsdk.rpc.events.EventsResult events_result = 1;
  bool has_events_result() const;
  private:
  bool _internal_has_events_result() const;
  public:
  void clear_events_result();
  const ::mavsdk::rpc::events::EventsResult& events_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::EventsResult* release_events_result();
  ::mavsdk::rpc::events::EventsResult* mutable_events_result();
  void set_allocated_events_result(::mavsdk::rpc::events::EventsResult* events_result);
  private:
  const ::mavsdk::rpc::events::EventsResult& _internal_events_result() const;
  ::mavsdk::rpc::events::EventsResult* _internal_mutable_events_result();
  public:
  void unsafe_arena_set_allocated_events_result(
      ::mavsdk::rpc::events::EventsResult* events_result);
  ::mavsdk::rpc::events::EventsResult* unsafe_arena_release_events_result();

  // .mavsdk.rpc.events.HealthAndArmingCheckReport report = 2;
  bool has_report() const;
  private:
  bool _internal_has_report() const;
  public:
  void clear_report();
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& report() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckReport* release_report();
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* mutable_report();
  void set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* report);
  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& _internal_report() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _internal_mutable_report();
  public:
  void unsafe_arena_set_allocated_report(
      ::mavsdk::rpc::events::HealthAndArmingCheckReport* report);
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* unsafe_arena_release_report();

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mavsdk::rpc::events::EventsResult* events_result_;
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// uint32 compid = 1;
inline void Event::clear_compid() {
  _impl_.compid_ = 0u;
}
inline uint32_t Event::_internal_compid() const {
  return _impl_.compid_;
}
inline uint32_t Event::compid() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.compid)
  return _internal_compid();
}
inline void Event::_internal_set_compid(uint32_t value) {
  
  _impl_.compid_ = value;
}
inline void Event::set_compid(uint32_t value) {
  _internal_set_compid(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.compid)
}

// string message = 2;
inline void Event::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Event::message() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.message)
}
inline std::string* Event::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.message)
  return _s;
}
inline const std::string& Event::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Event::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_message() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.message)
  return _impl_.message_.Release();
}
inline void Event::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.message)
}

// string description = 3;
inline void Event::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Event::description() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.description)
}
inline std::string* Event::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.description)
  return _s;
}
inline const std::string& Event::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Event::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_description() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.description)
  return _impl_.description_.Release();
}
inline void Event::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.description)
}

// .mavsdk.rpc.events.LogLevel log_level = 4;
inline void Event::clear_log_level() {
  _impl_.log_level_ = 0;
}
inline ::mavsdk::rpc::events::LogLevel Event::_internal_log_level() const {
  return static_cast< ::mavsdk::rpc::events::LogLevel >(_impl_.log_level_);
}
inline ::mavsdk::rpc::events::LogLevel Event::log_level() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.log_level)
  return _internal_log_level();
}
inline void Event::_internal_set_log_level(::mavsdk::rpc::events::LogLevel value) {
  
  _impl_.log_level_ = value;
}
inline void Event::set_log_level(::mavsdk::rpc::events::LogLevel value) {
  _internal_set_log_level(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.log_level)
}

// string event_namespace = 5;
inline void Event::clear_event_namespace() {
  _impl_.event_namespace_.ClearToEmpty();
}
inline const std::string& Event::event_namespace() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.event_namespace)
  return _internal_event_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_event_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.event_namespace)
}
inline std::string* Event::mutable_event_namespace() {
  std::string* _s = _internal_mutable_event_namespace();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.event_namespace)
  return _s;
}
inline const std::string& Event::_internal_event_namespace() const {
  return _impl_.event_namespace_.Get();
}
inline void Event::_internal_set_event_namespace(const std::string& value) {
  
  _impl_.event_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_event_namespace() {
  
  return _impl_.event_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_event_namespace() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.event_namespace)
  return _impl_.event_namespace_.Release();
}
inline void Event::set_allocated_event_namespace(std::string* event_namespace) {
  if (event_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.event_namespace_.SetAllocated(event_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_namespace_.IsDefault()) {
    _impl_.event_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.event_namespace)
}

// string event_name = 6;
inline void Event::clear_event_name() {
  _impl_.event_name_.ClearToEmpty();
}
inline const std::string& Event::event_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.event_name)
  return _internal_event_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_event_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.event_name)
}
inline std::string* Event::mutable_event_name() {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.event_name)
  return _s;
}
inline const std::string& Event::_internal_event_name() const {
  return _impl_.event_name_.Get();
}
inline void Event::_internal_set_event_name(const std::string& value) {
  
  _impl_.event_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_event_name() {
  
  return _impl_.event_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_event_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.event_name)
  return _impl_.event_name_.Release();
}
inline void Event::set_allocated_event_name(std::string* event_name) {
  if (event_name != nullptr) {
    
  } else {
    
  }
  _impl_.event_name_.SetAllocated(event_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_name_.IsDefault()) {
    _impl_.event_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.event_name)
}

// -------------------------------------------------------------------

// HealthAndArmingCheckProblem

// string message = 1;
inline void HealthAndArmingCheckProblem::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::message() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthAndArmingCheckProblem::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
}
inline std::string* HealthAndArmingCheckProblem::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::release_message() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _impl_.message_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
}

// string description = 2;
inline void HealthAndArmingCheckProblem::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::description() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthAndArmingCheckProblem::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
}
inline std::string* HealthAndArmingCheckProblem::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_description() const {
  return _impl_.description_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::release_description() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _impl_.description_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
}

// .mavsdk.rpc.events.LogLevel log_level = 3;
inline void HealthAndArmingCheckProblem::clear_log_level() {
  _impl_.log_level_ = 0;
}
inline ::mavsdk::rpc::events::LogLevel HealthAndArmingCheckProblem::_internal_log_level() const {
  return static_cast< ::mavsdk::rpc::events::LogLevel >(_impl_.log_level_);
}
inline ::mavsdk::rpc::events::LogLevel HealthAndArmingCheckProblem::log_level() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.log_level)
  return _internal_log_level();
}
inline void HealthAndArmingCheckProblem::_internal_set_log_level(::mavsdk::rpc::events::LogLevel value) {
  
  _impl_.log_level_ = value;
}
inline void HealthAndArmingCheckProblem::set_log_level(::mavsdk::rpc::events::LogLevel value) {
  _internal_set_log_level(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.log_level)
}

// string health_component = 4;
inline void HealthAndArmingCheckProblem::clear_health_component() {
  _impl_.health_component_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::health_component() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _internal_health_component();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthAndArmingCheckProblem::set_health_component(ArgT0&& arg0, ArgT... args) {
 
 _impl_.health_component_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
}
inline std::string* HealthAndArmingCheckProblem::mutable_health_component() {
  std::string* _s = _internal_mutable_health_component();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_health_component() const {
  return _impl_.health_component_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_health_component(const std::string& value) {
  
  _impl_.health_component_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_health_component() {
  
  return _impl_.health_component_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckProblem::release_health_component() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _impl_.health_component_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_health_component(std::string* health_component) {
  if (health_component != nullptr) {
    
  } else {
    
  }
  _impl_.health_component_.SetAllocated(health_component, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.health_component_.IsDefault()) {
    _impl_.health_component_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
}

// -------------------------------------------------------------------

// HealthAndArmingCheckMode

// string mode_name = 1;
inline void HealthAndArmingCheckMode::clear_mode_name() {
  _impl_.mode_name_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckMode::mode_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _internal_mode_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthAndArmingCheckMode::set_mode_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
}
inline std::string* HealthAndArmingCheckMode::mutable_mode_name() {
  std::string* _s = _internal_mutable_mode_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _s;
}
inline const std::string& HealthAndArmingCheckMode::_internal_mode_name() const {
  return _impl_.mode_name_.Get();
}
inline void HealthAndArmingCheckMode::_internal_set_mode_name(const std::string& value) {
  
  _impl_.mode_name_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckMode::_internal_mutable_mode_name() {
  
  return _impl_.mode_name_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthAndArmingCheckMode::release_mode_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _impl_.mode_name_.Release();
}
inline void HealthAndArmingCheckMode::set_allocated_mode_name(std::string* mode_name) {
  if (mode_name != nullptr) {
    
  } else {
    
  }
  _impl_.mode_name_.SetAllocated(mode_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_name_.IsDefault()) {
    _impl_.mode_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
}

// bool can_arm_or_run = 2;
inline void HealthAndArmingCheckMode::clear_can_arm_or_run() {
  _impl_.can_arm_or_run_ = false;
}
inline bool HealthAndArmingCheckMode::_internal_can_arm_or_run() const {
  return _impl_.can_arm_or_run_;
}
inline bool HealthAndArmingCheckMode::can_arm_or_run() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.can_arm_or_run)
  return _internal_can_arm_or_run();
}
inline void HealthAndArmingCheckMode::_internal_set_can_arm_or_run(bool value) {
  
  _impl_.can_arm_or_run_ = value;
}
inline void HealthAndArmingCheckMode::set_can_arm_or_run(bool value) {
  _internal_set_can_arm_or_run(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckMode.can_arm_or_run)
}

// repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3;
inline int HealthAndArmingCheckMode::_internal_problems_size() const {
  return _impl_.problems_.size();
}
inline int HealthAndArmingCheckMode::problems_size() const {
  return _internal_problems_size();
}
inline void HealthAndArmingCheckMode::clear_problems() {
  _impl_.problems_.Clear();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckMode::mutable_problems(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _impl_.problems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >*
HealthAndArmingCheckMode::mutable_problems() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return &_impl_.problems_;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckMode::_internal_problems(int index) const {
  return _impl_.problems_.Get(index);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckMode::problems(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _internal_problems(index);
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckMode::_internal_add_problems() {
  return _impl_.problems_.Add();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckMode::add_problems() {
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _add = _internal_add_problems();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >&
HealthAndArmingCheckMode::problems() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _impl_.problems_;
}

// -------------------------------------------------------------------

// HealthComponentReport

// string name = 1;
inline void HealthComponentReport::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HealthComponentReport::name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthComponentReport::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.name)
}
inline std::string* HealthComponentReport::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthComponentReport.name)
  return _s;
}
inline const std::string& HealthComponentReport::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HealthComponentReport::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthComponentReport::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthComponentReport::release_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthComponentReport.name)
  return _impl_.name_.Release();
}
inline void HealthComponentReport::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthComponentReport.name)
}

// string label = 2;
inline void HealthComponentReport::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& HealthComponentReport::label() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthComponentReport::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.label)
}
inline std::string* HealthComponentReport::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthComponentReport.label)
  return _s;
}
inline const std::string& HealthComponentReport::_internal_label() const {
  return _impl_.label_.Get();
}
inline void HealthComponentReport::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthComponentReport::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthComponentReport::release_label() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthComponentReport.label)
  return _impl_.label_.Release();
}
inline void HealthComponentReport::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthComponentReport.label)
}

// bool is_present = 3;
inline void HealthComponentReport::clear_is_present() {
  _impl_.is_present_ = false;
}
inline bool HealthComponentReport::_internal_is_present() const {
  return _impl_.is_present_;
}
inline bool HealthComponentReport::is_present() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.is_present)
  return _internal_is_present();
}
inline void HealthComponentReport::_internal_set_is_present(bool value) {
  
  _impl_.is_present_ = value;
}
inline void HealthComponentReport::set_is_present(bool value) {
  _internal_set_is_present(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.is_present)
}

// bool has_error = 4;
inline void HealthComponentReport::clear_has_error() {
  _impl_.has_error_ = false;
}
inline bool HealthComponentReport::_internal_has_error() const {
  return _impl_.has_error_;
}
inline bool HealthComponentReport::has_error() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.has_error)
  return _internal_has_error();
}
inline void HealthComponentReport::_internal_set_has_error(bool value) {
  
  _impl_.has_error_ = value;
}
inline void HealthComponentReport::set_has_error(bool value) {
  _internal_set_has_error(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.has_error)
}

// bool has_warning = 5;
inline void HealthComponentReport::clear_has_warning() {
  _impl_.has_warning_ = false;
}
inline bool HealthComponentReport::_internal_has_warning() const {
  return _impl_.has_warning_;
}
inline bool HealthComponentReport::has_warning() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.has_warning)
  return _internal_has_warning();
}
inline void HealthComponentReport::_internal_set_has_warning(bool value) {
  
  _impl_.has_warning_ = value;
}
inline void HealthComponentReport::set_has_warning(bool value) {
  _internal_set_has_warning(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.has_warning)
}

// -------------------------------------------------------------------

// HealthAndArmingCheckReport

// .mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1;
inline bool HealthAndArmingCheckReport::_internal_has_current_mode_intention() const {
  return this != internal_default_instance() && _impl_.current_mode_intention_ != nullptr;
}
inline bool HealthAndArmingCheckReport::has_current_mode_intention() const {
  return _internal_has_current_mode_intention();
}
inline void HealthAndArmingCheckReport::clear_current_mode_intention() {
  if (GetArenaForAllocation() == nullptr && _impl_.current_mode_intention_ != nullptr) {
    delete _impl_.current_mode_intention_;
  }
  _impl_.current_mode_intention_ = nullptr;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckMode& HealthAndArmingCheckReport::_internal_current_mode_intention() const {
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode* p = _impl_.current_mode_intention_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckMode&>(
      ::mavsdk::rpc::events::_HealthAndArmingCheckMode_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckMode& HealthAndArmingCheckReport::current_mode_intention() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
  return _internal_current_mode_intention();
}
inline void HealthAndArmingCheckReport::unsafe_arena_set_allocated_current_mode_intention(
    ::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_mode_intention_);
  }
  _impl_.current_mode_intention_ = current_mode_intention;
  if (current_mode_intention) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::release_current_mode_intention() {
  
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* temp = _impl_.current_mode_intention_;
  _impl_.current_mode_intention_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::unsafe_arena_release_current_mode_intention() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
  
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* temp = _impl_.current_mode_intention_;
  _impl_.current_mode_intention_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::_internal_mutable_current_mode_intention() {
  
  if (_impl_.current_mode_intention_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckMode>(GetArenaForAllocation());
    _impl_.current_mode_intention_ = p;
  }
  return _impl_.current_mode_intention_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::mutable_current_mode_intention() {
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* _msg = _internal_mutable_current_mode_intention();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
  return _msg;
}
inline void HealthAndArmingCheckReport::set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.current_mode_intention_;
  }
  if (current_mode_intention) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(current_mode_intention);
    if (message_arena != submessage_arena) {
      current_mode_intention = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_mode_intention, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.current_mode_intention_ = current_mode_intention;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
}

// repeated .mavsdk.rpc.events.HealthComponentReport health_components = 2;
inline int HealthAndArmingCheckReport::_internal_health_components_size() const {
  return _impl_.health_components_.size();
}
inline int HealthAndArmingCheckReport::health_components_size() const {
  return _internal_health_components_size();
}
inline void HealthAndArmingCheckReport::clear_health_components() {
  _impl_.health_components_.Clear();
}
inline ::mavsdk::rpc::events::HealthComponentReport* HealthAndArmingCheckReport::mutable_health_components(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _impl_.health_components_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport >*
HealthAndArmingCheckReport::mutable_health_components() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return &_impl_.health_components_;
}
inline const ::mavsdk::rpc::events::HealthComponentReport& HealthAndArmingCheckReport::_internal_health_components(int index) const {
  return _impl_.health_components_.Get(index);
}
inline const ::mavsdk::rpc::events::HealthComponentReport& HealthAndArmingCheckReport::health_components(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _internal_health_components(index);
}
inline ::mavsdk::rpc::events::HealthComponentReport* HealthAndArmingCheckReport::_internal_add_health_components() {
  return _impl_.health_components_.Add();
}
inline ::mavsdk::rpc::events::HealthComponentReport* HealthAndArmingCheckReport::add_health_components() {
  ::mavsdk::rpc::events::HealthComponentReport* _add = _internal_add_health_components();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport >&
HealthAndArmingCheckReport::health_components() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _impl_.health_components_;
}

// repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3;
inline int HealthAndArmingCheckReport::_internal_all_problems_size() const {
  return _impl_.all_problems_.size();
}
inline int HealthAndArmingCheckReport::all_problems_size() const {
  return _internal_all_problems_size();
}
inline void HealthAndArmingCheckReport::clear_all_problems() {
  _impl_.all_problems_.Clear();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckReport::mutable_all_problems(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _impl_.all_problems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >*
HealthAndArmingCheckReport::mutable_all_problems() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return &_impl_.all_problems_;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckReport::_internal_all_problems(int index) const {
  return _impl_.all_problems_.Get(index);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckReport::all_problems(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _internal_all_problems(index);
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckReport::_internal_add_all_problems() {
  return _impl_.all_problems_.Add();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckReport::add_all_problems() {
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _add = _internal_add_all_problems();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem >&
HealthAndArmingCheckReport::all_problems() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _impl_.all_problems_;
}

// -------------------------------------------------------------------

// EventsResult

// .mavsdk.rpc.events.EventsResult.Result result = 1;
inline void EventsResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::mavsdk::rpc::events::EventsResult_Result EventsResult::_internal_result() const {
  return static_cast< ::mavsdk::rpc::events::EventsResult_Result >(_impl_.result_);
}
inline ::mavsdk::rpc::events::EventsResult_Result EventsResult::result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResult.result)
  return _internal_result();
}
inline void EventsResult::_internal_set_result(::mavsdk::rpc::events::EventsResult_Result value) {
  
  _impl_.result_ = value;
}
inline void EventsResult::set_result(::mavsdk::rpc::events::EventsResult_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.EventsResult.result)
}

// string result_str = 2;
inline void EventsResult::clear_result_str() {
  _impl_.result_str_.ClearToEmpty();
}
inline const std::string& EventsResult::result_str() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResult.result_str)
  return _internal_result_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventsResult::set_result_str(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.EventsResult.result_str)
}
inline std::string* EventsResult::mutable_result_str() {
  std::string* _s = _internal_mutable_result_str();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.EventsResult.result_str)
  return _s;
}
inline const std::string& EventsResult::_internal_result_str() const {
  return _impl_.result_str_.Get();
}
inline void EventsResult::_internal_set_result_str(const std::string& value) {
  
  _impl_.result_str_.Set(value, GetArenaForAllocation());
}
inline std::string* EventsResult::_internal_mutable_result_str() {
  
  return _impl_.result_str_.Mutable(GetArenaForAllocation());
}
inline std::string* EventsResult::release_result_str() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.EventsResult.result_str)
  return _impl_.result_str_.Release();
}
inline void EventsResult::set_allocated_result_str(std::string* result_str) {
  if (result_str != nullptr) {
    
  } else {
    
  }
  _impl_.result_str_.SetAllocated(result_str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_str_.IsDefault()) {
    _impl_.result_str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.EventsResult.result_str)
}

// -------------------------------------------------------------------

// SubscribeEventsRequest

// -------------------------------------------------------------------

// EventsResponse

// .mavsdk.rpc.events.Event event = 1;
inline bool EventsResponse::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool EventsResponse::has_event() const {
  return _internal_has_event();
}
inline void EventsResponse::clear_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_ != nullptr) {
    delete _impl_.event_;
  }
  _impl_.event_ = nullptr;
}
inline const ::mavsdk::rpc::events::Event& EventsResponse::_internal_event() const {
  const ::mavsdk::rpc::events::Event* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::Event&>(
      ::mavsdk::rpc::events::_Event_default_instance_);
}
inline const ::mavsdk::rpc::events::Event& EventsResponse::event() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResponse.event)
  return _internal_event();
}
inline void EventsResponse::unsafe_arena_set_allocated_event(
    ::mavsdk::rpc::events::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.EventsResponse.event)
}
inline ::mavsdk::rpc::events::Event* EventsResponse::release_event() {
  
  ::mavsdk::rpc::events::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.EventsResponse.event)
  
  ::mavsdk::rpc::events::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::events::Event>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::mutable_event() {
  ::mavsdk::rpc::events::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.EventsResponse.event)
  return _msg;
}
inline void EventsResponse::set_allocated_event(::mavsdk::rpc::events::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.EventsResponse.event)
}

// -------------------------------------------------------------------

// SubscribeHealthAndArmingChecksRequest

// -------------------------------------------------------------------

// HealthAndArmingChecksResponse

// .mavsdk.rpc.events.HealthAndArmingCheckReport report = 1;
inline bool HealthAndArmingChecksResponse::_internal_has_report() const {
  return this != internal_default_instance() && _impl_.report_ != nullptr;
}
inline bool HealthAndArmingChecksResponse::has_report() const {
  return _internal_has_report();
}
inline void HealthAndArmingChecksResponse::clear_report() {
  if (GetArenaForAllocation() == nullptr && _impl_.report_ != nullptr) {
    delete _impl_.report_;
  }
  _impl_.report_ = nullptr;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& HealthAndArmingChecksResponse::_internal_report() const {
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport* p = _impl_.report_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckReport&>(
      ::mavsdk::rpc::events::_HealthAndArmingCheckReport_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& HealthAndArmingChecksResponse::report() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
  return _internal_report();
}
inline void HealthAndArmingChecksResponse::unsafe_arena_set_allocated_report(
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_);
  }
  _impl_.report_ = report;
  if (report) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::release_report() {
  
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::unsafe_arena_release_report() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
  
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::_internal_mutable_report() {
  
  if (_impl_.report_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckReport>(GetArenaForAllocation());
    _impl_.report_ = p;
  }
  return _impl_.report_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::mutable_report() {
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
  return _msg;
}
inline void HealthAndArmingChecksResponse::set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.report_;
  }
  if (report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(report);
    if (message_arena != submessage_arena) {
      report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.report_ = report;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
}

// -------------------------------------------------------------------

// GetHealthAndArmingChecksReportRequest

// -------------------------------------------------------------------

// GetHealthAndArmingChecksReportResponse

// .mavsdk.rpc.events.EventsResult events_result = 1;
inline bool GetHealthAndArmingChecksReportResponse::_internal_has_events_result() const {
  return this != internal_default_instance() && _impl_.events_result_ != nullptr;
}
inline bool GetHealthAndArmingChecksReportResponse::has_events_result() const {
  return _internal_has_events_result();
}
inline void GetHealthAndArmingChecksReportResponse::clear_events_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.events_result_ != nullptr) {
    delete _impl_.events_result_;
  }
  _impl_.events_result_ = nullptr;
}
inline const ::mavsdk::rpc::events::EventsResult& GetHealthAndArmingChecksReportResponse::_internal_events_result() const {
  const ::mavsdk::rpc::events::EventsResult* p = _impl_.events_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::EventsResult&>(
      ::mavsdk::rpc::events::_EventsResult_default_instance_);
}
inline const ::mavsdk::rpc::events::EventsResult& GetHealthAndArmingChecksReportResponse::events_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
  return _internal_events_result();
}
inline void GetHealthAndArmingChecksReportResponse::unsafe_arena_set_allocated_events_result(
    ::mavsdk::rpc::events::EventsResult* events_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.events_result_);
  }
  _impl_.events_result_ = events_result;
  if (events_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::release_events_result() {
  
  ::mavsdk::rpc::events::EventsResult* temp = _impl_.events_result_;
  _impl_.events_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::unsafe_arena_release_events_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
  
  ::mavsdk::rpc::events::EventsResult* temp = _impl_.events_result_;
  _impl_.events_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::_internal_mutable_events_result() {
  
  if (_impl_.events_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::events::EventsResult>(GetArenaForAllocation());
    _impl_.events_result_ = p;
  }
  return _impl_.events_result_;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::mutable_events_result() {
  ::mavsdk::rpc::events::EventsResult* _msg = _internal_mutable_events_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
  return _msg;
}
inline void GetHealthAndArmingChecksReportResponse::set_allocated_events_result(::mavsdk::rpc::events::EventsResult* events_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.events_result_;
  }
  if (events_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(events_result);
    if (message_arena != submessage_arena) {
      events_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, events_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.events_result_ = events_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
}

// .mavsdk.rpc.events.HealthAndArmingCheckReport report = 2;
inline bool GetHealthAndArmingChecksReportResponse::_internal_has_report() const {
  return this != internal_default_instance() && _impl_.report_ != nullptr;
}
inline bool GetHealthAndArmingChecksReportResponse::has_report() const {
  return _internal_has_report();
}
inline void GetHealthAndArmingChecksReportResponse::clear_report() {
  if (GetArenaForAllocation() == nullptr && _impl_.report_ != nullptr) {
    delete _impl_.report_;
  }
  _impl_.report_ = nullptr;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& GetHealthAndArmingChecksReportResponse::_internal_report() const {
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport* p = _impl_.report_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckReport&>(
      ::mavsdk::rpc::events::_HealthAndArmingCheckReport_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& GetHealthAndArmingChecksReportResponse::report() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
  return _internal_report();
}
inline void GetHealthAndArmingChecksReportResponse::unsafe_arena_set_allocated_report(
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_);
  }
  _impl_.report_ = report;
  if (report) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::release_report() {
  
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::unsafe_arena_release_report() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
  
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::_internal_mutable_report() {
  
  if (_impl_.report_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::events::HealthAndArmingCheckReport>(GetArenaForAllocation());
    _impl_.report_ = p;
  }
  return _impl_.report_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::mutable_report() {
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
  return _msg;
}
inline void GetHealthAndArmingChecksReportResponse::set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* report) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.report_;
  }
  if (report) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(report);
    if (message_arena != submessage_arena) {
      report = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.report_ = report;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace events
}  // namespace rpc
}  // namespace mavsdk

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mavsdk::rpc::events::EventsResult_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::events::EventsResult_Result>() {
  return ::mavsdk::rpc::events::EventsResult_Result_descriptor();
}
template <> struct is_proto_enum< ::mavsdk::rpc::events::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mavsdk::rpc::events::LogLevel>() {
  return ::mavsdk::rpc::events::LogLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_events_2fevents_2eproto
